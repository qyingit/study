3.1 稀疏数组
   二维数组转稀疏数组思路:
   1.遍历原始二维数组,得到有效个数sum
   2.根据sum可以创建稀疏数组 sparseArr int[sum+1][3]
   3.将二维数组的有效数据存入到稀疏数组
   稀疏数组转原始的二维数组思路
   1.先读取稀疏数组第一行,根据第一行数据,创建原始二位数组,比如 chessArr2=int[11][11]
   2.在读取稀疏数组后几行的数据,并赋值给原始的二维数组即可

3.2 队列
   队列是一个有序列表,可以用数组或者链表实现,遵循先入先出原则
   数组模拟队列思路:
   1.队列本身是有序列表,使用数组存储队列数据,则队列数组的声明如下,其中maxSize是队列最大容量
   2.因为队列输入,输出由前后端来处理的因此需要两个变量front及rear分别记录队列前后端下标,
   front随着数据输出而改变,而rear是随着数据的输入改变
   3.数据存入队列的时候 addqueue
   1.将尾指针往后移:rear+1,当front === rear 空
   2.若尾指针rear小于队列的最大下标maxSize -1 ,则将数据存入rear所指的数组元素中,否则无法
   存入数据.rear === maxSize -1(队列满)
   环形队列:
   尾索引的下一个为头索引时表示队列满,(rear+1)%maxSize == front[满]
   队列有效数据的个数 (rear+maxSize-front)%maxSize

4.1 单向链表 链表是有序的,以节点的方式链式存储的
   1.链表以节点得方式存储得,是链式存储
   2.每个节点包含data域,next域;指向下一个节点
   3.链表的各个节点不一定是连续存储的
   4.链表分带头节点链表和没有头节点的链表,根据实际需求确定
   链表的创建思路:
       1.先创建一个head头节点,作用就是表示单链表的头
       2.后面每添加一个节点,就直接加入到链表最后
       3.遍历.通过一个辅助变量遍历,帮助遍历整个链表
       4.添加的时候,找到新添加节点的位置,通过辅助变量指针搞定的 新节点.next=temp.next  将temp.next=新的节点
       5.修改节点 先遍历找到该节点修改
       6.删除节点 遍历找到删除的前一个节点temp 然后temp.next = temp.next.next 删除的节点会被垃圾回收机制回收
   单链表面试题:
        1.统计有效节点个数->遍历知道 temp.next != null
        2.查找单链表的倒数第K个节点->遍历两次,第一次得到总长度n,第二次,查找n-k的数据
        3.单链表反转:新定义一个头节点,遍历原链表,分别将节点数据放置到头部
        4.从尾到头打印单链表 ->1.循环使用栈的push装数据 循环pop出栈打印数据
        5.合并有序链表: 1.循环一个链表,将数据插入另一个链表中

4.2 双向链表:
   分析及实现:
   遍历:和单项链表一样,可以向前,向后
   添加:默认添加到双向链表最后
   修改:思路和原来单项链表一样
   删除:可以实现自我删除某个节点

单项链表应用场景:约瑟夫问题,约瑟夫环
   创建环形链表思路
       1.创建第一个节点,让first指向该节点,并形成环形
       2.后面当我们没创建一个新节点,就把该节点,加入已有的环形链表中
       3.遍历环形链表,先让一个辅助指针curBoy,指向first节点,然后循环遍历该环形链表,直到curBoy.next == first结束 当链表中两个
       节点都指向自己的时候就代表结束

5.1 栈 先入后出的有序列表,栈变化的一端为栈顶,另一端为栈底,最先放入的元素在栈底,最后的元素在栈顶
   应用场景：程序的调用,表达式转换,二叉树的遍历
   数组创建栈思路:
   1.定义一个top表示栈顶,初始化为1
   2.入栈的时候top++;stack[top] = data
   3.出栈,intvalue = stack[top],top --, return value
5.2 中缀表达式:
    思路:
    1.通过一个index值,遍历表达式
    2.如果是一个数字,直接入栈
    3.如果是一个符号,分如下情况
    4.如果当前符号栈为空直接入栈,
    5.如果符号栈有操作符,就进行比较,如果当前操作符优先级小于或等于栈中的操作符,就需要从数栈中pop两个数,在从符号栈中pop出一个符号,
    进行运算,得到结果,如数栈,将当前的操作符入符号栈.如果当前的操作符优先级大于栈中操作符,直接入符号栈
    6.当表达式扫描完毕,就顺序从数栈和符号栈中pop出响应的数和符号,并运行
    7.最后在数栈只有一个数字,就是表达式的结果

6.递归:
   递归式自己调用自己，每次调用传入不同的遍量,有助于编程者解决复杂问题,让代码简洁
   递归需要遵守的规则:
   1.执行一个方法,就创建一个新的受保护的独立空间
   2.方法的局部变量是独立的,不会相互影响,比如n变量
   3.如果方法中使用的是引用类型变量,就会共享引用类型的数据
   4.递归必须像退出递归的条件逼近,否则就是无限递归
   5.一个方法执行完毕,就会返回,遵守谁调用,就将结果返回给谁