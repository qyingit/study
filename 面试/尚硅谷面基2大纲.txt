JMM：java的内存模型,定义程序中各个变量(实例字段,静态字段,和构成数组元素对象)的访问方式
     规范:
         线程解锁前，必须把工作内存刷新回主内存
         线程加锁前,必须读取主内存的最新之回到自己的工作线程
         加锁解锁是同一把锁
         线程对变量的操作必须在工作内存中进行,首先将变量从主内存中拷贝到自己的工作内存,然后对边量进行操作,操作完成后将变量写回主内存
         数据读取速度: 硬盘 < 内存 < 缓存 < cpu
     三大特性:可见性，原子性，有序性
volitail的理解
轻量级的同步机制:
     三大特性:
         可见性
         不保证原子性
         禁止指令重排 ：
              计算在执行时为了提高效率，会经过编译器优化，指令并行重排,内存系统重排,最终执行指令
              单线程里面确保程序最终执行结果和代码顺序的一致性
              多线程环境线程交替执行,由于编译器优化重排存在，两个线程中使用的变量能否保证一致性无法确定，结果无法预测
              通过创建内存屏障禁止指令重排,在指令间插入，禁止在屏障前后的指令前后重排
              public void mySort(){
                 int x = 11;
                 int y = 12;
                 x = x + 5;
                 y = x * x;
              }

     volitail使用地方:
         instance = new Object()分三步  1.分配内存空间  2.初始化对象  3.设置instance指向刚分配的内存地址,此时instance != null
        单例模式
     automicInteger:原子性的加减

CAS是什么:
     比较并交换  真实值与期望值比较，如果相等就更新成功,否则失败
     boolean compareAndSet(int oldValue,int newValue){
        int oldValue;
        do{
          oldValue1 = getOldValue();
        }while(compareAndSet(oldValue, oldValue1, newValue))
        return oldValue;
     }
     CAS的缺点:
          1.长时间不成功,会给CPU带来额外开销,
          2.只能保证一个变量的操作原子性
     CAS问题:
           ABA的问题,更新一次了,再更新回去
           解决方法：版本号递增
     AutomicReference<Object> 原子引用类
          通过set将对象变为原子对象
          ABA 时间戳的原子引用，新增一种机制，那就是修改版本号(类似于时间戳)
     AtomicStampedReference<Integer>
          通过getstamp设置与获取时间戳

Arraylist线程不安全，怎么写一个线程安全的集合:
     故障现象:ConcurrentModificationException
     故障原因:
         新增的add并发操作不是原子性
         并发抢修改导致,参考会议签字
     解决方案:
         collections.synchronizedList(new Arraylist())包装为同步list
         CopyOnWriteArrayList  写时复制集合
             使用 volatile Object[] 去装对象 ，并且在增加的时候使用lock加锁
             对集合对象进行复制,扩容,释放锁
         CopyOnWriteArraySet
              底层使用 CopyOnWriteArrayList

         HashSet 底层是 HashMap ，value是一个Object的常量

Map线程不安全
     ConcurretHashMap 使用分段锁  将集合分为16个段,在每个段加锁

java的锁
    ReentrantLock： 默认非公平锁  构造器false不公平 true公平锁
        公平锁：队列,先来后到
        非公平：允许加塞，可能先申请的后获取锁,有优先级反转与饥饿现象，非公平锁的吞吐量比较大
    synchronized：也是一种非公平锁

    递归锁(可重入锁):
        线程在外层方法获取锁的时候，在进入内层方法会自动获取
        线程可以进入任何一个它已经拥有锁所同步的代码块

    自旋锁:
        采用循环的方式去尝试获取锁,这样减小上下文切换的消耗,缺点会消耗cpu
        {
            AtomicReference<Thread> autoThread = new ...;

            mylock(){
                Thread thread = ...;
                while(!autoThread.compareAndSet(null,therad)){

                }
            }
        }
    独占锁(写锁)，共享锁(读锁)，互斥锁
       //TODO 代码
        ReentrantWriteLock lock = ...
        lock.writeLock.lock();
        lock.readLock.lock();
        充分利用ThreadSleep

countDownLatch
         用于线程通信，让一些线程阻塞,直到另一些线程完成操作后才被唤醒
         主要有两个方法,多个线程调用wait阻塞,其他线程调用countDown方法,将计数器减一,当计数器为0时,阻塞的线程被唤醒，继续执行
        //todo 代码

CyclicBarrier 集齐七颗龙族召唤神龙
        可循环使用的屏障,直到最后一个线程到达屏障，才会让所有线程运行
        //todo
        CyclicBarrier  cyclicBarrier = new ...(7,()->{sout(".....")}(线程));
        cyclicBarrier.await();


Semaphore 信号量













































































