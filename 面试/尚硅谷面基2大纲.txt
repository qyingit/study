JMM：java的内存模型,定义程序中各个变量(实例字段,静态字段,和构成数组元素对象)的访问方式
     规范:
         线程解锁前，必须把工作内存刷新回主内存
         线程加锁前,必须读取主内存的最新之回到自己的工作线程
         加锁解锁是同一把锁
         线程对变量的操作必须在工作内存中进行,首先将变量从主内存中拷贝到自己的工作内存,然后对边量进行操作,操作完成后将变量写回主内存
         数据读取速度: 硬盘 < 内存 < 缓存 < cpu
     三大特性:可见性，原子性，有序性
volitail的理解
轻量级的同步机制:
     三大特性:
         可见性
         不保证原子性
         禁止指令重排 ：
              计算在执行时为了提高效率，会经过编译器优化，指令并行重排,内存系统重排,最终执行指令
              单线程里面确保程序最终执行结果和代码顺序的一致性
              多线程环境线程交替执行,由于编译器优化重排存在，两个线程中使用的变量能否保证一致性无法确定，结果无法预测
              通过创建内存屏障禁止指令重排,在指令间插入，禁止在屏障前后的指令前后重排
              public void mySort(){
                 int x = 11;
                 int y = 12;
                 x = x + 5;
                 y = x * x;
              }

     volitail使用地方:
         instance = new Object()分三步  1.分配内存空间  2.初始化对象  3.设置instance指向刚分配的内存地址,此时instance != null
        单例模式
     automicInteger:原子性的加减

CAS是什么:
     比较并交换  真实值与期望值比较，如果相等就更新成功,否则失败
     boolean compareAndSet(int oldValue,int newValue){
        int oldValue;
        do{
          oldValue1 = getOldValue();
        }while(compareAndSet(oldValue, oldValue1, newValue))
        return oldValue;
     }
     CAS的缺点:
          1.长时间不成功,会给CPU带来额外开销,
          2.只能保证一个变量的操作原子性
     CAS问题:
           ABA的问题,更新一次了,再更新回去
           解决方法：版本号递增
     AutomicReference<Object> 原子引用类
          通过set将对象变为原子对象
          ABA 时间戳的原子引用，新增一种机制，那就是修改版本号(类似于时间戳)
     AtomicStampedReference<Integer>
          通过getstamp设置与获取时间戳

Arraylist线程不安全，怎么写一个线程安全的集合:
     故障现象:ConcurrentModificationException
     故障原因:
         新增的add并发操作不是原子性
         并发抢修改导致,参考会议签字
     解决方案:
         collections.synchronizedList(new Arraylist())包装为同步list
         CopyOnWriteArrayList  写时复制集合
             使用 volatile Object[] 去装对象 ，并且在增加的时候使用lock加锁
             对集合对象进行复制,扩容,释放锁
         CopyOnWriteArraySet
              底层使用 CopyOnWriteArrayList

         HashSet 底层是 HashMap ，value是一个Object的常量

Map线程不安全
     ConcurretHashMap 使用分段锁  将集合分为16个段,在每个段加锁

java的锁
    ReentrantLock： 默认非公平锁  构造器false不公平 true公平锁
        公平锁：队列,先来后到
        非公平：允许加塞，可能先申请的后获取锁,有优先级反转与饥饿现象，非公平锁的吞吐量比较大
    synchronized：也是一种非公平锁

    递归锁(可重入锁):
        线程在外层方法获取锁的时候，在进入内层方法会自动获取
        线程可以进入任何一个它已经拥有锁所同步的代码块

    自旋锁:
        采用循环的方式去尝试获取锁,这样减小上下文切换的消耗,缺点会消耗cpu
        {
            AtomicReference<Thread> autoThread = new ...;

            mylock(){
                Thread thread = ...;
                while(!autoThread.compareAndSet(null,therad)){

                }
            }
        }
    独占锁(写锁)，共享锁(读锁)，互斥锁
       //TODO 代码
        ReentrantWriteLock lock = ...
        lock.writeLock.lock();
        lock.readLock.lock();
        充分利用ThreadSleep

countDownLatch
         用于线程通信，让一些线程阻塞,直到另一些线程完成操作后才被唤醒
         主要有两个方法,多个线程调用wait阻塞,其他线程调用countDown方法,将计数器减一,当计数器为0时,阻塞的线程被唤醒，继续执行
        //todo 代码

CyclicBarrier 集齐七颗龙族召唤神龙
        可循环使用的屏障,直到最后一个线程到达屏障，才会让所有线程运行
        //todo
        CyclicBarrier  cyclicBarrier = new ...(7,()->{sout(".....")}(线程));
        cyclicBarrier.await();


Semaphore 信号量
       eg：抢车位
       两个目的,一个用于共享资源的互斥，另一个用以并发线程数的控制

阻塞队列:
      BlockingQueue
          eg:吃火锅人多，不得不阻塞
          阻塞队列好的一面
              不需要关心什么时候阻塞线程,什么时候唤醒线程,因为这一切blockQueue包办了
          不得不组赛，如何管理
              当阻塞队列是空的时候,从队列获取元素会阻塞,当队列是满的时候,往队列里面添加元素会阻塞

      BlockingQueue
          ArrayBlock... 由数组组成的有界阻塞队列

          LinkedBlock... 由链表组成的有界队列 Integer.MAX_VALUE

          Priority... 优先级的无界阻塞队列
          DelayQueue   优先级队列实现的延迟无界阻塞队列
          Synchronized... 不存储元素的阻塞队列,也即单个元素队列

          LinkedTransfer... 链表组成的无界
          Linked....Dequeue 链表组成的双向阻塞队列

          核心方法:
              add(e) 当队列满add抛异常
              remove() 从队列取数据,为空时抛异常
              element() 检查队列空不空,队首元素是谁

              offer() 满是offer返回false
              peek()  队列空peek返回null

              put()  队列满时阻塞
              take() 队列空时阻塞

              offer(e,time,unit) 队列满时,超时取消进队列
              poll(e,time,unit) 获取数据
SynchronousQueue 是一个不存储元素的BlockQueue
      一个put操作必须等待一个take操作

Synchronized与lock的区别
      Synchronized是关键字JVM层面,使用的是同步监视器,Lock是api层面的锁,是一个对象
      Synchronized不需要用于手动释放,lock需要手动释放
      Synchronized等待是不可中断,lock等待是可以中断的 1.tryLock()2.LockInteruptibly
      加锁是否是公平的 sync不公平  lock是可选的
      sync锁不能绑定某个条件，lock可以绑定多个条件condition,可以选择性唤醒

      //todo  循环A-B-C打印代码
      //todo  blockqueue 实现消费者与生产者模式

线程池:
     超过最大线程排队等候
     优势:线程复用,控制最大并发数，管理线程
     特点;
     架构:
         Executors 创建线程工具类
         线程池底层是ThreadPoolExecutor
         四种线程池:
             newFixedThreadPool()  固定大小线程池   执行长期任务
             newsingleThreadExecutor()  单一的线程池
             newCachedThreadPool()  缓存线程池  短期异步小程序
             pool.submit()方法提交一个runnable任务  execute()执行
     几个重要参数:
         maxsize  最大线程数   队列满了线程扩容到maxsize
         coresize  核心线程数  达到coresize会将任务放到缓存队列中
         blockqueue  阻塞队列
         threadfactory 线程工厂
         time  存活时间   队列阻塞了，线程空闲时间达到了就会回收线程到核心线程数
         unit  存活时间单位
         reject  拒绝策略
             四种拒绝策略:
                  AboutPolicy:默认 直接抛异常
                  CallerRunsPolicy:将任务回退到调用线程处理
                  DiscardOldestPolicy: 抛弃队列中等待最久的任务，然后把当前任务加入队列中再尝试提交
                  Discard:直接丢弃任务,不处理也不抛出异常,如果任务可丢失,最好解决方案
         工作中不用executors创建对象:
              fix与single线程池的队列长度为Integer.MAX_VALUE 可能会有请求堆积，导致OOM
              Cached与schedule允许创建的线程数为Integer.MAX_VALUE 可能会创建大量线程,导致OOM
         如何配置参数
             cpu密集型
                  需要知道线程数几核,如果有大量任务,cpu全速运行，cpu核数+1个线程池配置
             io密集型
                  1.并不是一直再执行任务,一般 cpu核数 * 2
                  2.io大量阻塞，cpu核数/1-阻塞系数  阻塞系数再在0.8~0.9
          死锁编码及定位分析
             原因:
                 两个或两个以上的进程因争夺资源造成的相互等待的现象,如果无外力干涉，它们都将无法推进下去

             使用java工具查看
                 jps定位进程号
                 jstack pid  查看线程信息

JVM与GC
    线程共享: 堆（form,to,eden,old），原空间
    线程独占区域 寄存器，栈

类的加载器:
    父类加载机制,双亲委派机制,沙箱安全机制
垃圾回收算法:
    复制： from->to
    标记清除：磁盘碎片
    标记整理：碎片整理，耗时多
    分代收集：
minorGC  form->to->交换

GCRoots:
      虚拟机栈中引用的对象
      方法区中类静态属性引用的对象
      方法区中常量引用对象
      本地方法栈引用的对象
  什么是垃圾:内存中不需要使用的对象就是垃圾
  判断垃圾:
      引用计数:循环引用问题
      可达性分析:根搜索路径算法

JVM的参数
  标配参数:
    -version  -help
  X参数:
    -Xint 解释执行  -Xcomp  第一次使用就编译为本地代码  -Xmixed 混合模式
  XX参数:
    Boolean类型
        -XX:(+_) +开启 -关闭  eg:-XX


jinfo  查看参数信息































































Callable 与 Runnable的区别
        一个返回值,一个没有返回值
        一个抛异常,一个不抛异常
        方法名不一样,一个run,一个call
        RunnableFuture<V> ->FutureTask(Callable callable) 适配器模式
        建议callable的放在最后



























































































































































