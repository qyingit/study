# 11. Channel、ChannelPipeline 和 ChannelHandler

## 11.1 Channel

### 11.1.1 AbstractChannel

Channel 定义了一个传输通道应该有的操作，包括建立连接、关闭连接、读和写等等。

AbtractChannel 是 Channel 接口的一个模板实现，类中包含了以下主要属性：

```java
    // 父类 Channel
    private final Channel parent;
    private final Unsafe unsafe;
    // 对应的 ChannelPipeline
    private final DefaultChannelPipeline pipeline;
    // 绑定的本地地址
    private volatile SocketAddress localAddress;
    // 连接的远程地址
    private volatile SocketAddress remoteAddress;
    // 注册的 EventLoop
    private volatile EventLoop eventLoop;
    // 是否已注册
    private volatile boolean registered;
```

客户端 Channel 的 parent 为 null，服务端 SocketChannel 的 parent 为 ServerSocketChannel。

unsafe 类在 JUC 中也有广泛的使用，一般都是底层的操作。

对于那些 IO 方法，比如 read、write 等，都是直接调用 pipeline 来完成的，如下所示：

```java
    @Override
    public ChannelFuture write(Object msg) {
        return pipeline.write(msg);
    }
```

此类是抽象类，预留了很多模板方法给具体的子类实现，比如 doRegister、doBind 等。

AbstractUnsafe 是内部类，也是 Unsafe 的骨架实现，里面很多方法调用了 Channel 的方法。

**register**

从源码中可以看出，AbstractUnsafe 的 register 方法中只是检查注册的条件和设置结果而已，register0 也是，真正的注册操作是在 doRegister 中实现的，此方法是 protected 类型的抽象方法，在具体的子类中实现。

```java
        // 把 Channel 注册到 EventLoop 中
        @Override
        public final void register(EventLoop eventLoop, final ChannelPromise promise) {
            // EventLoop 不能为空
            if (eventLoop == null) {
                throw new NullPointerException("eventLoop");
            }
            // 已经注册过了，不用再注册了
            if (isRegistered()) {
                promise.setFailure(new IllegalStateException("registered to an event loop already"));
                return;
            }
            // Channel 和 EventLoop 是否配套
            if (!isCompatible(eventLoop)) {
                promise.setFailure(
                        new IllegalStateException("incompatible event loop type: " + eventLoop.getClass().getName()));
                return;
            }

            AbstractChannel.this.eventLoop = eventLoop;

            // 检查调用此方法的线程是不是 EventLoop 对应的线程，如果是，直接调用 register0 方法
            if (eventLoop.inEventLoop()) {
                register0(promise);
            } else {
                // 不是，将注册操作封装成 Runnable，加入到 EventLoop 的任务队列中
                // 一个 EventLoop 可能对应多个 Channel
                try {
                    eventLoop.execute(new Runnable() {
                        @Override
                        public void run() {
                            register0(promise);
                        }
                    });
                } catch (Throwable t) {
                    logger.warn(
                            "Force-closing a channel whose registration task was not accepted by an event loop: {}",
                            AbstractChannel.this, t);
                    closeForcibly();
                    closeFuture.setClosed();
                    safeSetFailure(promise, t);
                }
            }
        }
        
        // 执行注册
        private void register0(ChannelPromise promise) {
            try {
                // 判断当前 Channel 是否打开，没打开就无法注册
                if (!promise.setUncancellable() || !ensureOpen(promise)) {
                    return;
                }
                // 是否为首次注册
                boolean firstRegistration = neverRegistered;
                // 注册，子类实现（以 do 开头的基本都是子类实现）
                doRegister();
                // 设置注册成功
                neverRegistered = false;
                registered = true;

                // Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the
                // user may already fire events through the pipeline in the ChannelFutureListener.
                pipeline.invokeHandlerAddedIfNeeded();

                // 通知 promise 执行成功
                safeSetSuccess(promise);
                // 触发通知已注册事件
                pipeline.fireChannelRegistered();
                // 首次注册的话，就 fire 一个 channelActive，这样如果是注销再注册的话就不会触发多个channel actives事件
                if (isActive()) {
                    if (firstRegistration) {
                        pipeline.fireChannelActive();
                    } else if (config().isAutoRead()) {
                        // 自动开始读取
                        beginRead();
                    }
                }
            } catch (Throwable t) {
                // Close the channel directly to avoid FD leak.
                closeForcibly();
                closeFuture.setClosed();
                safeSetFailure(promise, t);
            }
        }
```

bind、disconnect、shutdownOutput 和上面的 register 类似。

**close**

关闭操作 doClose 在具体的子类中实现，在此 close 函数中调用 doClose0 及 doClose 函数，清空缓冲区，触发 Inactive 和 Deregister 通知事件。

```java
        // 关闭 Channel
        private void close(final ChannelPromise promise, final Throwable cause,
                           final ClosedChannelException closeCause, final boolean notify) {
            if (!promise.setUncancellable()) {
                return;
            }

            // 如果关闭操作已经开始了
            if (closeInitiated) {
                if (closeFuture.isDone()) {
                    // 已经关闭了
                    safeSetSuccess(promise);
                } else if (!(promise instanceof VoidChannelPromise)) { // Only needed if no VoidChannelPromise.
                    // 监听关闭操作是否完成
                    closeFuture.addListener(new ChannelFutureListener() {
                        @Override
                        public void operationComplete(ChannelFuture future) throws Exception {
                            promise.setSuccess();
                        }
                    });
                }
                return;
            }

            // 设置关闭操作已经开始执行
            closeInitiated = true;

            final boolean wasActive = isActive();
            final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
            this.outboundBuffer = null; // Disallow adding any messages and flushes to outboundBuffer.
            Executor closeExecutor = prepareToClose();
            if (closeExecutor != null) {
                // 在处理关闭操作的线程池中执行
                closeExecutor.execute(new Runnable() {
                    @Override
                    public void run() {
                        try {
                            // Execute the close.
                            doClose0(promise);
                        } finally {
                            // Call invokeLater so closeAndDeregister is executed in the EventLoop again!
                            invokeLater(new Runnable() {
                                @Override
                                public void run() {
                                    if (outboundBuffer != null) {
                                        // 释放缓冲区的消息
                                        outboundBuffer.failFlushed(cause, notify);
                                        outboundBuffer.close(closeCause);
                                    }
                                    fireChannelInactiveAndDeregister(wasActive);
                                }
                            });
                        }
                    }
                });
            } else {
                try {
                    // 没有线程池，直接在当前线程执行
                    doClose0(promise);
                } finally {
                    if (outboundBuffer != null) {
                        // 清空消息缓冲区
                        outboundBuffer.failFlushed(cause, notify);
                        outboundBuffer.close(closeCause);
                    }
                }
                // 处于刷新状态，还有数据没发送完
                if (inFlush0) {
                    // 封装成 Runnable 再执行
                    invokeLater(new Runnable() {
                        @Override
                        public void run() {
                            // 触发 Inactive 和 Deregister 事件
                            fireChannelInactiveAndDeregister(wasActive);
                        }
                    });
                } else {
                    // 发送完了，不用异步了，直接执行
                    fireChannelInactiveAndDeregister(wasActive);
                }
            }
        }

        private void doClose0(ChannelPromise promise) {
            try {
                doClose();
                // 设置关闭状态
                closeFuture.setClosed();
                safeSetSuccess(promise);
            } catch (Throwable t) {
                closeFuture.setClosed();
                safeSetFailure(promise, t);
            }
        }
```

**deregister**

deregister 函数用于取消注册，取消之后，同样触发 fireChannelUnregistered 通知事件。

```java
        @Override
        public final void deregister(final ChannelPromise promise) {
            assertEventLoop();

            deregister(promise, false);
        }

        // 取消注册
        private void deregister(final ChannelPromise promise, final boolean fireChannelInactive) {
            if (!promise.setUncancellable()) {
                return;
            }

            // 如果没有注册，就不用取消了
            if (!registered) {
                safeSetSuccess(promise);
                return;
            }

            // 在 EventLoop 中执行取消注册
            invokeLater(new Runnable() {
                @Override
                public void run() {
                    try {
                        // 执行取消注册
                        doDeregister();
                    } catch (Throwable t) {
                        logger.warn("Unexpected exception occurred while deregistering a channel.", t);
                    } finally {
                        if (fireChannelInactive) {
                            pipeline.fireChannelInactive();
                        }
                        if (registered) {
                            registered = false;
                            pipeline.fireChannelUnregistered();
                        }
                        safeSetSuccess(promise);
                    }
                }
            });
        }
```

**write and flush**

write 是把数据写入到缓冲区，flush 才是发送出去。

```java
        // 将消息添加到缓冲区中
        @Override
        public final void write(Object msg, ChannelPromise promise) {
            assertEventLoop();

            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
            if (outboundBuffer == null) {
                // 如果 outboundBuffer 为 null 说明 Channel 关闭，需要设置操作失败
                safeSetFailure(promise, WRITE_CLOSED_CHANNEL_EXCEPTION);
                // 释放消息以避免资源泄露
                ReferenceCountUtil.release(msg);
                return;
            }

            // 检查
            int size;
            try {
                // 过滤 msg，如果不是ByteBuf或者FileRegion就抛错
                msg = filterOutboundMessage(msg);
                size = pipeline.estimatorHandle().size(msg);
                if (size < 0) {
                    size = 0;
                }
            } catch (Throwable t) {
                safeSetFailure(promise, t);
                ReferenceCountUtil.release(msg);
                return;
            }

            // 添加消息，等到 flush
            outboundBuffer.addMessage(msg, size, promise);
        }

        @Override
        public final void flush() {
            assertEventLoop();

            // 缓冲区
            ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
            if (outboundBuffer == null) {
                return;
            }

            // 添加一个标记，意味着所有以前添加的消息都标记为刷新
            outboundBuffer.addFlush();
            flush0();
        }

        protected void flush0() {
            // 已经被冲刷走了
            if (inFlush0) {
                // Avoid re-entrance
                return;
            }

            final ChannelOutboundBuffer outboundBuffer = this.outboundBuffer;
            // Channel 关闭或者没有要写的数据
            if (outboundBuffer == null || outboundBuffer.isEmpty()) {
                return;
            }

            inFlush0 = true;

            // 检查是否是活跃状态
            if (!isActive()) {
                try {
                    if (isOpen()) {
                        // Channel 是打开的，failFlushed 将队列的中的写请求标记为失败
                        outboundBuffer.failFlushed(FLUSH0_NOT_YET_CONNECTED_EXCEPTION, true);
                    } else {
                        // Do not trigger channelWritabilityChanged because the channel is closed already.
                        outboundBuffer.failFlushed(FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);
                    }
                } finally {
                    inFlush0 = false;
                }
                return;
            }

            try {
                // 执行写入
                doWrite(outboundBuffer);
            } catch (Throwable t) {
                if (t instanceof IOException && config().isAutoClose()) {
                    // 遇到异常，尝试关闭
                    close(voidPromise(), t, FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);
                } else {
                    try {
                        shutdownOutput(voidPromise(), t);
                    } catch (Throwable t2) {
                        close(voidPromise(), t2, FLUSH0_CLOSED_CHANNEL_EXCEPTION, false);
                    }
                }
            } finally {
                inFlush0 = false;
            }
        }
```

**invokeLater**

上面的函数中多次使用 invokeLater 执行任务，此函数的作用是把任务加入到 EventLoop 中执行。

```java
        // 在 EvnetLoop 中执行 task
        private void invokeLater(Runnable task) {
            try {
                eventLoop().execute(task);
            } catch (RejectedExecutionException e) {
                logger.warn("Can't invoke task later as EventLoop rejected it", e);
            }
        }
```

### 11.1.2 AbstractNioChannel

从 AbstractNioChannel 的属性可以看出，Netty 中的 Channel 是在 NIO 的 Channel 基础上包装了一层。

```java
    // nio 中 SocketChannel 和 ServerSocketChannel 的公共父类，用于设置 SelectableChannel 参数和进行 IO 操作
    private final SelectableChannel ch;
    // 兴趣事件
    protected final int readInterestOp;
    // Channel 注册到 EventLoop 后返回的选择键
    volatile SelectionKey selectionKey;
```

**doRegister**

注册指的是把当前 Channel 注册到 EventLoop 代表的 Selector 上。这里调用了 NIO 中 Selector 的注册方法进行注册。

注册的时候，把自身当成附件注册进去，在 [EventLoop 线程模型](https://github.com/Augustvic/DubboSourceCodeAnalysis/blob/master/md/dubbo/10.md) 一节中使用过这一功能了，便于从 Selector 中获取 Channel 对象。

```java
    // 执行注册
    @Override
    protected void doRegister() throws Exception {
        // selected 记录是否注册成功
        boolean selected = false;
        for (;;) {
            try {
                // 将当前 Channel 注册到 EventLoop 上，返回 SelectionKey，从 SelectionKey 中可以获取 Channel 对象
                // ops 指定 Channel 对哪几类事件感兴趣
                // OP_READ = 1 << 0 读操作位
                // OP_WRITE = 1 << 2 写操作位
                // OP_CONNECT = 1 << 3 客户端连接服务端
                // OP_ACCEPT = 1 << 4 服务端接收客户端连接请求
                // 0 表示仅仅完成注册操作
                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), 0, this);
                return;
            } catch (CancelledKeyException e) {
                if (!selected) {
                    // 如果是第一次异常，调用 selectNow 将已经取消的 selectionKey 删除
                    eventLoop().selectNow();
                    selected = true;
                    // 继续循环，尝试注册
                } else {
                    // 仍然发生异常，说明注册不可能成功了，抛出异常
                    throw e;
                }
            }
        }
    }
```

**doBeginRead**

首先检查状态，如果 Channel 可用，设置读操作位，即完成了读操作之前的准备工作。

```java
    // 读操作之前的准备工作
    @Override
    protected void doBeginRead() throws Exception {
        // Channel 关闭了，直接返回
        if (inputShutdown) {
            return;
        }
        // 获取当前 selectionKey。
        // 可用的话说明状态正常，可以继续。否则直接返回。
        final SelectionKey selectionKey = this.selectionKey;
        if (!selectionKey.isValid()) {
            return;
        }

        readPending = true;

        final int interestOps = selectionKey.interestOps();
        // 检查读操作位，如果为 0 说明当前没有进行读操作。
        // 设置读操作位。
        if ((interestOps & readInterestOp) == 0) {
            selectionKey.interestOps(interestOps | readInterestOp);
        }
    }
```

### 11.1.3 AbstractNioByteChannel

**doWrite**

可以看出 doWrite 的流程也是比较简单的，在 doWriteBytes 函数中把缓存在 ByteBuf 中的数据发送到 Channel 中。中间通过 writeSpinCount 控制发送的次数，防止线程陷入无限的写操作中。

这个函数在 flush 操作中使用，不能仅仅从名字的 “write” 中判断它的功能，虽然其名字是 “write”，但它做的是 flush 的事情。

```java
    // 把 buffer 中的数据写入到 Channel 中发送（在 flush 中调用，实际上是把数据写入 channel）
    @Override
    protected void doWrite(ChannelOutboundBuffer in) throws Exception {
        int writeSpinCount = -1;

        boolean setOpWrite = false;
        for (;;) {
            // 获取写缓存中第一条要写入的数据
            Object msg = in.current();
            // 没有要写入的数据，取消 OP_WRITE 事件
            if (msg == null) {
                clearOpWrite();
                return;
            }

            // ByteBuf 类型的数据
            if (msg instanceof ByteBuf) {
                ByteBuf buf = (ByteBuf) msg;
                // 可读取字节数
                int readableBytes = buf.readableBytes();
                // 可读字节数为 0，说明消息不可读，删除该消息，继续往后
                if (readableBytes == 0) {
                    in.remove();
                    continue;
                }

                boolean done = false;
                long flushedAmount = 0;
                if (writeSpinCount == -1) {
                    // 获取循环发送的最大次数。一次发送没有完成时，继续循环发送的次数。
                    // 如果不设置，IO 线程会一直尝试写操作，没办法进行其它操作
                    writeSpinCount = config().getWriteSpinCount();
                }
                for (int i = writeSpinCount - 1; i >= 0; i --) {
                    // 调用 doWriteBytes 方法，抽象方法
                    int localFlushedAmount = doWriteBytes(buf);
                    // 空循环，退出循环，释放 IO 线程
                    if (localFlushedAmount == 0) {
                        setOpWrite = true;
                        break;
                    }

                    // 累加发送的字节数
                    flushedAmount += localFlushedAmount;
                    // 发送完毕，退出循环
                    if (!buf.isReadable()) {
                        done = true;
                        break;
                    }
                }

                // 更新发送进度
                in.progress(flushedAmount);

                // 发送成功，把已经发送的数据删除
                if (done) {
                    in.remove();
                } else {
                    // Break the loop and so incompleteWrite(...) is called.
                    break;
                }
            } else if (msg instanceof FileRegion) {
                FileRegion region = (FileRegion) msg;
                boolean done = region.transfered() >= region.count();

                if (!done) {
                    long flushedAmount = 0;
                    if (writeSpinCount == -1) {
                        writeSpinCount = config().getWriteSpinCount();
                    }

                    for (int i = writeSpinCount - 1; i >= 0; i--) {
                        long localFlushedAmount = doWriteFileRegion(region);
                        if (localFlushedAmount == 0) {
                            setOpWrite = true;
                            break;
                        }

                        flushedAmount += localFlushedAmount;
                        if (region.transfered() >= region.count()) {
                            done = true;
                            break;
                        }
                    }

                    in.progress(flushedAmount);
                }

                if (done) {
                    in.remove();
                } else {
                    // Break the loop and so incompleteWrite(...) is called.
                    break;
                }
            } else {
                // Should not reach here.
                throw new Error();
            }
        }
        // 如果没发送完，在 selector 上注册 OP_WRITE 事件
        // 启动刷新线程继续发送之前没发送完的消息
        // 如果发送完了，取消 OP_WRITE 事件
        incompleteWrite(setOpWrite);
    }
    
    // NioSocketChannel.doWriteBytes
    // 把 ByteBuf 中的数据写入 Channel 中
    @Override
    protected int doWriteBytes(ByteBuf buf) throws Exception {
        final int expectedWrittenBytes = buf.readableBytes();
        return buf.readBytes(javaChannel(), expectedWrittenBytes);
    }
    
    // 处理发送任务
    protected final void incompleteWrite(boolean setOpWrite) {
        // Did not write completely.
        if (setOpWrite) {
            // 设置写标识
            // 如果 OP_WRITE 被设置，会不断轮询 Channel 用于处理没有发送完成的消息，
            // 直到清除 SelectionKey 的 OP_WRITE 操作位。
            // 设置了 OP_WRITE 位之后就不用启动独立的 Runnable 来发送消息了。
            setOpWrite();
        } else {
            // 封装 Runnable，加入到 EventLoop 中执行。
            Runnable flushTask = this.flushTask;
            if (flushTask == null) {
                flushTask = this.flushTask = new Runnable() {
                    @Override
                    public void run() {
                        flush();
                    }
                };
            }
            eventLoop().execute(flushTask);
        }
    }
    
    // 设置写标识
    protected final void setOpWrite() {
        final SelectionKey key = selectionKey();
        if (!key.isValid()) {
            return;
        }
        final int interestOps = key.interestOps();
        if ((interestOps & SelectionKey.OP_WRITE) == 0) {
            key.interestOps(interestOps | SelectionKey.OP_WRITE);
        }
    }

    // 清除写标识
    protected final void clearOpWrite() {
        final SelectionKey key = selectionKey();
        // 注册可能已经通过 deregistration 取消了，首先检查 key 是否存在
        if (!key.isValid()) {
            return;
        }
        final int interestOps = key.interestOps();
        // 标志位置为 0
        if ((interestOps & SelectionKey.OP_WRITE) != 0) {
            key.interestOps(interestOps & ~SelectionKey.OP_WRITE);
        }
    }
```

**read**

read 方法在 NioByteUnsafe 中，用于处理读数据的操作。

首先分配缓冲区用于容纳读取到的数据，然后调用 doReadBytes 读取 Channel 中的数据，doReadBytes 方法在 NioSocketChannel 中实现。接着把读事件和读到的数据从 Pipeline 中的 head 节点向后传播，一直到 tail 为止。传播的过程请参考下文中 Pipeline 部分。

```java
        // 把数据读入 ByteBuf 中
        @Override
        public final void read() {
            final ChannelConfig config = config();
            if (!config.isAutoRead() && !isReadPending()) {
                removeReadOp();
                return;
            }

            final ChannelPipeline pipeline = pipeline();
            final ByteBufAllocator allocator = config.getAllocator();
            // 最多读取多少次
            final int maxMessagesPerRead = config.getMaxMessagesPerRead();
            RecvByteBufAllocator.Handle allocHandle = this.allocHandle;
            if (allocHandle == null) {
                this.allocHandle = allocHandle = config.getRecvByteBufAllocator().newHandle();
            }

            ByteBuf byteBuf = null;
            // 记录读取的次数
            int messages = 0;
            boolean close = false;
            try {
                // 读取数据总数
                int totalReadAmount = 0;
                boolean readPendingReset = false;
                do {
                    // 分配 ByteBuf
                    byteBuf = allocHandle.allocate(allocator);
                    // 可写字节数
                    int writable = byteBuf.writableBytes();
                    // 读取的数据量
                    int localReadAmount = doReadBytes(byteBuf);
                    if (localReadAmount <= 0) {
                        // 读不到
                        byteBuf.release();
                        byteBuf = null;
                        close = localReadAmount < 0;
                        if (close) {
                            // There is nothing left to read as we received an EOF.
                            setReadPending(false);
                        }
                        break;
                    }
                    if (!readPendingReset) {
                        readPendingReset = true;
                        setReadPending(false);
                    }
                    // 传播读事件
                    pipeline.fireChannelRead(byteBuf);
                    byteBuf = null;

                    // 超过限制了
                    if (totalReadAmount >= Integer.MAX_VALUE - localReadAmount) {
                        totalReadAmount = Integer.MAX_VALUE;
                        break;
                    }

                    // 累加
                    totalReadAmount += localReadAmount;

                    // 停止读取
                    if (!config.isAutoRead()) {
                        break;
                    }

                    if (localReadAmount < writable) {
                        // Read less than what the buffer can hold,
                        // which might mean we drained the recv buffer completely.
                        break;
                    }
                } while (++ messages < maxMessagesPerRead);

                // 读完了
                pipeline.fireChannelReadComplete();
                // 记录读取的数据量
                allocHandle.record(totalReadAmount);

                if (close) {
                    closeOnRead(pipeline);
                    close = false;
                }
            } catch (Throwable t) {
                handleReadException(pipeline, byteBuf, t, close);
            } finally {
                if (!config.isAutoRead() && !isReadPending()) {
                    removeReadOp();
                }
            }
        }
        
    // NioSocketChannel.doReadBytes
    // 把数据读取到 ByteBuf 中，返回读取到的数据量
    @Override
    protected int doReadBytes(ByteBuf byteBuf) throws Exception {
        return byteBuf.writeBytes(javaChannel(), byteBuf.writableBytes());
    }
```

### 11.1.4 NioSocketChannel

NioSocketChannel 继承自 AbstractNioByteChannel，是客户端 Channel，每一个 Channel 对应一个客户端。

**doConnect**

执行连接操作可能有三种结果：如果连接成功，返回 true；暂时没有连接上，连接结果不确定，将 selectionKey 设置为 OP_CONNECT，监听网络连接操作位，如果失败了，需要关闭客户端；连接失败，直接抛出异常。

```java
    // 连接操作
    @Override
    protected boolean doConnect(SocketAddress remoteAddress, SocketAddress localAddress) throws Exception {
        // 本地 Socket 地址不为空，绑定本地地址
        if (localAddress != null) {
            doBind0(localAddress);
        }

        boolean success = false;
        try {
            // 连接远程地址
            // 连接成功返回 true，还没有应答返回 false，失败抛出 IO 异常
            boolean connected = SocketUtils.connect(javaChannel(), remoteAddress);
            if (!connected) {
                // 还没应答，设置 OP_CONNECT 标志位
                selectionKey().interestOps(SelectionKey.OP_CONNECT);
            }
            success = true;
            return connected;
        } finally {
            // 失败了，关闭客户端连接
            if (!success) {
                doClose();
            }
        }
    }
```

**doWrite**

重写了 AbstractNioByteChannel 中的 doWrite 方法。同样的，这里的功能也是把数据从缓冲区 flush 到 Channel 里面，而不是 write 的功能，这一点需要注意。

```java
    // 把 Buffer 中的数据发送到 Channel 中
    @Override
    protected void doWrite(ChannelOutboundBuffer in) throws Exception {
        for (;;) {
            // 获取需要发送的数据量
            int size = in.size();
            if (size == 0) {
                clearOpWrite();
                break;
            }
            long writtenBytes = 0;
            boolean done = false;
            boolean setOpWrite = false;

            // 返回 Buffer 中的 ByteBuffer
            ByteBuffer[] nioBuffers = in.nioBuffers();
            // ByteBuffer 的个数
            int nioBufferCnt = in.nioBufferCount();
            // 需要发送的总字节数
            long expectedWrittenBytes = in.nioBufferSize();
            SocketChannel ch = javaChannel();

            switch (nioBufferCnt) {
                case 0:
                    // 没有 ByteBuf 要写，可能有其他的，调用父类的 doWrite
                    super.doWrite(in);
                    return;
                case 1:
                    // 只有一个 ByteBuf，获取这个 ByteBuf
                    // 和 default 不一样的只有 ch.write，这里传入一个 ByteBuf，后面传入了数组
                    ByteBuffer nioBuffer = nioBuffers[0];
                    for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {
                        final int localWrittenBytes = ch.write(nioBuffer);
                        if (localWrittenBytes == 0) {
                            setOpWrite = true;
                            break;
                        }
                        expectedWrittenBytes -= localWrittenBytes;
                        writtenBytes += localWrittenBytes;
                        if (expectedWrittenBytes == 0) {
                            done = true;
                            break;
                        }
                    }
                    break;
                default:
                    // 有很多 ByteBuf
                    // 获取最大循环次数
                    for (int i = config().getWriteSpinCount() - 1; i >= 0; i --) {
                        // 三个参数分别为需要发送的 ByteBuf 数组，数组偏移量，发送的 ByteBuf 个数
                        // 返回值是写入 SocketChannel 的字节个数
                        final long localWrittenBytes = ch.write(nioBuffers, 0, nioBufferCnt);
                        // 说明 TCP 发送缓冲区已满，从循环跳出
                        // 设置 OP_WRITE 位，表示 EventLoop 需要继续轮询，发送未完成的消息
                        if (localWrittenBytes == 0) {
                            setOpWrite = true;
                            break;
                        }
                        expectedWrittenBytes -= localWrittenBytes;
                        writtenBytes += localWrittenBytes;
                        if (expectedWrittenBytes == 0) {
                            // 发送完了
                            done = true;
                            break;
                        }
                    }
                    break;
            }

            // 释放已发送的消息
            in.removeBytes(writtenBytes);

            if (!done) {
                // 没发送完
                incompleteWrite(setOpWrite);
                break;
            }
        }
    }
```

### 11.1.5 AbstractNioMessageChannel

AbstractNioMessageChannel 是 NioServerSocketChannel 的父类。

**doWrite**

在循环体内对消息发送，如果从 ChannelOutboundBuffer 中获取不到消息了，说明消息发送完毕，清除写标识，退出循环。doWriteMessage 在具体的子类中实现。

和 AbstractNioByteChannel 的区别是，这里没有区分 ByteBuf/FileRegion，发送的是 POJO 对象。

```java
    @Override
    protected void doWrite(ChannelOutboundBuffer in) throws Exception {
        final SelectionKey key = selectionKey();
        final int interestOps = key.interestOps();

        for (;;) {
            // 从 Buffer 中弹出消息
            Object msg = in.current();
            // 没获取到消息，清除 OP_WRITE 标志位
            if (msg == null) {
                if ((interestOps & SelectionKey.OP_WRITE) != 0) {
                    key.interestOps(interestOps & ~SelectionKey.OP_WRITE);
                }
                break;
            }
            try {
                boolean done = false;
                // 最多执行 writeSpinCount 次
                for (int i = config().getWriteSpinCount() - 1; i >= 0; i--) {
                    // 尝试发送
                    // 这里没有区分 ByteBuf/FileRegion 等
                    if (doWriteMessage(msg, in)) {
                        // 发送成功，跳出循环
                        done = true;
                        break;
                    }
                }

                // 发送完了，删除
                if (done) {
                    in.remove();
                } else {
                    // 没有发送完，设置 OP_WRITE 标识， 不断轮询
                    if ((interestOps & SelectionKey.OP_WRITE) == 0) {
                        key.interestOps(interestOps | SelectionKey.OP_WRITE);
                    }
                    break;
                }
            } catch (Exception e) {
                if (continueOnWriteError()) {
                    in.remove(e);
                } else {
                    throw e;
                }
            }
        }
    }
```

在 NioMessageUnsafe 里面有一个名为 readBuf 的 List 列表，用于保存和服务端连接的客户端 Channel 列表，下面一小节会涉及到。

### 11.1.6 NioServerSocketChannel

**doReadMessage**

在 NioServerSocketChannel 中，读取操作就是接收客户端的连接请求，创建 NioSocketChannel 对象，并把它放入 List 中。

```java
    // 在 NioServerSocketChannel 中，读取操作就是接收客户端的连接请求，然后创建 NioSocketChannel 对象
    @Override
    protected int doReadMessages(List<Object> buf) throws Exception {
        // 通过 ServerSocketChannel 的 accept 接收新的客户端连接
        SocketChannel ch = SocketUtils.accept(javaChannel());

        try {
            // 接收到了，创造一个客户端 Channel，添加到列表中
            if (ch != null) {
                buf.add(new NioSocketChannel(this, ch));
                return 1;
            }
        } catch (Throwable t) {
            logger.warn("Failed to create a new channel from an accepted socket.", t);

            try {
                ch.close();
            } catch (Throwable t2) {
                logger.warn("Failed to close a socket.", t2);
            }
        }

        return 0;
    }
```

此类中有很多方法直接抛出一个异常，没有任何其他的代码，是因为这些方法是 NioSocketChannel 需要使用的方法，NioServerSocketChannel 不会使用，所以不需要实现。

## 11.2 ChannelPipeline

Channel 和 ChannelPipeline 是一一对应的关系，ChannelPipeline 有一个 Channel 类型的属性，代表了其对应哪一个 Channel。

更具体地说，ChannelPipeline 是一个双向链表，链表中每一个节点是一个 ChannelHandlerContext，每个 ChannelHandlerContext 里面是一个 ChannelHandler。如果 ChannelHandler 没有私有的属性，只有公共的方法，那它是可以重复使用的，但一个 ChannelHandlerContext 只能属于某一个而不是多个 ChannelPipeline。

可以把所有的 ChannelHandler 看成一个过滤器链，可以随意定义自己的 ChannelHandler，以便对数据进行操作，例如实现常用的编码和解码等功能。ChannelHandler 将会在 11.3 小节进行详细介绍。

通常所说的入站是指从双向链表中的 head 节点到 tail 节点，出站是指从 tail 节点到 head 节点。head 节点和 tail 节点是 ChannelPipeline 中必须有的 ChannelHandler，不能被删除，所以下文中出现的 addLast 函数指的是在 tail 节点之前添加，而 removeLast 指的是删除 tail 节点的前一个节点。这一点需要注意。

实际上 head 节点比 tail 节点重要得多，无论是出站和入站，真正的操作都是在 head 节点中执行，tail 只是让事件开始传播或者让事件传播到此结束而已。这一点在 11.2.2 小结中可以清楚地看到。

### 11.2.1 双向链表维护

DefaultPipeline 中 TailContext 和 HeadContext 分别表示尾节点和头结点，从源码中可以看到，tailContext 的所有函数体都是空的，说明 tailContext 没有任何作用。HeadContext 分为两类，一类是以 “channel” 开头的函数，其实现如下：

```java
        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            ctx.fireChannelRead(msg);
        }
```

这一类函数是入站事件，read 表示 Channel 发送数据过来了，当前站可以开始读取。在函数中调用了 fireChannelRead，以 “fire” 开头的函数可以看成是通知事件，作用是通知下一个节点（ChannelHandler）进行相应的操作。之后事件就会依次传播，直到结束。

另一类函数形如：

```java
        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
            unsafe.write(msg, promise);
        }
```

这一类是出站事件，事件传播到这里，已经完成了所有 handler 的过滤，write 调用底层的 unsafe，把数据写入到缓冲区中，最后通过 flush 发送到 channel 里面。

**添加节点**

以 addLast 为例：

```java
    @Override
    public final ChannelPipeline addLast(EventExecutorGroup group, String name, ChannelHandler handler) {
        final AbstractChannelHandlerContext newCtx;
        synchronized (this) {
            // 禁止非 Sharable 的 Handler 重复添加到不同的 pipeline 中
            checkMultiplicity(handler);

            // 创建节点 ChannelHandlerContext 节点
            newCtx = newContext(group, filterName(name, handler), handler);

            // 添加节点
            addLast0(newCtx);

            // 当前 Channel 还没有注册在 EventLoop 上，此时没有 EventExecutor 可执行 HandlerAdd 事件
            // 创建一个任务，任务会在 Channel 被注册的时候调用
            if (!registered) {
                newCtx.setAddPending();
                callHandlerCallbackLater(newCtx, true);
                return this;
            }

            // 回调用户的方法
            EventExecutor executor = newCtx.executor();
            if (!executor.inEventLoop()) {
                newCtx.setAddPending();
                executor.execute(new Runnable() {
                    @Override
                    public void run() {
                        callHandlerAdded0(newCtx);
                    }
                });
                return this;
            }
        }
        callHandlerAdded0(newCtx);
        return this;
    }
```

首先检查 Handler 是否可分享，然后创建一个 ChannelHandlerContext。

在 Pipeline 中的每一个 ChannelHandler 都有唯一的名字，filterName 用于确保传入的 name 可用。如果传入的是 null，那么调用 generateName 生成一个唯一的名字，如果不为 null，检查名字是否已经存在，如果存在则抛出异常：

```java
    // 确保唯一的名字
    private String filterName(String name, ChannelHandler handler) {
        if (name == null) {
            // 生成唯一的名字
            return generateName(handler);
        }
        // 检查是否重复
        checkDuplicateName(name);
        return name;
    }
    
    // 检查名字是否重复，重复则抛出异常
    private void checkDuplicateName(String name) {
        if (context0(name) != null) {
            throw new IllegalArgumentException("Duplicate handler name: " + name);
        }
    }
    
    // 获取 name 对应的 Handler
    private AbstractChannelHandlerContext context0(String name) {
        AbstractChannelHandlerContext context = head.next;
        // 从 head 的下一个节点开始遍历所有的 HandlerContext
        while (context != tail) {
            // 找到了，返回
            if (context.name().equals(name)) {
                return context;
            }
            context = context.next;
        }
        // 没找到
        return null;
    }
```

没有指定名字时， Netty 根据 Handler 的类型自动生成，命名规则为类型加编号，例如：DemoChannelHandler#0，DemoChannelHandler#1 等等：

```java
    // 生成唯一的名字
    private String generateName(ChannelHandler handler) {
        // 检查缓存中有没有生成过默认的 name
        // EchoClientHandler 的默认名字是 EchoClientHandler#0
        Map<Class<?>, String> cache = nameCaches.get();
        Class<?> handlerType = handler.getClass();
        String name = cache.get(handlerType);
        if (name == null) {
            // 没有生成过，生成一个名字放入缓存
            name = generateName0(handlerType);
            cache.put(handlerType, name);
        }

        // 如果这一类型的 handler 已经有名字了，说明已经存在，那么需要生成
        // 顺着序号往上，#0、#1 ... 一直到需要没使用过为止
        // 一个用户一般不会把同一类型的多个 handler 放在里面，但是必须确保没有任何冲突
        // 获取 name 对应的 handler
        if (context0(name) != null) {
            String baseName = name.substring(0, name.length() - 1); // Strip the trailing '0'.
            for (int i = 1;; i ++) {
                String newName = baseName + i;
                // 这个 name 没使用过，表示找到了，马上跳出
                if (context0(newName) == null) {
                    name = newName;
                    break;
                }
            }
        }
        return name;
    }

    private static String generateName0(Class<?> handlerType) {
        // 这种类型的第一个名字
        return StringUtil.simpleClassName(handlerType) + "#0";
    }
```

执行添加的流程在 addLast0 中实现。addLast0 是典型的链表操作了，把节点插入到链表中间，分别更新插入节点、前一个节点、后一个节点的指针即可。

```java
    // 添加到链表中 tail 节点的前面
    private void addLast0(AbstractChannelHandlerContext newCtx) {
        AbstractChannelHandlerContext prev = tail.prev;
        newCtx.prev = prev;
        newCtx.next = tail;
        prev.next = newCtx;
        tail.prev = newCtx;
    }
```

如果当前 Channel 还没有注册，把事件包装成 PendingHandlerCallback 节点先保存起来，后续再执行。

callHandlerCallbackLater 如下所示：

```java
    // 封装成任务添加到链表中，等注册完成之后执行
    private void callHandlerCallbackLater(AbstractChannelHandlerContext ctx, boolean added) {
        assert !registered;

        PendingHandlerCallback task = added ? new PendingHandlerAddedTask(ctx) : new PendingHandlerRemovedTask(ctx);
        PendingHandlerCallback pending = pendingHandlerCallbackHead;
        if (pending == null) {
            pendingHandlerCallbackHead = task;
        } else {
            // 找到链表的尾节点
            while (pending.next != null) {
                pending = pending.next;
            }
            // 添加到链表后面
            pending.next = task;
        }
    }
```

添加之后，继续调用 callHandlerAdded0 执行后续事件：

```java
    // 回调
    private void callHandlerAdded0(final AbstractChannelHandlerContext ctx) {
        try {
            // 设置节点状态为添加成功
            ctx.setAddComplete();
            // 后续事件
            ctx.handler().handlerAdded(ctx);
        } catch (Throwable t) {
            // 异常时删除 Context，尽量恢复
            boolean removed = false;
            try {
                // 在双向链表中删除
                remove0(ctx);
                try {
                    // 后续事件
                    ctx.handler().handlerRemoved(ctx);
                } finally {
                    ctx.setRemoved();
                }
                removed = true;
            } catch (Throwable t2) {
                if (logger.isWarnEnabled()) {
                    logger.warn("Failed to remove a handler: " + ctx.name(), t2);
                }
            }

            if (removed) {
                fireExceptionCaught(new ChannelPipelineException(
                        ctx.handler().getClass().getName() +
                        ".handlerAdded() has thrown an exception; removed.", t));
            } else {
                fireExceptionCaught(new ChannelPipelineException(
                        ctx.handler().getClass().getName() +
                        ".handlerAdded() has thrown an exception; also failed to remove.", t));
            }
        }
    }
```

到这里添加节点的流程就结束了，以 “add” 开头的函数基本都执行同样的步骤。

**删除节点**

在删除之前，首先要找到 handler 所在的 Context，由于是链式结构，所以只能从头开始遍历。

其实这一操作耗费不了多少资源，因为在实际情况下，一个 Pipeline 上的 Handler 数量是极其有限的，而且删除操作并不是需要频繁进行的操作。

```java
    // 删除 Handler
    @Override
    public final ChannelPipeline remove(ChannelHandler handler) {
        // getContextOrDie 找到待删除的节点
        remove(getContextOrDie(handler));
        return this;
    }
    
    // 获取 ChannelHandler 对应的 Context
    private AbstractChannelHandlerContext getContextOrDie(ChannelHandler handler) {
        AbstractChannelHandlerContext ctx = (AbstractChannelHandlerContext) context(handler);
        if (ctx == null) {
            throw new NoSuchElementException(handler.getClass().getName());
        } else {
            return ctx;
        }
    }
    
    // 找到 Handler 对应的 Context
    @Override
    public final ChannelHandlerContext context(ChannelHandler handler) {
        if (handler == null) {
            throw new NullPointerException("handler");
        }
        // 从头开始遍历
        AbstractChannelHandlerContext ctx = head.next;
        for (;;) {
            // 遍历完了还没找到，返回 null
            if (ctx == null) {
                return null;
            }
            // 找到了，返回
            if (ctx.handler() == handler) {
                return ctx;
            }
            ctx = ctx.next;
        }
    }
```

如前文所说，头结点和尾节点不能删除，所以在删除之前，首先检查节点是不是头结点或尾节点。

接着在 remove0 中把要删除的节点从链表中移除。

如果还没有注册，同样先保存下来，在注册时再调用。最后回调执行删除的后续操作（如果有的话）。

```java
    private AbstractChannelHandlerContext remove(final AbstractChannelHandlerContext ctx) {
        // 头结点和尾节点不能删
        assert ctx != head && ctx != tail;

        synchronized (this) {
            // 调整双向链表指针，删除节点
            remove0(ctx);

            // 如果 Channel 还没有在 EventLoop 上注册
            // 创建一个任务，任务在 Channel 被注册的时候调用
            if (!registered) {
                callHandlerCallbackLater(ctx, false);
                return ctx;
            }

            // 回调
            EventExecutor executor = ctx.executor();
            if (!executor.inEventLoop()) {
                executor.execute(new Runnable() {
                    @Override
                    public void run() {
                        callHandlerRemoved0(ctx);
                    }
                });
                return ctx;
            }
        }
        callHandlerRemoved0(ctx);
        return ctx;
    }

    // 调整前后指针，把节点删除
    private static void remove0(AbstractChannelHandlerContext ctx) {
        AbstractChannelHandlerContext prev = ctx.prev;
        AbstractChannelHandlerContext next = ctx.next;
        prev.next = next;
        next.prev = prev;
    }
    
    // 调整前后指针，把节点删除
    private static void remove0(AbstractChannelHandlerContext ctx) {
        AbstractChannelHandlerContext prev = ctx.prev;
        AbstractChannelHandlerContext next = ctx.next;
        prev.next = next;
        next.prev = prev;
    }
```

在注册的时候会调用下面的函数来完成暂时保存而没有执行的操作：

```java
    // 在 register0 中调用，处理待执行的 HandlerAdd 和 HandlerRemove 任务
    final void invokeHandlerAddedIfNeeded() {
        assert channel.eventLoop().inEventLoop();
        if (firstRegistration) {
            firstRegistration = false;
            // 注册时候执行 HandlerAdd 和 HandlerRemove 任务
            callHandlerAddedForAllHandlers();
        }
    }
    
    private void callHandlerAddedForAllHandlers() {
        final PendingHandlerCallback pendingHandlerCallbackHead;
        synchronized (this) {
            assert !registered;

            // This Channel itself was registered.
            registered = true;

            // 获取任务链表
            pendingHandlerCallbackHead = this.pendingHandlerCallbackHead;
            this.pendingHandlerCallbackHead = null;
        }
        // 用一个局部变量保存任务链表头部是因为以下代码如果在 synchronized 块内，则当用户在
        // 非 EventLoop 中执行 HandlerAdd() 方法而该方法中又新增一个 handler 时不会发生死锁
        PendingHandlerCallback task = pendingHandlerCallbackHead;
        // 遍历并执行
        while (task != null) {
            task.execute();
            task = task.next;
        }
    }
```

以 “remove” 开头的所有方法流程和上述方法类似。

**销毁**

调用 destroy 函数偶从 tail 到 head 将 Pipeline 链表中所有的节点销毁：

```java
    /**
     * 删除从 tail 到 head 的所有 handler，不包括 head 和 tail
     */
    private synchronized void destroy() {
        // 从 head 的下一个节点开始
        destroyUp(head.next, false);
    }

    private void destroyUp(AbstractChannelHandlerContext ctx, boolean inEventLoop) {
        final Thread currentThread = Thread.currentThread();
        final AbstractChannelHandlerContext tail = this.tail;
        for (;;) {
            if (ctx == tail) {
                destroyDown(currentThread, tail.prev, inEventLoop);
                break;
            }

            final EventExecutor executor = ctx.executor();
            // 参数 inEventLoop 应理解为是否直接执行本段代码的 for 循环部分，也就是说为 true 时不需要提交
            // 一个 destroyUp 任务，为 false 时则需要判断当前执行线程是否为 EventLoop 线程
            // 如果不是，在 executor 里面继续执行后面的 destroy
            if (!inEventLoop && !executor.inEventLoop(currentThread)) {
                final AbstractChannelHandlerContext finalCtx = ctx;
                executor.execute(new Runnable() {
                    @Override
                    public void run() {
                        destroyUp(finalCtx, true);
                    }
                });
                break;
            }

            ctx = ctx.next;
            // 悲观情况下，每一次都要判断是不是 EventLoop 线程
            inEventLoop = false;
        }
    }
```

可以看到 destroy 最初是从 head 而不是 tail 开始遍历，而且在 destroyUp 函数中并没有执行删除相关的操作。原因是需要考虑到以下情况：有一个入站事件正在从 head 向 tail 传播，如果从 tail 开始删除节点，那么入站事件的处理流程将会中断。为了避免这种情况，首先从 head 节点开始往 tail 遍历（如果当前线程不是 EventLoop 的线程，把遍历任务加入调度队列，如果是 EventLoop，直接遍历），当到达 tail 节点之后，确保没有入站事件，才从尾部开始，调用 destroyDown 执行删除操作：

```java
    private void destroyDown(Thread currentThread, AbstractChannelHandlerContext ctx, boolean inEventLoop) {
        // 执行到这里说明已经到了尾节点，入站事件已经在删除之前传播完毕了
        final AbstractChannelHandlerContext head = this.head;
        for (;;) {
            // head 不能删
            if (ctx == head) {
                break;
            }

            final EventExecutor executor = ctx.executor();
            // inEventLoop 一直为 false
            // 每一次都会判断当前线程是否为 EventLoop 线程
            if (inEventLoop || executor.inEventLoop(currentThread)) {
                // 从链表中删除节点
                synchronized (this) {
                    remove0(ctx);
                }
                // 删除之后的后续
                callHandlerRemoved0(ctx);
            } else {
                final AbstractChannelHandlerContext finalCtx = ctx;
                executor.execute(new Runnable() {
                    @Override
                    public void run() {
                        destroyDown(Thread.currentThread(), finalCtx, true);
                    }
                });
                break;
            }

            ctx = ctx.prev;
            inEventLoop = false;
        }
    }
```

### 11.2.2 一次入站/出站事件的流程

**入站**

以读事件为例。

入站事件的源头是 Channel 的 IO 就绪事件。当 EventLoop 中的 Selector 选择当前 Channel 开启 IO 事件的时候，入站事件就开始了，更具体一点，入站读事件是从 AbstractNioByteChannel 中的内部类 NioByteUnsafe 的 read 方法开始的：

```java
        // Channel
        @Override
        public final void read() {
            ...
            final ChannelPipeline pipeline = pipeline();
            ...
            读取结果到 byteBuf 中
            ...
            pipeline.fireChannelRead(byteBuf);
            ...
        }
```

调用 Pipeline 的 fireChannelRead 把读取到的结果传入 Pipeline 中，如下所示：

```java
    // Pipeline
    @Override
    public final ChannelPipeline fireChannelRead(Object msg) {
        AbstractChannelHandlerContext.invokeChannelRead(head, msg);
        return this;
    }
    
    // context
    // 静态方法
    static void invokeChannelRead(final AbstractChannelHandlerContext next, final Object msg) {
        ObjectUtil.checkNotNull(msg, "msg");
        EventExecutor executor = next.executor();
        if (executor.inEventLoop()) {
            // 调用 context 里面的 invokeChannelRead 函数
            next.invokeChannelRead(msg);
        } else {
            executor.execute(new Runnable() {
                @Override
                public void run() {
                    next.invokeChannelRead(msg);
                }
            });
        }
    }
```

head 节点既是 Inbound 类型，也是 Outbound 类型，所以入站事件的第一个 handler 即为 head。

invokeChannelRead 是静态方法，传入的参数是 head 和 msg。如果调用 invokeChannelRead 的线程就是当前 handler 对应的线程，那么调用 handler 的 invokeChannelRead，把消息传递到当前 handler 里面；如果不是，把任务包装成 Runnable 提交到当前 handler 对应线程的调度队列里面，后续由对应线程自己执行。

继续往后看，invokeChannelRead 是 ChannelHandlerContext 里面的函数：

```java
    // context
    private void invokeChannelRead(Object msg) {
        if (invokeHandler()) {
            try {
                // 调用 handler 的 channelRead 处理 read
                ((ChannelInboundHandler) handler()).channelRead(this, msg);
            } catch (Throwable t) {
                // 捕捉到异常，开始传播
                notifyHandlerException(t);
            }
        } else {
            fireChannelRead(msg);
        }
    }
```

在 invokeChannelRead 调用当前 handler 的 channelRead 方法执行自定义的读操作。如果是默认的 ChannelInboundHandlerAdapter，其 channelRead 函数的实现如下：

```java
    // handler
    /**
     * 默认传播。
     */
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        ctx.fireChannelRead(msg);
    }
```

没有任何多余的操作，直接调用了 ChannelHandlerContext 里面的 fireChannelRead。在用户自定义的 handler 中，如果需要将事件传播下去，则调用 context.fireChannelRead，如果不调用，则事件到这里就结束了。

```java
    // context
    // inbound 的 read 通知事件
    @Override
    public ChannelHandlerContext fireChannelRead(final Object msg) {
        invokeChannelRead(findContextInbound(), msg);
        return this;
    }
    
    // context
    private AbstractChannelHandlerContext findContextInbound() {
        AbstractChannelHandlerContext ctx = this;
        do {
            // 往后查找，直到找到 inbound为止
            ctx = ctx.next;
        } while (!ctx.inbound);
        return ctx;
    }
```

这里比较重要的是 findContextInbound 方法，它的作用是找到下一个 Inbound 节点。

找到下一个 Inbound 节点之后，继续调用静态方法 invokeChannelRead，很显然，我们又回到了原点，只是这里的 next 已经变成了下一个节点。

到这里完成了一个 ChannelHandler 的处理，我们可以据此推测出，事件在 Pipeline 的传递其实就是以下事件的迭代：

* invokeChannelRead(next, msg)
* context.invokeChannelRead(msg);
* handler.channelRead(msg);
* context.fireChannelRead(msg)
* context.findContextInbound()

当消息传递到最后一个节点，即 tail 节点时，如下所示：

```java
        @Override
        public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
            onUnhandledInboundMessage(msg);
        }
        
    protected void onUnhandledInboundMessage(Object msg) {
        try {
            logger.debug(
                    "Discarded inbound message {} that reached at the tail of the pipeline. " +
                            "Please check your pipeline configuration.", msg);
        } finally {
            ReferenceCountUtil.release(msg);
        }
    }
```

释放缓冲区就可以了，不做任何其他的操作。也就是说，如果在 handler 中不对接收到的数据做任何操作的话，到 tail 中将会直接释放，也不会做出任何操作。

**出站**

调用 AbstractChannel 的 write 方法时，写事件就开始了：

```java
    @Override
    public ChannelFuture write(Object msg) {
        return pipeline.write(msg);
    }
```

可以看到，和入站事件类似，也是调用了 pipeline 的 write 方法，把事件传递到 pipeline 链中。

```java
    @Override
    public final ChannelFuture write(Object msg) {
        return tail.write(msg);
    }
```

和入站事件的传播顺序完全相反，出站事件是从 tail 节点开始的。将会依次经过以下流程并不断迭代：

* context.write(msg, promise)
* context.write(msg, flush, promise)
* context.findContextOutbound()
* context.invokeWrite(msg, promise)
* context.invokeWrite0(msg, promise)
* handler.write(this, msg, promise)

一直到 head 节点中，调用底层 unsafe 的 write 的方法，写操作就到此结束了。

所以前面说 head 节点要比 tail 重要得多，是因为 head 节点包含了很多和底层有关联的操作，而 tail 基本没什么功能。

```java
        @Override
        public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
            unsafe.write(msg, promise);
        }
```

### 11.2.3 异常事件

异常处理器一般定义在链表末尾（tail 节点前一个位置），并继承自 ChannelDuplexHandler，ChannelDuplexHandler 既是 inbound 类型也是 outbound 类型。

考虑读事件中调用 invokeChannelRead 方法：

```java
    private void invokeChannelRead(Object msg) {
        if (invokeHandler()) {
            try {
                // 调用 handler 的 channelRead 处理 read
                ((ChannelInboundHandler) handler()).channelRead(this, msg);
            } catch (Throwable t) {
                // 捕捉到异常，开始传播
                notifyHandlerException(t);
            }
        } else {
            fireChannelRead(msg);
        }
    }
```

捕捉到异常时，调用 notifyHandlerException 处理：

```java
    private void notifyHandlerException(Throwable cause) {
        if (inExceptionCaught(cause)) {
            if (logger.isWarnEnabled()) {
                logger.warn(
                        "An exception was thrown by a user handler " +
                                "while handling an exceptionCaught event", cause);
            }
            return;
        }
        invokeExceptionCaught(cause);
    }
    
    private void invokeExceptionCaught(final Throwable cause) {
        if (invokeHandler()) {
            try {
                // 调用此 handler 的 exceptionCaught 来处理
                // 默认情况下如果不覆盖这一个方法，将会在 ChannelInboundHandlerAdapter 中调用 exceptionCaught
                // 然后会继续调用 ctx.fireExceptionCaught
                handler().exceptionCaught(this, cause);
            } catch (Throwable error) {
                if (logger.isDebugEnabled()) {
                    logger.debug(
                        "An exception {}" +
                        "was thrown by a user handler's exceptionCaught() " +
                        "method while handling the following exception:",
                        ThrowableUtil.stackTraceToString(error), cause);
                } else if (logger.isWarnEnabled()) {
                    logger.warn(
                        "An exception '{}' [enable DEBUG level for full stacktrace] " +
                        "was thrown by a user handler's exceptionCaught() " +
                        "method while handling the following exception:", error, cause);
                }
            }
        } else {
            fireExceptionCaught(cause);
        }
    }
```

handler 中的 exceptionCaught 函数默认调用 context.fireExceptionCaught 进行处理：

```java
    // 不处理异常，而是把它向后传递
    // 向后指的是 next
    @Override
    public ChannelHandlerContext fireExceptionCaught(final Throwable cause) {
        invokeExceptionCaught(next, cause);
        return this;
    }
    
    static void invokeExceptionCaught(final AbstractChannelHandlerContext next, final Throwable cause) {
        ObjectUtil.checkNotNull(cause, "cause");
        EventExecutor executor = next.executor();
        if (executor.inEventLoop()) {
            next.invokeExceptionCaught(cause);
        } else {
            try {
                executor.execute(new Runnable() {
                    @Override
                    public void run() {
                        next.invokeExceptionCaught(cause);
                    }
                });
            } catch (Throwable t) {
                if (logger.isWarnEnabled()) {
                    logger.warn("Failed to submit an exceptionCaught() event.", t);
                    logger.warn("The exceptionCaught() event that was failed to submit was:", cause);
                }
            }
        }
    }
```

把异常向后传递，这里的“后”特指 next，即 head 到 tail 方向，这也是自定义的异常处理器要加在 tail 前面的原因。

对于 outbound 事件，也是通过 notifyHandlerException 处理异常，即从 head 向 tail 传播。

## 11.3 ChannelHandler

作为开发人员而言，ChannelHandler 是 Netty 框架中最重要的组件，因为 ChannelHandler 是所有
处理入站和出站数据的应用程序逻辑的容器，也使开发人员可以完全自由发挥的部分。可以根据需求自定义想要的 ChannelHandler，例如定义最常用的编码解码器。

ChannelHandler 的典型用途包括：

* 将数据从一种格式转换为另一种格式；
* 提供异常的通知；
* 提供 Channel 变为活动的或者非活动的通知；
* 提供当 Channel 注册到 EventLoop 或者从 EventLoop 注销时的通知；
* 提供有关用户自定义事件的通知。

ChannelHandler 分为 inbound 类型和 outbound 类型，从名字可以看出，它们分别用于入站事件和出站事件，在入站事件的处理过程中，将会跳过所有的 outbound 节点，出站事件同理。

ChannelInboundHandlerAdapter 实现了 ChannelInboundHandler 接口，但是所有的方法都只是把事件向后传递，没有多余的动作。如果用户想要对入站的某一事件进行处理，只需要继承 ChannelInboundHandlerAdapter 实现对应的方法即可，不用管其它方法。ChannelOutboundHandlerAdapter 同理。

下面列举几个 Netty 内置的 ChannelHandler 的实现：

**LoggingHandler**

继承自 ChannelDuplexHandler，说明入站和出站事件都要经过此 handler。用 @Sharable 修饰，说明此 handler 没有状态相关的变量，可以在开发调试的时候：使用static修饰LoggingHandler实例，并在生产环境删除LoggingHandler。

此类有以下成员变量：

```java
    // 默认级别为Debug
    private static final LogLevel DEFAULT_LEVEL = LogLevel.DEBUG;
    // 实际使用的日志处理，slf4j、log4j等
    protected final InternalLogger logger;
    // 日志框架使用的日志级别
    protected final InternalLogLevel internalLevel;
    // Netty使用的日志级别
    private final LogLevel level;
```

以 channelRead 为例，相关函数如下所示：

```java
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        // 先记录一下日志，然后再传播
        logMessage(ctx, "READ", msg);
        ctx.fireChannelRead(msg);
    }
    
    private void logMessage(ChannelHandlerContext ctx, String eventName, Object msg) {
        if (logger.isEnabled(internalLevel)) {
            logger.log(internalLevel, format(ctx, formatMessage(eventName, msg)));
        }
    }
    
    // 消息转变成 String
    protected String formatMessage(String eventName, Object msg) {
        if (msg instanceof ByteBuf) {
            return formatByteBuf(eventName, (ByteBuf) msg);
        } else if (msg instanceof ByteBufHolder) {
            return formatByteBufHolder(eventName, (ByteBufHolder) msg);
        } else {
            return formatNonByteBuf(eventName, msg);
        }
    }
```

**ByteToMessageDecoder**

解码器是 ChannelHandler 最常见的一种形式，由于网络数据传输的基本单位值字节，编码解码就成为了必不可少的流程。

ByteToMessageDecoder 是把字节解码成消息帧，之后再由 MessageToMessageDecoder 解码成 POJO 对象。

由于可能出现的粘包/拆包问题，每一次接收到的并不一定是一个完整的对象，在 ByteToMessageDecoder 中，使用自定义的 Cumulation 累积器保存临时的数据：

```java
    /**
     * 累积器。
     */
    public interface Cumulator {
        /**
         * 返回保存了累积字节的 ByteBuf。
         * in 表示该次 channelRead 读取到的新数据。
         */
        ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in);
    }
    
    /**
     * Cumulator 的实现。
     */
    public static final Cumulator MERGE_CUMULATOR = new Cumulator() {
        @SuppressWarnings("deprecation")
        @Override
        public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {
            final ByteBuf buffer;
            // 如果缓冲区容量不够容纳待写入的数据
            // 引用计数大于 1
            if (cumulation.writerIndex() > cumulation.maxCapacity() - in.readableBytes()
                    || cumulation.refCnt() > 1 || cumulation instanceof ReadOnlyByteBuf) {
                // 扩容，创建一个新的，销毁老的缓冲区
                buffer = expandCumulation(alloc, cumulation, in.readableBytes());
            } else {
                buffer = cumulation;
            }
            buffer.writeBytes(in);
            in.release();
            return buffer;
        }
    };
    
    /**
     * Cumulator 的实现。使用 CompositeByteBuf，不需要每次扩容都进行内存复制，但是使用了更复杂的索引。
     */
    public static final Cumulator COMPOSITE_CUMULATOR = new Cumulator() {
        @Override
        public ByteBuf cumulate(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in) {
            ByteBuf buffer;
            if (cumulation.refCnt() > 1) {
                // 在 refCnt 计数大于 1 的时候扩容
                buffer = expandCumulation(alloc, cumulation, in.readableBytes());
                buffer.writeBytes(in);
                in.release();
            } else {
                // 引用计数大于 1，使用 CompositeByteBuf
                CompositeByteBuf composite;
                if (cumulation instanceof CompositeByteBuf) {
                    composite = (CompositeByteBuf) cumulation;
                } else {
                    // 原来的 ByteBuf 不是 Composite 类型，创建一个新的
                    composite = alloc.compositeBuffer(Integer.MAX_VALUE);
                    composite.addComponent(true, cumulation);
                }
                // 把需要读取的 ByteBuf 添加到 CompositeByteBuf 中
                composite.addComponent(true, in);
                buffer = composite;
            }
            return buffer;
        }
    };
```

参数 cumulation 表示当前的累积区，in 表示读取到的数据。expandCumulation 方法用于扩容：

```java
    // 对累积区扩容
    static ByteBuf expandCumulation(ByteBufAllocator alloc, ByteBuf cumulation, int readable) {
        ByteBuf oldCumulation = cumulation;
        // 扩容后新的缓冲区
        cumulation = alloc.buffer(oldCumulation.readableBytes() + readable);
        // 把老的数据写到里面
        cumulation.writeBytes(oldCumulation);
        // 释放老的缓冲区
        oldCumulation.release();
        return cumulation;
    }
```

默认使用的累加器是 MERGE_CUMULATOR。

此类中主要包括以下成员变量：

```java
    // 累积区
    ByteBuf cumulation;
    // 默认使用 MERGE 累积器
    private Cumulator cumulator = MERGE_CUMULATOR;
    // 设置为 true 后每个 channelRead 事件只解码出一个结果，某些特殊协议使用
    private boolean singleDecode;
    // 解码结果为空
    private boolean decodeWasNull;
    // 是否首个消息
    private boolean first;
    private byte decodeState = STATE_INIT;
    // 累积区不丢弃字节的最大次数，16 次后开始丢弃
    private int discardAfterReads = 16;
    // 累积区不丢弃字节的 channelRead 次数
    private int numReads;
```

在 channelRead 方法中只处理 ByteBuf 类型的消息，如果消息是其他类型，直接向后传递，不进行任何处理。

在 channelRead 中还进行了分配累积区、统计读取次数，传播事件等工作。在 finally 的流程中可以看到，如果缓冲区没有数据了，需要释放缓冲区；如果读取次数超过了 discardAfterReads 次且累积区还有数据，将会主动放弃一些字节，防止累积区占用过多内存。

具体的解码操作是调用了 callDecode 完成，解析出数据后，调用 fireChannelRead 把消息往后传递。

```java
    @Override
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
        // 只对 ByteBuf 类型进行处理
        if (msg instanceof ByteBuf) {
            // 解码结果列表，在线程中缓存，可循环使用
            CodecOutputList out = CodecOutputList.newInstance();
            try {
                ByteBuf data = (ByteBuf) msg;
                first = cumulation == null;
                // 如果是首次解码
                if (first) {
                    // 直接把 data 当成累积区
                    cumulation = data;
                } else {
                    // 如果不是首次，需要分配空间
                    cumulation = cumulator.cumulate(ctx.alloc(), cumulation, data);
                }
                // 解码操作
                callDecode(ctx, cumulation, out);
            } catch (DecoderException e) {
                throw e;
            } catch (Exception e) {
                throw new DecoderException(e);
            } finally {
                if (cumulation != null && !cumulation.isReadable()) {
                    // 如果累积区没有字节数据了，说明处理完毕
                    numReads = 0;
                    // 释放
                    cumulation.release();
                    cumulation = null;
                } else if (++ numReads >= discardAfterReads) {
                    // 连续 discardAfterReads 次之后，累积区还有字节数据，丢弃一部分数据
                    // 主动丢弃，防止累积区占用大量内存甚至引发 OOM
                    numReads = 0;
                    discardSomeReadBytes();
                }

                int size = out.size();
                // 把本次没有解码出数据
                decodeWasNull = !out.insertSinceRecycled();
                // 触发事件，把解码的结果传递给下一个 handler
                fireChannelRead(ctx, out, size);
                // 回收解码的结果
                out.recycle();
            }
        } else {
            ctx.fireChannelRead(msg);
        }
    }
    
    // 达到限制次数了，丢弃一些数据
    protected final void discardSomeReadBytes() {
        // 需要满足条件才能丢弃
        // 引用计数等于 1 才能丢弃，如果大于 1 说明该累积区还在被使用
        if (cumulation != null && !first && cumulation.refCnt() == 1) {
            cumulation.discardSomeReadBytes();
        }
    }
```

callDecode 中循环解码，解析到数据立刻发送出去，并进行下一次解析。

解码操作在 decode 中完成，decode 是此类中唯一的抽象类，由开发者根据需要自己实现。

```java
    protected void callDecode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
        try {
            while (in.isReadable()) {
                int outSize = out.size();

                if (outSize > 0) {
                    // out 里面有解码出的消息，立刻传递
                    fireChannelRead(ctx, out, outSize);
                    out.clear();

                    // 检查 handler 是否被删除
                    if (ctx.isRemoved()) {
                        break;
                    }
                    outSize = 0;
                }

                int oldInputLength = in.readableBytes();
                // 解码
                decodeRemovalReentryProtection(ctx, in, out);

                // 检查 handler 是否被删除
                if (ctx.isRemoved()) {
                    break;
                }

                // outSize 恒等于 0 ，因为上面已经设置过了
                if (outSize == out.size()) {
                    if (oldInputLength == in.readableBytes()) {
                        // 没有解码出消息，因为可读的数据没变
                        break;
                    } else {
                        // 读取了一部分消息，但是没有解码出消息，因为 out 里面什么都没有
                        // 说明需要更多的数据，继续解码
                        continue;
                    }
                }
                // 运行到这里说明已经解码出消息了
                if (oldInputLength == in.readableBytes()) {
                    // 解码出消息但是 in 的字节数没变，说明有 bug
                    throw new DecoderException(
                            StringUtil.simpleClassName(getClass()) +
                                    ".decode() did not read anything but decoded a message.");
                }

                // 设定了只解码一次，退出循环
                if (isSingleDecode()) {
                    break;
                }
            }
        } catch (DecoderException e) {
            throw e;
        } catch (Exception cause) {
            throw new DecoderException(cause);
        }
    }
    
    final void decodeRemovalReentryProtection(ChannelHandlerContext ctx, ByteBuf in, List<Object> out)
            throws Exception {
        // 设置解码器正在解码状态，防止解码过程中另一个线程调用 handlerRemoved 销毁数据
        decodeState = STATE_CALLING_CHILD_DECODE;
        try {
            // 解码
            decode(ctx, in, out);
        } finally {
            //decodeState == STATE_HANDLER_REMOVED_PENDING 表示在解码过程中，有另外的线程把 ctx 移除了
            // 这时候需要由当前线程调用 handlerRemoved 方法来完成数据销毁
            boolean removePending = decodeState == STATE_HANDLER_REMOVED_PENDING;
            decodeState = STATE_INIT;
            if (removePending) {
                handlerRemoved(ctx);
            }
        }
    }
```

channelReadComplete 用于读事件完成后的通知：

```java
    // 读事件完成后的处理
    @Override
    public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {
        // 连续读的次数
        numReads = 0;
        // 丢弃已读数据，节约内存
        discardSomeReadBytes();
        if (decodeWasNull) {
            // 没有解码出结果，继续读
            decodeWasNull = false;
            if (!ctx.channel().config().isAutoRead()) {
                ctx.read();
            }
        }
        ctx.fireChannelReadComplete();
    }
```

handlerRemoved 用于把 handler 从 ChannelPipeline 中移除，移除时如果还有没被解码的数据，将数据传递到下一个处理器：

```java
    // 将 handler 从 ChannelPipeline 中移除
    @Override
    public final void handlerRemoved(ChannelHandlerContext ctx) throws Exception {
        // 是否正在解码中
        if (decodeState == STATE_CALLING_CHILD_DECODE) {
            // 正在解码中就把状态标志为 STATE_HANDLER_REMOVED_PENDING，
            // 表示要销毁数据，等解码线程解完码后销毁数据，自己直接返回
            decodeState = STATE_HANDLER_REMOVED_PENDING;
            return;
        }
        ByteBuf buf = cumulation;
        // 累积区有数据
        if (buf != null) {
            cumulation = null;
            int readable = buf.readableBytes();
            if (readable > 0) {
                // 读取缓冲区的数据
                ByteBuf bytes = buf.readBytes(readable);
                // 释放
                buf.release();
                // 把数据传到下一个 handler
                ctx.fireChannelRead(bytes);
            } else {
                // 没有可读的，直接释放
                buf.release();
            }
            numReads = 0;
            // 发布读取完成通知
            ctx.fireChannelReadComplete();
        }
        // 删除
        handlerRemoved0(ctx);
    }
```

**LineBasedFrameDecoder**

LineBasedFrameDecoder 继承自 ByteToMessageDecoder，是一个基于分隔符的解码器，使用分隔符来应对粘包/拆包的问题，使用的分隔符为： windows 的 \r\n 和 linux 的 \n。

该类中的成员变量包括：

```java
    // 最大帧的长度，超过这个长度将会抛出 TooLongFrameException 异常
    private final int maxLength;
    // 是否快速失败
    // true 表示当帧长度过长立即抛出异常，不再读取整个帧
    // false 表示读完整个帧再抛出异常
    private final boolean failFast;
    // 是否略过分隔符，tru 表示解码结果不包括分隔符
    private final boolean stripDelimiter;

    // 超过最大帧长度是否丢弃字节
    private boolean discarding;
    // 丢弃的字节数
    private int discardedBytes;

    // 最后一次扫描的位置
    private int offset;
```

所有的函数都围绕 decode 实现：

```java
    @Override
    protected final void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
        // 解码出单个消息帧
        Object decoded = decode(ctx, in);
        if (decoded != null) {
            out.add(decoded);
        }
    }
    
    /**
     * 解码出单个消息帧。
     *
     * @param   ctx             the {@link ChannelHandlerContext} which this {@link ByteToMessageDecoder} belongs to
     * @param   buffer          the {@link ByteBuf} from which to read data
     * @return  frame           the {@link ByteBuf} which represent the frame or {@code null} if no frame could
     *                          be created.
     */
    protected Object decode(ChannelHandlerContext ctx, ByteBuf buffer) throws Exception {
        // 找到行分隔符索引
        final int eol = findEndOfLine(buffer);
        if (!discarding) {
            if (eol >= 0) {
                // 查询到了换行符的位置
                final ByteBuf frame;
                // 需要读取的长度
                final int length = eol - buffer.readerIndex();
                // 分隔符的长度
                final int delimLength = buffer.getByte(eol) == '\r'? 2 : 1;

                // 长度大于限制
                if (length > maxLength) {
                    // 把 readerIndex 设置为分隔符之后的位置，相当于直接丢弃了
                    buffer.readerIndex(eol + delimLength);
                    // 传播异常
                    fail(ctx, length);
                    return null;
                }

                // 正常情况
                if (stripDelimiter) {
                    // 读取分隔符之前的内容
                    frame = buffer.readSlice(length);
                    // 跳过分隔符
                    buffer.skipBytes(delimLength);
                } else {
                    // 读取包括分隔符在内的内容
                    frame = buffer.readSlice(length + delimLength);
                }
                // 返回子缓冲区
                return frame.retain();
            } else {
                // 没找到分隔符位置
                // 可读字节长度
                final int length = buffer.readableBytes();
                // 可读字节数大于长度限制
                if (length > maxLength) {
                    // 记录需要丢弃的字节数（当前所有字节）
                    discardedBytes = length;
                    // readerIndex 跳过当前所有字节
                    buffer.readerIndex(buffer.writerIndex());
                    // 设置标记
                    discarding = true;
                    offset = 0;
                    // 传播异常
                    if (failFast) {
                        fail(ctx, "over " + discardedBytes);
                    }
                }
                return null;
            }
        } else {
            // discarding 为 true，说明之前发生了异常，需要丢弃一个消息
            if (eol >= 0) {
                // 如果获取到了分隔符，丢弃行为到此为止，分隔符后面的就不要再丢弃了
                // length 为需要丢弃的消息和分隔符之前的有效消息的总长度
                final int length = discardedBytes + eol - buffer.readerIndex();
                // 分隔符长度
                final int delimLength = buffer.getByte(eol) == '\r'? 2 : 1;
                // 设置 readerIndex，相当于继续丢弃了分隔符之前的字节
                buffer.readerIndex(eol + delimLength);
                // 设置标记
                discardedBytes = 0;
                discarding = false;
                // 抛异常
                if (!failFast) {
                    fail(ctx, length);
                }
            } else {
                // 没找到分隔符，增加 discardedBytes，继续丢弃字节
                discardedBytes += buffer.readableBytes();
                buffer.readerIndex(buffer.writerIndex());
            }
            return null;
        }
    }
```

首先是找到分隔符，如果发生了异常（之前有需要丢弃的情况）或者分隔符之前的数据太长了，那么直接丢弃，从分隔符之后重新开始；如果满足读取的条件，那么读取这一段数据并返回。

从这段代码可以看出两点，一点是只有两个分隔符之间的数据才会读取，其他不符合条件的数据都直接丢弃，另外一点是 ByteToMessageDecoder 确实不是完整的解码操作，这里只是把数据流变成消息帧，还需要另外的解码器把消息帧变成 POJO 对象。

寻找分隔符的过程很简单，就是依次遍历：

```java
    /**
     * 找到行分隔符，返回其索引。
     * 没找到返回 -1。
     */
    private int findEndOfLine(final ByteBuf buffer) {
        int totalLength = buffer.readableBytes();
        int i = buffer.forEachByte(buffer.readerIndex() + offset, totalLength - offset, ByteBufProcessor.FIND_LF);
        if (i >= 0) {
            offset = 0;
            // 前一个字节是 ’\r'
            if (i > 0 && buffer.getByte(i - 1) == '\r') {
                // 往前挪一位
                i--;
            }
        } else {
            offset = totalLength;
        }
        return i;
    }
```

## 11.4 参考

* 《Netty 实战》
* 《Netty 权威指南》
* [05-Channel实现之AbstractChannel](https://blog.csdn.net/my_momo_csdn/article/details/102746944)
* [自顶向下深入分析Netty（七）--ChannelPipeline源码实现](https://www.jianshu.com/p/0e15165714fc)
* [自顶向下深入分析Netty（八）--ChannelHandler](https://www.jianshu.com/p/a9bcd89553f5)
* [Pipeline的入站流程详解（netty源码死磕7）](https://blog.51cto.com/14033611/2309993?source=dra)
* [netty源码分析之pipeline(二)](https://www.jianshu.com/p/087b7e9a27a2)
* [netty-读半包处理--ByteToMessageDecoder](https://www.freesion.com/article/629652675/)