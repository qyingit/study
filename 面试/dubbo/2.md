# 2. SPI

## 2.1 Java SPI

用简单的话说，SPI（Service Provider Interface）是一种服务（接口和实现类）发现机制，将接口实现类的全限定名写在配置文件中，并由服务加载器读取配置文件，加载实现类，即为某个接口寻找具体的实现。这样可以在运行时，动态为接口替换实现类。这样做也是为了模块设计的可拔插原则。SPI 中最核心的是工具类 java.util.ServiceLoader，在测试程序中调用 ServiceLoader.load 方法开启 SPI：

```java
    public static <S> ServiceLoader<S> load(Class<S> service) {
        // 当前线程上下文的类加载器
        ClassLoader cl = Thread.currentThread().getContextClassLoader();
        return ServiceLoader.load(service, cl);
    }
    
    public static <S> ServiceLoader<S> load(Class<S> service, ClassLoader loader) {
        return new ServiceLoader<>(service, loader);
    }
    
    // 构造函数
    private ServiceLoader(Class<S> svc, ClassLoader cl) {
        service = Objects.requireNonNull(svc, "Service interface cannot be null");
        loader = (cl == null) ? ClassLoader.getSystemClassLoader() : cl;
        acc = (System.getSecurityManager() != null) ? AccessController.getContext() : null;
        reload();
    }
```

可以看到，首先是使用构造函数构造一个 ServiceLoader 对象，ServiceLoader 的类属性主要有以下几个：

```java
    // 配置文件所在的文件夹
    private static final String PREFIX = "META-INF/services/";

    // 需要被加载的服务（类或接口）
    private final Class<S> service;

    // 类加载器
    private final ClassLoader loader;

    // 访问控制
    private final AccessControlContext acc;

    // 服务提供者
    private LinkedHashMap<String,S> providers = new LinkedHashMap<>();

    // 迭代器，类的懒加载器，只有在迭代时才加载
    private LazyIterator lookupIterator;
```

构造函数在上述属性初始化完成后，调用了 reload 函数开始真正的服务发现流程，reload 函数如下所示：

```java
    // 构造 LazyIterator 迭代器。
    public void reload() {
        providers.clear();
        lookupIterator = new LazyIterator(service, loader);
    }
```

LazyIterator 是 ServiceLoader 比较核心的部分，因为 ServiceLoader 本质是一个迭代器。

```java
for (Service service : ServiceLoader) {
    service.hello();
}
```

如上述示例，当我们在 main 方法里面通过 foreach 迭代服务的时候，会调用 ServiceLoader 类里面的 iterator 方法返回的迭代器，进行循环迭代，而 iterator 返回的迭代器则是基于 LazyIterator 创建的，其中 lookupIterator 就是上文中的 LazyIterator 对象实例：

```java
    public Iterator<S> iterator() {
        return new Iterator<S>() {

            Iterator<Map.Entry<String,S>> knownProviders
                = providers.entrySet().iterator();

            public boolean hasNext() {
                if (knownProviders.hasNext())
                    return true;
                return lookupIterator.hasNext();
            }

            public S next() {
                if (knownProviders.hasNext())
                    return knownProviders.next().getValue();
                return lookupIterator.next();
            }

            public void remove() {
                throw new UnsupportedOperationException();
            }

        };
    }
```

LazyIterator 实现了 Iterator 接口，核心方法为 next 和 hasNext。

```java
    private class LazyIterator
        implements Iterator<S>
    {
        // 服务接口类
        Class<S> service;
        // 加载器
        ClassLoader loader;
        // 服务的 URL 枚举
        Enumeration<URL> configs = null;
        // 要加载的服务的名称集合；
        Iterator<String> pending = null;
        // 下一个要加载的服务名称
        String nextName = null;

        // 构造函数
        private LazyIterator(Class<S> service, ClassLoader loader) {
            this.service = service;
            this.loader = loader;
        }
        
        ...
        ...
    }
```

可以看到其实 next 方法中没有实质性的操作，"next" 逻辑是放在私有方法 nextService 中。

```java
        public S next() {
            // 首先根据判断 acc 是否为空，若为空则说明没有设置安全策略直接调用 nextService 方法，否则以特权方式调用 nextService 方法
            if (acc == null) {
                return nextService();
            } else {
                PrivilegedAction<S> action = new PrivilegedAction<S>() {
                    public S run() { return nextService(); }
                };
                return AccessController.doPrivileged(action, acc);
            }
        }
        
        private S nextService() {
            // 判断是否有下一个
            if (!hasNextService())
                throw new NoSuchElementException();
            // 下一个的名字
            String cn = nextName;
            nextName = null;
            Class<?> c = null;
            try {
                // 反射的方式加载 cn 类
                c = Class.forName(cn, false, loader);
            } catch (ClassNotFoundException x) {
                fail(service,
                     "Provider " + cn + " not found");
            }
            // 检查是否符合要求
            // 是否是子类（实现类）
            if (!service.isAssignableFrom(c)) {
                fail(service,
                     "Provider " + cn  + " not a subtype");
            }
            // 检查类型
            // 如果符合要求，将加载的类放入 providers 中，然后返回当前加载到的类
            try {
                S p = service.cast(c.newInstance());
                providers.put(cn, p);
                return p;
            } catch (Throwable x) {
                fail(service,
                     "Provider " + cn + " could not be instantiated",
                     x);
            }
            throw new Error();          // This cannot happen
        }
```

从上面的 next 方法也可以看出，LazyIterator 确实是懒加载的方式，迭代的时候才加载某个具体的实现类。

另一个核心的方法是 hasNext 方法，用于判断是否还有下一个。同样的，hasNext 不包含逻辑实现，真正的实现是在 hasNextService 方法中。

```java
        public boolean hasNext() {
            if (acc == null) {
                return hasNextService();
            } else {
                PrivilegedAction<Boolean> action = new PrivilegedAction<Boolean>() {
                    public Boolean run() { return hasNextService(); }
                };
                return AccessController.doPrivileged(action, acc);
            }
        }

        private boolean hasNextService() {
            // nextName 有值，返回 true
            if (nextName != null) {
                return true;
            }
            // 如果 configs 为 null，对 configs 初始化
            if (configs == null) {
                try {
                    // 前缀加真正的全类名才是完整的名字
                    // 前缀为 “META-INF/services/”，需要把配置文件放在 resources 的此目录下。
                    String fullName = PREFIX + service.getName();
                    // 对 fullName 定位，返回 URL 给 configs
                    if (loader == null)
                        configs = ClassLoader.getSystemResources(fullName);
                    else
                        configs = loader.getResources(fullName);
                } catch (IOException x) {
                    fail(service, "Error locating configuration files", x);
                }
            }
            // 根据 URL，读取配置文件
            while ((pending == null) || !pending.hasNext()) {
                if (!configs.hasMoreElements()) {
                    return false;
                }
                pending = parse(service, configs.nextElement());
            }
            nextName = pending.next();
            return true;
        }
    }
```

在 parse 函数中读取文件，返回一个集合的迭代器，配置文件每行对应集合一条数据。

在 parseLine 函数中逐行读取。忽略注释，即 ‘#’ 后面的部分，并且剔除空格，接着是一系列的参数合法检验，然后判断providers和names里是否都没包含这个服务名称，若都没包含names直接add，最后返回下一行的行标；

```java
    private Iterator<String> parse(Class<?> service, URL u)
        throws ServiceConfigurationError
    {
        InputStream in = null;
        BufferedReader r = null;
        ArrayList<String> names = new ArrayList<>();
        try {
            in = u.openStream();
            r = new BufferedReader(new InputStreamReader(in, "utf-8"));
            int lc = 1;
            // 逐行获取，将结果保存在 names 中
            while ((lc = parseLine(service, u, r, lc, names)) >= 0);
        } catch (IOException x) {
            fail(service, "Error reading configuration file", x);
        } finally {
            try {
                if (r != null) r.close();
                if (in != null) in.close();
            } catch (IOException y) {
                fail(service, "Error closing configuration file", y);
            }
        }
        // 返回迭代器
        return names.iterator();
    }
    
    private int parseLine(Class<?> service, URL u, BufferedReader r, int lc,
                          List<String> names)
        throws IOException, ServiceConfigurationError
    {
        // 读取一行
        String ln = r.readLine();
        if (ln == null) {
            return -1;
        }
        // 忽略注释
        int ci = ln.indexOf('#');
        if (ci >= 0) ln = ln.substring(0, ci);
        ln = ln.trim();
        int n = ln.length();
        // 检验格式
        if (n != 0) {
            if ((ln.indexOf(' ') >= 0) || (ln.indexOf('\t') >= 0))
                fail(service, u, lc, "Illegal configuration-file syntax");
            int cp = ln.codePointAt(0);
            if (!Character.isJavaIdentifierStart(cp))
                fail(service, u, lc, "Illegal provider-class name: " + ln);
            for (int i = Character.charCount(cp); i < n; i += Character.charCount(cp)) {
                cp = ln.codePointAt(i);
                if (!Character.isJavaIdentifierPart(cp) && (cp != '.'))
                    fail(service, u, lc, "Illegal provider-class name: " + ln);
            }
            if (!providers.containsKey(ln) && !names.contains(ln))
                names.add(ln);
        }
        return lc + 1;
    }
```

## 2.2 Dubbo SPI

Dubbo SPI 机制的核心类是 ExtensionLoader 类，几乎所有的逻辑和方法都封装在 ExtensionLoader 中。

> Dubbo SPI 中的配置文件是 key-value 的形式，例如“spi=com.alibaba.dubbo.common.extension.factory.SpiExtensionFactory”，下文提到的扩展名均为 key-value 中的 key。

### 2.2.1 ExtensionLoader

#### 2.2.1.1 类属性和静态常量

以 DIRECTORY 结尾的三个静态常量对应于 JDK 的 SPI 机制中配置文件的目录，其中 "META-INF/services/" 是 dubbo 为了兼容 JDK 的 SPI 扩展机制思想而设的，"META-INF/dubbo/" 存放用户自定义的配置文件，"META-INF/dubbo/internal/" 存放 DUBBO 内部的配置文件。

```java
    private static final String SERVICES_DIRECTORY = "META-INF/services/";
    private static final String DUBBO_DIRECTORY = "META-INF/dubbo/";
    private static final String DUBBO_INTERNAL_DIRECTORY = DUBBO_DIRECTORY + "internal/";
```

使用两个 Map 分别表示 ExtensionLoader 加载器集合和实例对象集合。

```java
    // ExtensionLoader 集合， key 表示接口，value 表示对应的 ExtensionLoader
    private static final ConcurrentMap<Class<?>, ExtensionLoader<?>> EXTENSION_LOADERS = new ConcurrentHashMap<Class<?>, ExtensionLoader<?>>();
    // 对象实例集合，key 表示实现类，value 表示对应的对象
    private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = new ConcurrentHashMap<Class<?>, Object>();
```

以 cached 开头的一系列（非静态）常量起到缓存的作用，在后续的很多操作中，都是首先检查缓存是否命中，这样做可以避免一个对象被重复创建多次。

由于是非静态常量，属于 ExtensionLoader 对象私有。

```java
    // ExtensionLoader 集合， key 表示接口，value 表示对应的 ExtensionLoader
    private static final ConcurrentMap<Class<?>, ExtensionLoader<?>> EXTENSION_LOADERS = new ConcurrentHashMap<>(64);
    // 对象实例集合，key 表示实现类，value 表示对应的对象
    private static final ConcurrentMap<Class<?>, Object> EXTENSION_INSTANCES = new ConcurrentHashMap<>(64);
    // 此 ExtensionLoader 对应的类（接口）
    private final Class<?> type;
    private final ExtensionFactory objectFactory;
    // 扩展类与扩展名映射
    private final ConcurrentMap<Class<?>, String> cachedNames = new ConcurrentHashMap<>();
    // 扩展名与扩展类的映射，和 cachedNames 正好相反
    // Holder 类位于 common 模块中，仅有一个 value 属性，此处相当于在 Map 外面加了一层而已。此处的 Holder 的 value 即为 Map。
    private final Holder<Map<String, Class<?>>> cachedClasses = new Holder<>();
    // 扩展名与加有 @Activate 的自动激活类的映射
    private final Map<String, Object> cachedActivates = new ConcurrentHashMap<>();
    // 扩展名与扩展类实例的映射，例如 “dubbo” 与 DubboProcotol 对象
    private final ConcurrentMap<String, Holder<Object>> cachedInstances = new ConcurrentHashMap<>();
    // 缓存的自适应 (Adaptive) 扩展类实例，例如 AdaptiveExtensionFactory 类的对象
    private final Holder<Object> cachedAdaptiveInstance = new Holder<>();
    // 缓存的自适应扩展对象的类，例如 AdaptiveExtensionFactory 类
    private volatile Class<?> cachedAdaptiveClass = null;
    // 缓存的默认扩展名，就是 @SPI 中设置的值
    private String cachedDefaultName;
    private volatile Throwable createAdaptiveInstanceError;
    // 扩展 Wrapper 实现类集合
    private Set<Class<?>> cachedWrapperClasses;
    // 扩展名与加载对应拓展类发生的异常的映射
    private Map<String, IllegalStateException> exceptions = new ConcurrentHashMap<>();
```

从上面的两个静态 Map 和私有属性可以看出，每一个接口对应一个 ExtensionLoader 实例，每一个接口可以对应多个具体的实现（扩展名/扩展点，扩展名和扩展点是一一对应的关系）。

> 自动包装扩展点的 Wrapper 类。ExtensionLoader 在加载扩展点时，如果加载到的扩展点有拷贝构造函数，则判定为扩展点 Wrapper 类。
Wrapper 类同样实现了扩展点接口，但是 Wrapper 不是扩展点的真正实现。它的用途主要是用于从 ExtensionLoader 返回扩展点时，包装在真正的扩展点实现外。即从 ExtensionLoader 中返回的实际上是 Wrapper 类的实例，Wrapper 持有了实际的扩展点实现类。
扩展点的 Wrapper 类可以有多个，也可以根据需要新增。
通过 Wrapper 类可以把所有扩展点公共逻辑移至 Wrapper 中。新加的 Wrapper 在所有的扩展点上添加了逻辑，有些类似 AOP，即 Wrapper 代理了扩展点。
> 可以简单地理解为，Wrapper 类在原来扩展点的基础上包装了一层，加了点功能。这是典型的装饰器模式。

#### 2.2.1.2 成员函数

**getExtensionLoader**

在使用 ExtensionLoader 对象之前，首先要通过 getExtensionLoader 获取 ExtensionLoader 实例。

从下面的源码中可以看到 getExtensionLoader 方法的逻辑比较简单，首先检查传入的参数是否是扩展点接口，如果都符合要求，就从缓存中查找，找到返回，没找到创建一个，存入缓存后返回。

```java
    // 静态方法，获取接口对应的 ExtensionLoader
    @SuppressWarnings("unchecked")
    public static <T> ExtensionLoader<T> getExtensionLoader(Class<T> type) {
        // 扩展点接口为 null
        if (type == null) {
            throw new IllegalArgumentException("Extension type == null");
        }
        // 扩展点接口不是个接口
        if (!type.isInterface()) {
            throw new IllegalArgumentException("Extension type (" + type + ") is not an interface!");
        }
        // 检查是否为扩展点接口（有没有 @SPI 注释）
        if (!withExtensionAnnotation(type)) {
            throw new IllegalArgumentException("Extension type (" + type +
                    ") is not an extension, because it is NOT annotated with @" + SPI.class.getSimpleName() + "!");
        }
        // 看缓存中有没有
        ExtensionLoader<T> loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);
        if (loader == null) {
            // 缓存中没有，创建该接口的加载器，然后添加到缓存中
            EXTENSION_LOADERS.putIfAbsent(type, new ExtensionLoader<T>(type));
            loader = (ExtensionLoader<T>) EXTENSION_LOADERS.get(type);
        }
        return loader;
    }
```

ExtensionLoader 只是获取接口实现的工具，有了 ExtensionLoader 之后，就可以尝试获取扩展点对应的实现了。

**getExtension**

getExtension 函数用于获取扩展点的实现，逻辑和 getExtensionLoader 类似，如果在缓存中找到了，就返回缓存中的对象，如果不在，创造一个放入缓存中再返回。

```java
    /**
     * 根据给定参数（扩展名）找到指定的扩展点实现，如果没找到，抛出 IllegalStateException 异常
     */
    @SuppressWarnings("unchecked")
    public T getExtension(String name) {
        if (StringUtils.isEmpty(name)) {
            // 传入参数不符合规定，抛出异常
            throw new IllegalArgumentException("Extension name == null");
        }
        if ("true".equals(name)) {
            // 获取默认的扩展实现类
            return getDefaultExtension();
        }
        // 从缓存中查找，获取 Holder 容器
        final Holder<Object> holder = getOrCreateHolder(name);
        Object instance = holder.get();
        // 如果 Holder 容器中没有实例，往里面填充一个实例
        if (instance == null) {
            synchronized (holder) {
                instance = holder.get();
                // 双重检查
                if (instance == null) {
                    // 创造扩展点，并存入 Holder
                    instance = createExtension(name);
                    holder.set(instance);
                }
            }
        }
        return (T) instance;
    }
    
    // 从缓存中获取，如果不存在，创造一个 Holder 容器
    private Holder<Object> getOrCreateHolder(String name) {
        Holder<Object> holder = cachedInstances.get(name);
        if (holder == null) {
            cachedInstances.putIfAbsent(name, new Holder<>());
            holder = cachedInstances.get(name);
        }
        return holder;
    }
```

**createExtension**

createExtension 方法用于创建一个扩展名为 name 的扩展点，主要包含以下四个步骤：

1. 通过 getExtensionClasses 获取所有扩展类，然后从这里面获取扩展名为 name 的扩展类
2. 尝试从缓存中获取或者直接创建一个扩展类的实例
3. 向扩展对象注入依赖
4. 循环创建扩展类的 Wrapper 嵌套实例

其中第三步和第四步分别是 Dubbo 中 IOC 和 AOP 的具体实现。

```java
    // 创造扩展点
    @SuppressWarnings("unchecked")
    private T createExtension(String name) {
        // 调用 getExtensionClasses 方法加载所有的扩展类（并放入对应的缓存）
        // 获取 name 对应的类
        Class<?> clazz = getExtensionClasses().get(name);
        // 不存在，抛出异常
        if (clazz == null) {
            throw findException(name);
        }
        try {
            // 尝试从缓存中获取类的实例
            T instance = (T) EXTENSION_INSTANCES.get(clazz);
            if (instance == null) {
                // 缓存中没有，创造一个并放入缓存
                EXTENSION_INSTANCES.putIfAbsent(clazz, clazz.newInstance());
                instance = (T) EXTENSION_INSTANCES.get(clazz);
            }
            // Dubbo 的 IOC 实现
            // 注入依赖（通过 setter）
            injectExtension(instance);
            Set<Class<?>> wrapperClasses = cachedWrapperClasses;
            if (CollectionUtils.isNotEmpty(wrapperClasses)) {
                // 如果有 Wrapper 类，循环创建 Wrapper 实例（最后某个类所有的 Wrapper 嵌套在一起）
                for (Class<?> wrapperClass : wrapperClasses) {
                    // Dubbo 的 AOP 实现
                    // 将当前 instance 作为参数传给 Wrapper 的构造方法，并通过反射创建 Wrapper 实例，
                    // 然后向 Wrapper 实例中注入依赖，最后将 Wrapper 实例再次赋值给 instance 变量
                    instance = injectExtension((T) wrapperClass.getConstructor(type).newInstance(instance));
                }
            }
            initExtension(instance);
            return instance;
        } catch (Throwable t) {
            throw new IllegalStateException("Extension instance (name: " + name + ", class: " +
                    type + ") couldn't be instantiated: " + t.getMessage(), t);
        }
    }
```

createExtension 中调用了很多私有方法，后面将对这些方法一一说明。

**getExtensionClasses**

此方法用于获取所有的扩展类，即从配置文件中获取所有的扩展名-扩展类映射。

```java
    // 获取接口所有的扩展点
    private Map<String, Class<?>> getExtensionClasses() {
        // 获取缓存中扩展名-扩展类的映射
        Map<String, Class<?>> classes = cachedClasses.get();
        // 缓存中 Map 不存在，说明是第一次，还没有初始化
        if (classes == null) {
            synchronized (cachedClasses) {
                classes = cachedClasses.get();
                // 双重检查
                if (classes == null) {
                    // 获得所有的扩展类，并存入到 cachedClassed 中
                    classes = loadExtensionClasses();
                    cachedClasses.set(classes);
                }
            }
        }
        return classes;
    }
```

如果缓存中没有 Map，说明还没有初始化，加锁并执行双重检查后开始初始化。初始化的逻辑在 loadExtensionClasses 方法中实现。

**loadExtensionClasses**

首先解析出 @SPI 注释中的内容，赋值给 cachedDefaultName，然后调用 loadDirectory 加载三个指定文件夹中的配置文件，将扩展类放入 extensionClasses 中。

```java
    /**
     * 获取接口所有的扩展点
     * */
    private Map<String, Class<?>> loadExtensionClasses() {
        // 从 @SPI 中获取默认的扩展点，并缓存
        cacheDefaultExtensionName();
        Map<String, Class<?>> extensionClasses = new HashMap<>();
        // 加载指定文件夹的配置文件中的扩展点
        for (LoadingStrategy strategy : strategies) {
            loadDirectory(extensionClasses, strategy.directory(), type.getName(), strategy.preferExtensionClassLoader(), strategy.excludedPackages());
            loadDirectory(extensionClasses, strategy.directory(), type.getName().replace("org.apache", "com.alibaba"), strategy.preferExtensionClassLoader(), strategy.excludedPackages());
        }
        return extensionClasses;
    }
    
    /**
     * 从 @SPI 注释中提取并缓存默认扩展名，如果其存在的话
     */
    private void cacheDefaultExtensionName() {
        // 获取 @SPI 注释
        final SPI defaultAnnotation = type.getAnnotation(SPI.class);
        if (defaultAnnotation == null) {
            return;
        }
        // @SPI 的默认值
        String value = defaultAnnotation.value();
        // trim 去掉首尾的空格
        if ((value = value.trim()).length() > 0) {
            String[] names = NAME_SEPARATOR.split(value);
            // 只允许一个默认值
            if (names.length > 1) {
                throw new IllegalStateException("More than 1 default extension name on extension " + type.getName()
                        + ": " + Arrays.toString(names));
            }
            if (names.length == 1) {
                cachedDefaultName = names[0];
            }
        }
    }
```

**loadDirectory**

从参数 dir 代表的路径中，加载配置文件所有的扩展类，存入 extensionClasses 映射中。

调用 loadResource 加载，读取配置文件。

```java
    // 从配置文件 dir 中，加载扩展接口所有的实现类
    private void loadDirectory(Map<String, Class<?>> extensionClasses, String dir, String type,
                               boolean extensionLoaderClassLoaderFirst, String... excludedPackages) {
        String fileName = dir + type;
        try {
            Enumeration<java.net.URL> urls = null;
            // 类加载器
            ClassLoader classLoader = findClassLoader();
            if (extensionLoaderClassLoaderFirst) {
                ClassLoader extensionLoaderClassLoader = ExtensionLoader.class.getClassLoader();
                if (ClassLoader.getSystemClassLoader() != extensionLoaderClassLoader) {
                    urls = extensionLoaderClassLoader.getResources(fileName);
                }
            }
            // 获取 urls，这里和 jdk 中 ServiceLoader 一样
            // 根据文件名加载所有同名文件
            if(urls == null || !urls.hasMoreElements()) {
                if (classLoader != null) {
                    urls = classLoader.getResources(fileName);
                } else {
                    urls = ClassLoader.getSystemResources(fileName);
                }
            }

            if (urls != null) {
                while (urls.hasMoreElements()) {
                    java.net.URL resourceURL = urls.nextElement();
                    // 调用 loadResource
                    loadResource(extensionClasses, classLoader, resourceURL, excludedPackages);
                }
            }
        } catch (Throwable t) {
            logger.error("Exception occurred when loading extension class (interface: " +
                    type + ", description file: " + fileName + ").", t);
        }
    }
```

**loadResource**

读取配置文件之后，逐行加载。解析每一行的 key 和 value，使用反射构建对象实例，然后在 loadClass 方法中完成各种缓存的配置。

```java
    // 读取配置文件的内容，逐行加载扩展点
    private void loadResource(Map<String, Class<?>> extensionClasses, ClassLoader classLoader,
                              java.net.URL resourceURL, String... excludedPackages) {
        try {
            try (BufferedReader reader = new BufferedReader(new InputStreamReader(resourceURL.openStream(), StandardCharsets.UTF_8))) {
                String line;
                // 按行读取
                while ((line = reader.readLine()) != null) {
                    final int ci = line.indexOf('#');
                    // 去掉注释，只需要 '#' 之前的部分
                    if (ci >= 0) {
                        line = line.substring(0, ci);
                    }
                    // 去掉前后空格
                    line = line.trim();
                    if (line.length() > 0) {
                        try {
                            String name = null;
                            // 定位 ‘=’
                            int i = line.indexOf('=');
                            if (i > 0) {
                                // ‘=’ 之前的为扩展名，之后的为具体的扩展接口实现类
                                name = line.substring(0, i).trim();
                                line = line.substring(i + 1).trim();
                            }
                            if (line.length() > 0 && !isExcluded(line, excludedPackages)) {
                                // 调用 Class.forName 通过反射加载类，然后在 loadClass 方法中操作前面提到的一系列缓存
                                loadClass(extensionClasses, resourceURL, Class.forName(line, true, classLoader), name);
                            }
                        } catch (Throwable t) {
                            IllegalStateException e = new IllegalStateException("Failed to load extension class (interface: " + type + ", class line: " + line + ") in " + resourceURL + ", cause: " + t.getMessage(), t);
                            exceptions.put(line, e);
                        }
                    }
                }
            }
        } catch (Throwable t) {
            logger.error("Exception occurred when loading extension class (interface: " +
                    type + ", class file: " + resourceURL + ") in " + resourceURL, t);
        }
    }
```

**loadClass**

处理各种缓存。

主要分成以下三类：

* 有 @Adaptive 注释的自适应扩展点，保存在 cachedAdaptiveClass（不是 Map）中。
* Wrapper 类，保存在 wrappers 中。一个扩展点可以有多个 Wrapper 类。
* 普通扩展点，保存到局部变量 extesionClasses 中。

```java
    // 操作以 cached 开头的各种缓存
    private void loadClass(Map<String, Class<?>> extensionClasses, java.net.URL resourceURL, Class<?> clazz, String name) throws NoSuchMethodException {
        if (!type.isAssignableFrom(clazz)) {
            throw new IllegalStateException("Error occurred when loading extension class (interface: " +
                    type + ", class line: " + clazz.getName() + "), class "
                    + clazz.getName() + " is not subtype of interface.");
        }
        // 是否有 Adaptive 注解
        if (clazz.isAnnotationPresent(Adaptive.class)) {
            cacheAdaptiveClass(clazz);
            // 是否是 Wrapper 类
        } else if (isWrapperClass(clazz)) {
            cacheWrapperClass(clazz);
        } else {
            // clazz 是普通的扩展点
            // 如果没有构造函数抛出异常
            clazz.getConstructor();
            if (StringUtils.isEmpty(name)) {
                // 如果 name 为空，说明配置文件不是 key-value 形式，只有扩展点，没有扩展名
                // 尝试从 clazz 的注释中获取名字
                name = findAnnotationName(clazz);
                if (name.length() == 0) {
                    throw new IllegalStateException("No such extension name for the class " + clazz.getName() + " in the config " + resourceURL);
                }
            }
            // 切分名字
            String[] names = NAME_SEPARATOR.split(name);
            if (ArrayUtils.isNotEmpty(names)) {
                cacheActivateClass(clazz, names[0]);
                for (String n : names) {
                    // 缓存扩展类-扩展名映射
                    cacheName(clazz, n);
                    // 保存到 extensionClasses 里面
                    saveInExtensionClass(extensionClasses, clazz, n);
                }
            }
        }
    }
```

> 本身 Dubbo SPI 的配置文件格式为 key-value，不需要这么多步骤，此处是为了兼容 JDK SPI。如果 JDK SPI 的配置文件中是 xx.yyy.DemoFilter，那么其扩展名为 demo。

**injectExtension**

到这里就完成了 createExtension 的第一步。第二步创建实例比较简单。实例化之后，在 createExtension 的第三步中，调用 injectExtension 方法完成依赖注入。

Dubbo 中通过 setter 方法注入依赖。首先从类中获取以 “set” 开头、只有一个参数且为 public 类型的函数，如果其没有 @DisableInject 注释，检测其依赖的参数，获取依赖的对象，之后调用此方法完成注入。

```java
    // 为 instance 注入依赖
    private T injectExtension(T instance) {
        if (objectFactory == null) {
            return instance;
        }
        try {
            // 获取该类中所有的方法
            for (Method method : instance.getClass().getMethods()) {
                // 如果不是 set 方法，直接下一次循环
                if (!isSetter(method)) {
                    continue;
                }
                /**
                 * 如果有 @DisableInject 注释，直接下一次循环
                 * Check {@link DisableInject} to see if we need auto injection for this property
                 */
                if (method.getAnnotation(DisableInject.class) != null) {
                    continue;
                }
                // 参数类型
                Class<?> pt = method.getParameterTypes()[0];
                // 如果是基本参数类型，直接下一次循环
                if (ReflectUtils.isPrimitives(pt)) {
                    continue;
                }
                try {
                    // 获取属性的名字，比如 setName 的属性名为 name
                    String property = getSetterProperty(method);
                    // 从 ObjectFactory 获取依赖对象
                    Object object = objectFactory.getExtension(pt, property);
                    if (object != null) {
                        // 通过反射调用 setter 方法，注入依赖
                        method.invoke(instance, object);
                    }
                } catch (Exception e) {
                    logger.error("Failed to inject via method " + method.getName()
                            + " of interface " + type.getName() + ": " + e.getMessage(), e);
                }

            }
        } catch (Exception e) {
            logger.error(e.getMessage(), e);
        }
        return instance;
    }
```

### 2.2.2 @SPI

和 Dubbo SPI 直接相关的是 @SPI 注释，表示的是该接口为可扩展接口。@SPI("key") 注解中的 key 则表示默认的实现类，加载实现类的时候将会在配置文件中查找该 key 对应的实现类。

```java
// @Retention 指定注解应该保留多长时间，RUNTIME 包含在类文件中，由虚拟机载入，可以用反射获取
@Retention(RetentionPolicy.RUNTIME)
// @Target 限制注解能用在哪儿，ElementType.TYPE 表示可以用在类、接口、注解上
@Target({ElementType.TYPE})
public @interface SPI {

    /**
     * 默认扩展类名
     */
    String value() default "";

}
```

从源码中可以看到 @SPI 只有一个参数，表示默认的扩展名。

## 2.3 自适应扩展

“自适应扩展”希望达到的目的是，在启动时不需要加载所有的扩展点，在扩展方法被调用时，才根据指定参数进行加载。可以简单地理解为，用户传入参数（通常是 URL），指定加载哪一个就加载哪一个。直到方法调用的时候，才决定调用的是哪一个扩展点的实现。

[Dubbo 官网](http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html) 中以汽车制造为例，描述了自适应扩展类的核心实现：在扩展接口的方法被调用时，通过 SPI 加载具体的扩展实现类，并调用扩展对象的同名方法。

对于每一个自适应方法，基本的实现流程是在扩展方法里加载该类，然后生成对象实例，最后调用扩展方法本身。（请参考后面的 Transport$Adaptive 实例。)

生成自适应扩展方法的过程中需要做的是生成自定义的适配器类，和自定义的实现了扩展接口的 @Adaptive 方法。Dubbo 自动构建了这部分的代码后，通过 javassist 或 jdk 编译这段代码，得到 class 文件，然后通过反射（newInstance）获得实例，并注入依赖。

### 2.3.1 获得自适应扩展点

getAdaptiveExtension 是获取自适应扩展的入口方法，下面从 getAdaptiveExtension 开始：

**getAdaptiveExtension**

首先检查缓存中是否已经有实例了，有的话返回，没有的话调用 createAdaptiveExtension 生成。

```java
    // 获取自适应扩展类
    @SuppressWarnings("unchecked")
    public T getAdaptiveExtension() {
        // 从缓存中获取（一个接口只有一个自适应扩展点）
        Object instance = cachedAdaptiveInstance.get();
        if (instance == null) {
            if (createAdaptiveInstanceError != null) {
                throw new IllegalStateException("Failed to create adaptive instance: " +
                        createAdaptiveInstanceError.toString(),
                        createAdaptiveInstanceError);
            }
            synchronized (cachedAdaptiveInstance) {
                instance = cachedAdaptiveInstance.get();
                // 双重检查
                if (instance == null) {
                    try {
                        // 创建自适应扩展
                        instance = createAdaptiveExtension();
                        // 存入缓存
                        cachedAdaptiveInstance.set(instance);
                    } catch (Throwable t) {
                        createAdaptiveInstanceError = t;
                        throw new IllegalStateException("Failed to create adaptive instance: " + t.toString(), t);
                    }
                }
            }
        }
        return (T) instance;
    }
```

**createAdaptiveExtension**

此方法主要包含三个步骤：

1. 调用 getAdaptiveExtensionClass 方法获取 Class
2. 生成实例
3. 向实例注入依赖

```java
    // 创建自适应扩展类
    @SuppressWarnings("unchecked")
    private T createAdaptiveExtension() {
        try {
            // 调用 getAdaptiveExtensionClass 方法获取 class
            // 生成实例
            // 向实例注入依赖
            return injectExtension((T) getAdaptiveExtensionClass().newInstance());
        } catch (Exception e) {
            throw new IllegalStateException("Can't create adaptive extension " + type + ", cause: " + e.getMessage(), e);
        }
    }
```

**getAdaptiveExtensionClass**

检查缓存中有没有自适应扩展类，如果有直接返回，没有就创造一个。

```java
    // 获取自适应扩展类
    private Class<?> getAdaptiveExtensionClass() {
        // 获取所有 SPI 扩展类
        getExtensionClasses();
        // 缓存命中
        if (cachedAdaptiveClass != null) {
            return cachedAdaptiveClass;
        }
        // 创建自适应的扩展类
        return cachedAdaptiveClass = createAdaptiveExtensionClass();
    }
```

**createAdaptiveExtensionClass**

创造自适应扩展类的第一是生成自适应扩展类的代码，然后获取编译器，最后编译这段代码，生成 class。

```java
    // 创建自适应扩展类
    private Class<?> createAdaptiveExtensionClass() {
        // 构建自适应扩展类的代码
        String code = new AdaptiveClassCodeGenerator(type, cachedDefaultName).generate();
        ClassLoader classLoader = findClassLoader();
        // 获取编译器实现类
        org.apache.dubbo.common.compiler.Compiler compiler = ExtensionLoader.getExtensionLoader(org.apache.dubbo.common.compiler.Compiler.class).getAdaptiveExtension();
        // 编译代码，生成 Class
        return compiler.compile(code, classLoader);
    }
```

在 2.6.x 的版本中构建自适应代码的工作在 createAdaptiveExtensionClassCode 函数中实现，在最新的 master(2020.4) 版本中，把这一项工作抽象到了 AdaptiveClassCodeGenerator 类中。

**createAdaptiveExtensionClassCode**

2.6.x 版本中使用此方法构建自适应代码。

此方法是 ExtensionLoader 中代码行最多的方法，大概思路是根据传递进去的参数（URL），不断解析需要的参数，根据参数的不同生成不同的语句。

整个流程主要分成以下几个部分：
1. 检查 @Adaptive 注解；
2. 生成 "package", "import", "类名" 等语句；
3. 没有 @Adaptive 注释的方法，不需要适配，直接抛出 Unsupported 异常;
*（第 4 - 9 步仅针对 @Adaptive 的方法，且都表示生成相应的代码，而非执行具体操作）*
4. 有 @Adaptive 注释的方法，首先需要从方法的参数中获取 URL，要么直接有 URL 参数，要么参数可以调用 get 方法获取 URL；
5. 解析 @Adaptive 注释里的参数，存进数组；
6. 检查方法是否有 Invocation 类型的参数；
7. 获取 URL 中的扩展名；
8. 根据扩展名加载接口的实现类；
9. 调用方法；
10. 生成"函数名"的代码，将所有代码转化成字符串，最后返回。

此方法的详细注释如下所示：

```java
    // 生成自适应扩展类的代码
    private String createAdaptiveExtensionClassCode() {
        StringBuilder codeBuilder = new StringBuilder();
        // 获取接口中所有的方法
        Method[] methods = type.getMethods();
        boolean hasAdaptiveAnnotation = false;
        // 检查方法上是否有 @Adaptive 注解
        // 如果所有方法都没有 @Adaptive 注解，抛出异常
        for (Method m : methods) {
            if (m.isAnnotationPresent(Adaptive.class)) {
                hasAdaptiveAnnotation = true;
                break;
            }
        }
        // no need to generate adaptive class since there's no adaptive method found.
        if (!hasAdaptiveAnnotation)
            throw new IllegalStateException("No adaptive method on extension " + type.getName() + ", refuse to create the adaptive class!");

        // 生成 package 语句，即类文件最头部的 “ package + type 所在包”
        codeBuilder.append("package ").append(type.getPackage().getName()).append(";");
        // 生成 import 语句，此处需要导入 ExtensionLoader 类
        codeBuilder.append("\nimport ").append(ExtensionLoader.class.getName()).append(";");
        // 生成类的第一行 “public class ...”，类的名称为“接口名 + $Adaptive”
        codeBuilder.append("\npublic class ").append(type.getSimpleName()).append("$Adaptive").append(" implements ").append(type.getCanonicalName()).append(" {");

        // 接口中的方法分为两类，一类是被 @Adaptive 注解修饰的，另一类是不被 @Adaptive 修饰的
        // 不被 @Adaptive 注解修饰的直接抛出 Unsupported 异常
        // 被 @Adaptive 注解修饰的才进行适配的逻辑
        for (Method method : methods) {
            Class<?> rt = method.getReturnType();
            // 获取参数
            Class<?>[] pts = method.getParameterTypes();
            Class<?>[] ets = method.getExceptionTypes();

            Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);
            StringBuilder code = new StringBuilder(512);
            if (adaptiveAnnotation == null) {
                // 没有 @Adaptive 注解，直接抛出异常
                code.append("throw new UnsupportedOperationException(\"method ")
                        .append(method.toString()).append(" of interface ")
                        .append(type.getName()).append(" is not adaptive method!\");");
            } else {
                // 有 @Adaptive 注解，首先从参数中直接或间接找到 URL，找不到的话直接抛出异常
                int urlTypeIndex = -1;
                // 找到 URL 参数的位置（索引）
                for (int i = 0; i < pts.length; ++i) {
                    if (pts[i].equals(URL.class)) {
                        urlTypeIndex = i;
                        break;
                    }
                }
                // 索引不为 -1，说明存在 URL
                if (urlTypeIndex != -1) {
                    // 生成代码，检查 URL 是否为 null
                    String s = String.format("\nif (arg%d == null) throw new IllegalArgumentException(\"url == null\");",
                            urlTypeIndex);
                    code.append(s);

                    // 生成代码，将 URL 保存到 “url” 变量中
                    s = String.format("\n%s url = arg%d;", URL.class.getName(), urlTypeIndex);
                    code.append(s);
                }
                // 不存在 URL 类型的参数，需要从 Invoker 参数中获取 URL
                else {
                    String attribMethod = null;

                    // 寻找可以获得 URL 的 getter 方法
                    LBL_PTS:
                    // 遍历参数列表
                    for (int i = 0; i < pts.length; ++i) {
                        // 获取索引为 i 的参数（类）的所有方法
                        Method[] ms = pts[i].getMethods();
                        // 遍历方法列表
                        for (Method m : ms) {
                            String name = m.getName();
                            // 满足以下所有条件才表示找到了：
                            // 1. 方法以 get 开头，或方法名大于 3 个字符
                            // 2. 方法的访问权限为 public
                            // 3. 方法非静态
                            // 4. 方法参数数量为 0
                            // 5. 方法返回值类型为 URL
                            if ((name.startsWith("get") || name.length() > 3)
                                    && Modifier.isPublic(m.getModifiers())
                                    && !Modifier.isStatic(m.getModifiers())
                                    && m.getParameterTypes().length == 0
                                    && m.getReturnType() == URL.class) {
                                // 索引为 i 的参数中可以获取到 URL
                                urlTypeIndex = i;
                                // 目标方法的名字
                                attribMethod = name;
                                break LBL_PTS;
                            }
                        }
                    }
                    // 没找到，抛出异常
                    if (attribMethod == null) {
                        throw new IllegalStateException("fail to create adaptive class for interface " + type.getName()
                                + ": not found url parameter or url attribute in parameters of method " + method.getName());
                    }

                    // 生成代码，检查可返回 URL 的参数是否为 null
                    String s = String.format("\nif (arg%d == null) throw new IllegalArgumentException(\"%s argument == null\");",
                            urlTypeIndex, pts[urlTypeIndex].getName());
                    code.append(s);
                    // 生成代码，调用可返回 URL 的参数的 get 方法返回 URL，判断返回的 URL 是否为 null
                    s = String.format("\nif (arg%d.%s() == null) throw new IllegalArgumentException(\"%s argument %s() == null\");",
                            urlTypeIndex, attribMethod, pts[urlTypeIndex].getName(), attribMethod);
                    code.append(s);
                    // 获取返回的 URL，赋值给 "url"
                    s = String.format("%s url = arg%d.%s();", URL.class.getName(), urlTypeIndex, attribMethod);
                    code.append(s);
                }

                // 获取 @Adaptive 标签的参数
                String[] value = adaptiveAnnotation.value();
                // value is not set, use the value generated from class name as the key
                // 如果该注解没有参数，创造一个默认参数
                // 获取类名，然后处理类名。LoadBalance 经过处理后得到 load.balance
                if (value.length == 0) {
                    char[] charArray = type.getSimpleName().toCharArray();
                    StringBuilder sb = new StringBuilder(128);
                    for (int i = 0; i < charArray.length; i++) {
                        // 大写字母先加个 '.'，再把大写变成小写加在后面
                        if (Character.isUpperCase(charArray[i])) {
                            if (i != 0) {
                                sb.append(".");
                            }
                            sb.append(Character.toLowerCase(charArray[i]));
                        } else {
                            // 小写字母直接加在后面
                            sb.append(charArray[i]);
                        }
                    }
                    value = new String[]{sb.toString()};
                }

                // 检查方法的列表中是否存在 Invocation 类型的参数
                boolean hasInvocation = false;
                for (int i = 0; i < pts.length; ++i) {
                    if (pts[i].getName().equals("com.alibaba.dubbo.rpc.Invocation")) {
                        // 生成代码，如果存在 Invocation 类型的参数，检查是否为 null
                        String s = String.format("\nif (arg%d == null) throw new IllegalArgumentException(\"invocation == null\");", i);
                        code.append(s);
                        // 生成代码，调用该对象的 getMethodName 方法
                        s = String.format("\nString methodName = arg%d.getMethodName();", i);
                        code.append(s);
                        hasInvocation = true;
                        break;
                    }
                }

                // @SPI 设置的值，如果没有设置的话，cacheDefaultName 为 null
                String defaultExtName = cachedDefaultName;
                String getNameCode = null;
                // 从后往前遍历 value 数组。value 数组是 @Adaptive 设置的参数
                // 此循环是为了获得 URL 中的扩展名
                // 从后往前是因为 @Adaptive 注解的参数顺序是从前往后
                for (int i = value.length - 1; i >= 0; --i) {
                    // 数组最后一个值
                    if (i == value.length - 1) {
                        // @SPI 已经设置了默认的参数
                        if (null != defaultExtName) {
                            // 数组最后一个值不是 protocol，
                            if (!"protocol".equals(value[i]))
                                if (hasInvocation)
                                    // 生成代码：调用 url 的 getMethodParameter(String method, String key, String defaultValue) 方法，method 参数传入 "methodName"
                                    getNameCode = String.format("url.getMethodParameter(methodName, \"%s\", \"%s\")", value[i], defaultExtName);
                                else
                                    // 生成代码：调用 url 的 getParameter(String key, String defaultValue) 方法，如果通过 key 取到了值就返回该值，没取到则返回默认值
                                    getNameCode = String.format("url.getParameter(\"%s\", \"%s\")", value[i], defaultExtName);
                            else
                                // 生成代码：如果方法 getProtocol 有返回值就返回该值，没有则返回 @SPI 设置的默认值
                                getNameCode = String.format("( url.getProtocol() == null ? \"%s\" : url.getProtocol() )", defaultExtName);
                        } else {
                            // @SPI 没有设置默认参数
                            if (!"protocol".equals(value[i]))
                                if (hasInvocation)
                                    getNameCode = String.format("url.getMethodParameter(methodName, \"%s\", \"%s\")", value[i], defaultExtName);
                                else
                                    getNameCode = String.format("url.getParameter(\"%s\")", value[i]);
                            else
                                // 生成代码：url.getProtocol()，意思是从 url 中获取协议
                                getNameCode = "url.getProtocol()";
                        }
                    } else {
                        // 数组最后一个值不是 protocol
                        if (!"protocol".equals(value[i]))
                            if (hasInvocation)
                                getNameCode = String.format("url.getMethodParameter(methodName, \"%s\", \"%s\")", value[i], defaultExtName);
                            else
                                getNameCode = String.format("url.getParameter(\"%s\", %s)", value[i], getNameCode);
                        else
                            getNameCode = String.format("url.getProtocol() == null ? (%s) : url.getProtocol()", getNameCode);
                    }
                }
                // 生成代码：得到的 getNameCode 赋值给 extName
                code.append("\nString extName = ").append(getNameCode).append(";");
                // 生成代码：检查得到的 extName 是否为 null
                String s = String.format("\nif(extName == null) " +
                                "throw new IllegalStateException(\"Fail to get extension(%s) name from url(\" + url.toString() + \") use keys(%s)\");",
                        type.getName(), Arrays.toString(value));
                code.append(s);

                // 根据获取到的扩展名（extName）加载扩展实例
                s = String.format("\n%s extension = (%<s)%s.getExtensionLoader(%s.class).getExtension(extName);",
                        type.getName(), ExtensionLoader.class.getSimpleName(), type.getName());
                code.append(s);

                // return 语句
                if (!rt.equals(void.class)) {
                    code.append("\nreturn ");
                }

                // 调用目标方法
                s = String.format("extension.%s(", method.getName());
                code.append(s);
                for (int i = 0; i < pts.length; i++) {
                    if (i != 0)
                        code.append(", ");
                    code.append("arg").append(i);
                }
                code.append(");");
            }

            // 生成方法的名字
            codeBuilder.append("\npublic ").append(rt.getCanonicalName()).append(" ").append(method.getName()).append("(");
            // 添加方法参数
            for (int i = 0; i < pts.length; i++) {
                if (i > 0) {
                    codeBuilder.append(", ");
                }
                codeBuilder.append(pts[i].getCanonicalName());
                codeBuilder.append(" ");
                codeBuilder.append("arg").append(i);
            }
            codeBuilder.append(")");
            // 抛出异常
            if (ets.length > 0) {
                codeBuilder.append(" throws ");
                for (int i = 0; i < ets.length; i++) {
                    if (i > 0) {
                        codeBuilder.append(", ");
                    }
                    codeBuilder.append(ets[i].getCanonicalName());
                }
            }
            // 再将上面生成的方法体加在里面
            codeBuilder.append(" {");
            codeBuilder.append(code.toString());
            codeBuilder.append("\n}");
        }
        codeBuilder.append("\n}");
        if (logger.isDebugEnabled()) {
            logger.debug(codeBuilder.toString());
        }
        return codeBuilder.toString();
    }
```

**AdaptiveClassCodeGenerator**

master(2020.4) 版本中把上面的实现流程拆分之后，放到了此类中，更符合面向对象的原则。

此类中有一系列的模板属性用于快速构建适配代码，在后面的函数中都会用到，如下所示：

```java
    // 各种模板
    // Invocation 全限定类名
    private static final String CLASSNAME_INVOCATION = "org.apache.dubbo.rpc.Invocation";
    // package
    private static final String CODE_PACKAGE = "package %s;\n";
    // import
    private static final String CODE_IMPORTS = "import %s;\n";
    // 类签名
    private static final String CODE_CLASS_DECLARATION = "public class %s$Adaptive implements %s {\n";
    // 方法名
    private static final String CODE_METHOD_DECLARATION = "public %s %s(%s) %s {\n%s}\n";
    // 方法参数
    private static final String CODE_METHOD_ARGUMENT = "%s arg%d";
    // 抛出异常
    private static final String CODE_METHOD_THROWS = "throws %s";
    // 抛出 Unsupported 异常
    private static final String CODE_UNSUPPORTED = "throw new UnsupportedOperationException(\"The method %s of interface %s is not adaptive method!\");\n";
    // 检查参数是否为 null
    private static final String CODE_URL_NULL_CHECK = "if (arg%d == null) throw new IllegalArgumentException(\"url == null\");\n%s url = arg%d;\n";
    // 扩展名赋值
    private static final String CODE_EXT_NAME_ASSIGNMENT = "String extName = %s;\n";
    // 检查扩展名是否为 null
    private static final String CODE_EXT_NAME_NULL_CHECK = "if(extName == null) "
                    + "throw new IllegalStateException(\"Failed to get extension (%s) name from url (\" + url.toString() + \") use keys(%s)\");\n";
    // 检查参数是否为 null
    private static final String CODE_INVOCATION_ARGUMENT_NULL_CHECK = "if (arg%d == null) throw new IllegalArgumentException(\"invocation == null\"); "
                    + "String methodName = arg%d.getMethodName();\n";
    // 获取扩展类并赋值给 extension
    private static final String CODE_EXTENSION_ASSIGNMENT = "%s extension = (%<s)%s.getExtensionLoader(%s.class).getExtension(extName);\n";
    // 某个参数
    private static final String CODE_EXTENSION_METHOD_INVOKE_ARGUMENT = "arg%d";
```

generate 是 AdaptiveClassCodeGenerator 类中唯一的 public 方法，生成适配代码只能调用 generate。

generate 方法的流程从上往下依次是：生成 "package" 语句、生成 "import" 语句、生成类签名、处理每一个 @Adaptive 方法。

```java
    /**
     * 生成代码（String 类型）
     */
    public String generate() {
        // 如果类中没有任何方法是 @Adaptive 注释，不需要生成自适应扩展类，直接抛出异常
        if (!hasAdaptiveMethod()) {
            throw new IllegalStateException("No adaptive method exist on extension " + type.getName() + ", refuse to create the adaptive class!");
        }

        StringBuilder code = new StringBuilder();
        // 生成 "package" 语句
        code.append(generatePackageInfo());
        // 生成 "import" 语句
        code.append(generateImports());
        // 生成类签名
        code.append(generateClassDeclaration());
        // 处理每一个 @Adaptive 方法
        Method[] methods = type.getMethods();
        for (Method method : methods) {
            code.append(generateMethod(method));
        }
        code.append("}");

        if (logger.isDebugEnabled()) {
            logger.debug(code.toString());
        }
        return code.toString();
    }
```

前面三个步骤比较简单，都只有一句话，在前面提到的模板语句中填充就可以了：

```java
    // 生成 "package" 语句
    private String generatePackageInfo() {
        return String.format(CODE_PACKAGE, type.getPackage().getName());
    }

    // 生成 "import" 语句
    private String generateImports() {
        return String.format(CODE_IMPORTS, ExtensionLoader.class.getName());
    }

    // 生成类签名
    private String generateClassDeclaration() {
        return String.format(CODE_CLASS_DECLARATION, type.getSimpleName(), type.getCanonicalName());
    }
```

比较复杂的是生成每一个方法的适配代码，每一个方法有包含以下几个部分：

```java
    /**
     * 方法的定义
     */
    private String generateMethod(Method method) {
        // 返回值类型
        String methodReturnType = method.getReturnType().getCanonicalName();
        // 方法名
        String methodName = method.getName();
        // 方法体
        String methodContent = generateMethodContent(method);
        // 参数
        String methodArgs = generateMethodArguments(method);
        // 抛出异常
        String methodThrows = generateMethodThrows(method);
        return String.format(CODE_METHOD_DECLARATION, methodReturnType, methodName, methodArgs, methodThrows, methodContent);
    }
```

生成方法体的代码在 generateMethodContent 中：

```java
    /**
     * 创建方法体的代码
     */
    private String generateMethodContent(Method method) {
        // 检查是否有 @Adaptive 注释
        Adaptive adaptiveAnnotation = method.getAnnotation(Adaptive.class);
        StringBuilder code = new StringBuilder(512);
        if (adaptiveAnnotation == null) {
            // 没有 @Adaptive 注释，如果调用了，方法体中直接抛出异常
            return generateUnsupported(method);
        } else {
            // 找到方法所有参数中 URL 参数的索引
            int urlTypeIndex = getUrlTypeIndex(method);

            if (urlTypeIndex != -1) {
                // 如果找到了，添加检查 URL 参数是否为 null 的代码
                code.append(generateUrlNullCheck(urlTypeIndex));
            } else {
                // 没有找到，看看参数所在的类里面有没有可以获取 URL 的方法，如果没有，就结束，直接抛出异常
                code.append(generateUrlAssignmentIndirectly(method));
            }
            // 获取 @Adaptive 注释的参数
            String[] value = getMethodAdaptiveValue(adaptiveAnnotation);
            // 方法列表中是否有 Invocation 类型的参数
            boolean hasInvocation = hasInvocationArgument(method);
            // 生成检查 Invocation 是否为 null 的代码
            code.append(generateInvocationArgumentNullCheck(method));
            // 生成从 URL 中获取扩展点（全限定类名）的代码
            code.append(generateExtNameAssignment(value, hasInvocation));
            // 生成检查刚刚获取到的扩展点的类名是否为空的代码
            code.append(generateExtNameNullCheck(value));
            // 生成获取扩展类实例并赋值给 extension 的代码
            code.append(generateExtensionAssignment());
            // 生成调用语句和 return 语句
            code.append(generateReturnAndInvocation(method));
        }
        return code.toString();
    }
    
    /**
     * 找到方法的参数中 URL 的索引
     */
    private int getUrlTypeIndex(Method method) {
        int urlTypeIndex = -1;
        // 方法中所有参数的类型
        Class<?>[] pts = method.getParameterTypes();
        for (int i = 0; i < pts.length; ++i) {
            // 找到了 URL 参数
            if (pts[i].equals(URL.class)) {
                urlTypeIndex = i;
                break;
            }
        }
        return urlTypeIndex;
    }
    
    /**
     * 从方法的参数中获取 URL
     * 检查方法的参数中，是否有包含能获取 URL 方法的类，如果没有，抛出 IllegalStateException 异常
     */
    private String generateUrlAssignmentIndirectly(Method method) {
        // 参数列表
        Class<?>[] pts = method.getParameterTypes();
        Map<String, Integer> getterReturnUrl = new HashMap<>();
        // 遍历参数列表，寻找可以获得 URL 的 getter 方法
        for (int i = 0; i < pts.length; ++i) {
            // 遍历 pts[i] 的所有方法
            for (Method m : pts[i].getMethods()) {
                String name = m.getName();
                // 同时满足以下所有条件就表示找到了：
                // 1. 方法以 get 开头，或方法名大于 3 个字符
                // 2. 方法的访问权限为 public
                // 3. 方法非静态
                // 4. 方法参数数量为 0
                // 5. 方法返回值类型为 URL
                if ((name.startsWith("get") || name.length() > 3)
                        && Modifier.isPublic(m.getModifiers())
                        && !Modifier.isStatic(m.getModifiers())
                        && m.getParameterTypes().length == 0
                        && m.getReturnType() == URL.class) {
                    // 把找到的参数保存下来
                    getterReturnUrl.put(name, i);
                }
            }
        }
        // 如果所有参数都不满足条件，抛出异常，说明这不是一个可适配的类
        if (getterReturnUrl.size() <= 0) {
            throw new IllegalStateException("Failed to create adaptive class for interface " + type.getName()
                    + ": not found url parameter or url attribute in parameters of method " + method.getName());
        }
        // 获取 "getUrl" 方法所在的参数索引
        Integer index = getterReturnUrl.get("getUrl");
        if (index != null) {
            // 有 getUrl，直接处理 getUrl
            return generateGetUrlNullCheck(index, pts[index], "getUrl");
        } else {
            // 否则处理保存的参数里面的第一个
            Map.Entry<String, Integer> entry = getterReturnUrl.entrySet().iterator().next();
            return generateGetUrlNullCheck(entry.getValue(), pts[entry.getValue()], entry.getKey());
        }
    }
    
    /**
     * 获取 @Adaptive 注释的参数，如果没有的话根据接口名自动生成
     * 默认扩展点的优先级为 @Adaptive 从左到右，最后才是 @SPI
     */
    private String[] getMethodAdaptiveValue(Adaptive adaptiveAnnotation) {
        String[] value = adaptiveAnnotation.value();
        // 没有设置，根据类名自动生成一个，例如 HasAdaptiveExt 就是 has.adaptive.ext
        if (value.length == 0) {
            String splitName = StringUtils.camelToSplitName(type.getSimpleName(), ".");
            value = new String[]{splitName};
        }
        return value;
    }
    
    /**
     * 生成从 URL 参数中获取扩展点的代码
     */
    private String generateExtNameAssignment(String[] value, boolean hasInvocation) {
        // TODO: refactor it
        String getNameCode = null;
        // 从后往前遍历 value 数组。value 数组是 @Adaptive 设置的参数
        // 此循环是为了获得 URL 中的扩展名
        // 从后往前是因为 @Adaptive 注解的参数顺序是从前往后，后面的将会被依次覆盖
        for (int i = value.length - 1; i >= 0; --i) {
            if (i == value.length - 1) {
                // 如果是数组最后一个值
                if (null != defaultExtName) {
                    // @SPI 注解中已经设置了默认的参数
                    if (!"protocol".equals(value[i])) {
                        // 数组最后一个值不是 protocol
                        if (hasInvocation) {
                            // 生成代码：调用 url 的 getMethodParameter(String method, String key, String defaultValue) 方法，method 参数传入 "methodName"
                            getNameCode = String.format("url.getMethodParameter(methodName, \"%s\", \"%s\")", value[i], defaultExtName);
                        } else {
                            // 生成代码：调用 url 的 getParameter(String key, String defaultValue) 方法，如果通过 key 取到了值就返回该值，没取到则返回默认值
                            getNameCode = String.format("url.getParameter(\"%s\", \"%s\")", value[i], defaultExtName);
                        }
                    } else {
                        // 生成代码：如果方法 getProtocol 有返回值就返回该值，没有则返回 @SPI 设置的默认值
                        getNameCode = String.format("( url.getProtocol() == null ? \"%s\" : url.getProtocol() )", defaultExtName);
                    }
                } else {
                    // @SPI 没有设置默认参数
                    if (!"protocol".equals(value[i])) {
                        if (hasInvocation) {
                            getNameCode = String.format("url.getMethodParameter(methodName, \"%s\", \"%s\")", value[i], defaultExtName);
                        } else {
                            getNameCode = String.format("url.getParameter(\"%s\")", value[i]);
                        }
                    } else {
                        // 生成代码：url.getProtocol()，从 url 中获取协议类型
                        getNameCode = "url.getProtocol()";
                    }
                }
            } else {
                // 如果不是数组中最后一个值
                if (!"protocol".equals(value[i])) {
                    // 当前值不是 protocol
                    if (hasInvocation) {
                        getNameCode = String.format("url.getMethodParameter(methodName, \"%s\", \"%s\")", value[i], defaultExtName);
                    } else {
                        getNameCode = String.format("url.getParameter(\"%s\", %s)", value[i], getNameCode);
                    }
                } else {
                    getNameCode = String.format("url.getProtocol() == null ? (%s) : url.getProtocol()", getNameCode);
                }
            }
        }

        return String.format(CODE_EXT_NAME_ASSIGNMENT, getNameCode);
    }
```

首先判断方法是否有 @Adaptive 注释，如果没有，表示此方法不是适配方法，只需要在 方法体中抛出异常就可以了，否则，为此方法生成适配的代码。其实每一个方法的代码大致框架都差不多：

* 处理 URL 参数。由于是根据 URL 的参数生成适配类，所以必须要获取到 URL。如果方法签名中有 URL 参数，检查它是否为空；如果没有 URL 参数，检查是否能从其他参数所在类的 get 方法中获取，例如某一个参数可能包含 “getUrl” 方法。
* 获取 @Adaptive 注释的参数，存进数组。
* 检查参数列表中是否有 Invocation 参数，从而确定后面的代码。
* 生成从 URL 获取扩展点（全限定类名）的代码。
* 生成获取扩展点实例的代码。
* 生成调用方法的语句和 return 语句。

这是简要的步骤，中间还省略了检查参数是否为 null 的步骤。

按照以上思路生成适配方法的代码。虽然看起来步骤很复杂，实际上没有什么复杂的逻辑，只需要一步一步弄清执行流程就好了。

以 com.alibaba.dubbo.remoting.Transporter 接口为例，最后生成的适配器类的代码如下所示：

```java
package com.alibaba.dubbo.remoting;
import com.alibaba.dubbo.common.extension.ExtensionLoader;
public class Transporter$Adaptive implements com.alibaba.dubbo.remoting.Transporter{
    
    public com.alibaba.dubbo.remoting.Client connect(com.alibaba.dubbo.common.URL arg0, com.alibaba.dubbo.remoting.ChannelHandler arg1) throws com.alibaba.dubbo.remoting.RemotingException {
        if (arg0 == null) 
            throw new IllegalArgumentException("url == null");
        
        com.alibaba.dubbo.common.URL url = arg0;
        String extName = url.getParameter("client", url.getParameter("transporter", "netty"));
        if(extName == null) 
            throw new IllegalStateException("Fail to get extension(com.alibaba.dubbo.remoting.Transporter) name from url(" + url.toString() + ") use keys([client, transporter])");
        com.alibaba.dubbo.remoting.Transporter extension = (com.alibaba.dubbo.remoting.Transporter)ExtensionLoader.getExtensionLoader
        
        (com.alibaba.dubbo.remoting.Transporter.class).getExtension(extName);
        return extension.connect(arg0, arg1);
    }
    public com.alibaba.dubbo.remoting.Server bind(com.alibaba.dubbo.common.URL arg0, com.alibaba.dubbo.remoting.ChannelHandler arg1) throws com.alibaba.dubbo.remoting.RemotingException {
        if (arg0 == null) 
            throw new IllegalArgumentException("url == null");
        com.alibaba.dubbo.common.URL url = arg0;
        String extName = url.getParameter("server", url.getParameter("transporter", "netty"));
        if(extName == null) 
            throw new IllegalStateException("Fail to get extension(com.alibaba.dubbo.remoting.Transporter) name from url(" + url.toString() + ") use keys([server, transporter])");
        com.alibaba.dubbo.remoting.Transporter extension = (com.alibaba.dubbo.remoting.Transporter)ExtensionLoader.getExtensionLoader
        (com.alibaba.dubbo.remoting.Transporter.class).getExtension(extName);
        
        return extension.bind(arg0, arg1);
    }
}
```

### 2.3.2 测试

对以上的论断进行简单的测试：

创建 Ext6 接口和对应的两个实现 impl1, impl2，并添加配置文件：

```java
@SPI
public interface Ext6 {
    @Adaptive("key1")
    String echo(URL url, String s);
}
```

“impl2” 中 echo 接口的实现是抛出异常。

编写单元测试方法：

```java
    @Test
    public void test_getAdaptiveExtension_NoSPINoAdaptive() throws Exception {
        Ext6 ext = ExtensionLoader.getExtensionLoader(Ext6.class).getAdaptiveExtension();
        HashMap<String, String> params = new HashMap<String, String>();
        params.put("key1", "impl1");
        params.put("key2", "impl2");
        URL url = new URL("dubbo", "127.0.0.1", 70, params);
        ext.echo(url, "haha");
    }
```

运行该程序确实抛出了 UnsupportedOperationException 异常。如果去掉 @Adaptive 注释的参数，将会抛出 IllegalStateException 异常。而如果在 @SPI 参数中再次设置默认扩展实现，则不会抛出异常。

测试结果和 2.3.1 中源码的分析完全一致。

### 2.3.3 @Adaptive

在最后对 @Adaptive 注解做一个简单的介绍。

```java
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Adaptive {
    /**
     * 决定注入哪一个目标扩展点。目标扩展点取决于 URL 中的参数，参数名由此方法提供
     *
     * 如果指定的参数在 URL 中没有找到，将会使用默认的扩展类（在 @SPI 中指定）
     *
     * 例如，给定字符串数组 {"key1", "key2"}
     *
     * 首先在 URL 中寻找参数 key1，在生成的代码中使用它的值作为扩展名
     * 如果没有找到 key1，继续尝试寻找 key2 参数
     * 如果 key2 也没找到，那么使用 @SPI 中指定的扩展名
     * 如果没有 @SPI，在生成的代码中会因为获取不到扩展名对应的类名而抛出 IllegalStateException 异常
     *
     * @return parameter key names in URL
     */
    String[] value() default {};
}
```

可以看到 @Adaptive 的参数是一个 String 类型的数组，从最左边往右边匹配。

在上面的注释中已经阐述了扩展实现的加载顺序，此处不再赘述。

这一小节到此为止讨论的都是 @Adaptive 注解在接口方法上的情况，实际上 @Adaptive 还可以注解在类上面，表示直接指定了接口对应的适配类，不需要生成代码，这种情况相对来说比较简单。

## 2.4 扩展点自动激活

### 2.4.1 getActivateExtension

getActivateExtension 一共有四个同名函数，其它三个都是调用的下面这一个，只是指定了部分参数而已。

此函数的上半部分是把需要激活，但是不在参数数组 names 里面的扩展点激活，下半部分是把 names 里面的扩展点激活。

```java
    /**
     * 获取需要激活的扩展点。
     *
     * @param url    url
     * @param values extension point names
     * @param group  group
     * @return extension list which are activated
     * @see org.apache.dubbo.common.extension.Activate
     */
    public List<T> getActivateExtension(URL url, String[] values, String group) {
        List<T> activateExtensions = new ArrayList<>();
        List<String> names = values == null ? new ArrayList<>(0) : Arrays.asList(values);
        // 所有用户自己配置的 filter 信息（有些 Filter 是默认激活的，有些是配置激活的，这里这里的 names 就指的配置激活的 filter 信息）
        // 如果 names 不包含 "-default"，<dubbo:service filter="-default" /> 配置代表移除所有 Dubbo 默认的过滤器
        // 在这一个 if 块里添加 Dubbo 默认的过滤器
        if (!names.contains(REMOVE_VALUE_PREFIX + DEFAULT_KEY)) {
            getExtensionClasses();
            // 遍历缓存
            // cachedActivates 存储的是扩展名与加有 @Activate 的自动激活类的映射
            for (Map.Entry<String, Object> entry : cachedActivates.entrySet()) {
                String name = entry.getKey();
                Object activate = entry.getValue();

                String[] activateGroup, activateValue;

                if (activate instanceof Activate) {
                    activateGroup = ((Activate) activate).group();
                    activateValue = ((Activate) activate).value();
                } else if (activate instanceof com.alibaba.dubbo.common.extension.Activate) {
                    activateGroup = ((com.alibaba.dubbo.common.extension.Activate) activate).group();
                    activateValue = ((com.alibaba.dubbo.common.extension.Activate) activate).value();
                } else {
                    continue;
                }
                // group 用来区分是在 provider 端生效还是 consumer 端生效
                // 如果和指定的 group 匹配，并且同时满足以下三个条件时，将对象添加到列表里
                // 1. 函数传进来的参数 names 里面不包含扩展名
                // 2. 函数传进来的参数 names 里面不包含 "-" + name
                // 3. isActive 返回的结果是要激活
                if (isMatchGroup(group, activateGroup)
                        && !names.contains(name)
                        && !names.contains(REMOVE_VALUE_PREFIX + name)
                        && isActive(activateValue, url)) {
                    activateExtensions.add(getExtension(name));
                }
            }
            // 排序
            activateExtensions.sort(ActivateComparator.COMPARATOR);
        }
        List<T> loadedExtensions = new ArrayList<>();
        // 遍历传进来的参数 names
        // 在这一个循环里添加用户指定的过滤器
        for (int i = 0; i < names.size(); i++) {
            String name = names.get(i);
            // 如果 name 不是以 "-" 开头，而且 names 不包含 "-" + name
            if (!name.startsWith(REMOVE_VALUE_PREFIX)
                    && !names.contains(REMOVE_VALUE_PREFIX + name)) {
                // 如果 name 等于 "default"
                if (DEFAULT_KEY.equals(name)) {
                    if (!loadedExtensions.isEmpty()) {
                        // 先把 loadedExtensions 里面的元素全部加到要返回的结果集里
                        // 然后清空 loadedExtensions
                        activateExtensions.addAll(0, loadedExtensions);
                        loadedExtensions.clear();
                    }
                } else {
                    // 添加到 loadedExtensions 里
                    loadedExtensions.add(getExtension(name));
                }
            }
        }
        if (!loadedExtensions.isEmpty()) {
            activateExtensions.addAll(loadedExtensions);
        }
        // 返回扩展点
        return activateExtensions;
    }
    
    // 判断 group 是否匹配
    private boolean isMatchGroup(String group, String[] groups) {
        if (group == null || group.length() == 0) {
            return true;
        }
        // 遍历，如果 groups 里面有就返回 true
        if (groups != null && groups.length > 0) {
            for (String g : groups) {
                if (group.equals(g)) {
                    return true;
                }
            }
        }
        return false;
    }
    
    // 是否应该被激活加载
    private boolean isActive(Activate activate, URL url) {
        String[] keys = activate.value();
        if (keys.length == 0) {
            return true;
        }
        // 对于 @Activate 中的每个 key
        for (String key : keys) {
            // 遍历 URL 的每个参数
            for (Map.Entry<String, String> entry : url.getParameters().entrySet()) {
                String k = entry.getKey();
                String v = entry.getValue();
                // 如果参数的 key 等于 key，或者有参数的 key 以 "." + key 结尾
                // 且其 value 不为 null
                if ((k.equals(key) || k.endsWith("." + key))
                        && ConfigUtils.isNotEmpty(v)) {
                    return true;
                }
            }
        }
        return false;
    }
```

### 2.4.2 @Activate

@Activate 主要用在 Filter（Listener） 上面，有的 Filter 需要在 Provider 端加载，有的 Filter 需要在 Consumer 端加载。当前的运行端决定哪些 Filter 需要被引入执行。

```java
/**
 * 激活。此注释可用于根据给定条件自动激活某些扩展，例如：@Activate 可用于在
 * 接口有多个实现的时候加载某些 Filter 扩展点。
 *
 * group 指定了一个组的条件，SPI 框架定义了有效的组的 value。
 * value 表示 URL 中指定的参数。
 *
 * SPI 提供了可以用来根据给定条件激活扩展的函数 getActivateExtension。
 *
 * @see SPI
 * @see URL
 * @see ExtensionLoader
 */
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE, ElementType.METHOD})
public @interface Activate {
    /**
     * 当其中一个组匹配的时候激活当前的扩展，传递给 getActivateExtension 的组
     * 将用于匹配。
     *
     * @return group names to match
     * @see ExtensionLoader#getActivateExtension(URL, String, String)
     */
    String[] group() default {};

    /**
     * 当指定的 key 出现在 URL 参数中的时候激活当前扩展。
     *
     * 例如，给定 @Activate("cache, validation")，只有当 cache 或 validation 作为
     * key 出现在 URL 的参数中的时候，当前扩展才会返回。
     *
     * @return URL parameter keys
     * @see ExtensionLoader#getActivateExtension(URL, String)
     * @see ExtensionLoader#getActivateExtension(URL, String, String)
     */
    String[] value() default {};

    /**
     * 排序信息，可以不提供。
     *
     * @return extension list which should be put before the current one
     */
    String[] before() default {};

    /**
     * 排序信息，可以不提供。
     *
     * @return extension list which should be put after the current one
     */
    String[] after() default {};

    /**
     * 排序信息，可以不提供。
     *
     * @return absolute ordering info
     */
    int order() default 0;
}
```

## 2.5 IOC 与 AOP

最后再总结一下 IOC 和 AOP 在 Dubbo 中的应用。

### 2.5.1 IOC

Dubbo 的依赖注入体现在扩展点加载的环节，具体来说就是 injectExtension 方法中。

injectExtension 方法在三个部分被使用：创建扩展点（createExtension）、创建自适应扩展点（createAdaptiveExtension）、为 Wrapper 进行属性注入（createExtension）。

依赖注入的方式是类的 setter 方法，完成依赖注入的流程如下：

* 获取 instance 的 setter 方法（以 set 开头的方法），获取方法的属性类型。
* 使用 objectFactory 创建一个该类型的对象实例。
* 执行 instance 的 setter 方法，为其注入刚刚创建的对象实例。

### 2.5.2 AOP

Dubbo 的面向切面编程也体现在扩展点加载环节。

通过 Wrapper 类可以把所有扩展点公共逻辑移至 Wrapper 中。新加的 Wrapper 在所有的扩展点上添加了逻辑，有些类似 AOP，即 Wrapper 代理了扩展点。

以 Protocol 的加载为例，其对应的配置文件中有如下两行：

```txt
filter=com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper
listener=com.alibaba.dubbo.rpc.protocol.ProtocolListenerWrapper
```

这两个类没有 @Adaptive 注解且具有含 Protocol 的单参构造器，会被看成是 Protocol 的 Wrapper 包装类。

createExtension 的 Wrapper 部分，首先是获取 ProtocolListenerWrapper 的单参构造器，然后创建 ProtocolListenerWrapper 实例，最后完成对 ProtocolListenerWrapper 实例进行属性注入，注意此时的 instance 变成了 ProtocolListenerWrapper 实例，而不再是之前的 DubboProtocol 实例了。之后使用 ProtocolFilterWrapper 以同样的方式进行包装，只是此时 ProtocolFilterWrapper 包装的是 ProtocolListenerWrapper 实例。

AOP 用到了装饰器设计模式。

### 2.5.3 Spring 的 AOP 增强方式

分别有以下五种：

| 增强类型 | 应用场景 |
| - | - |
| 前置增强 | 权限控制，记录调用日志 |
| 后置增强 | 统计分析结果数据 |
| 异常增强 | 通过日志记录方法异常信息 |
| 最终增强 | 释放资源 |
| 环绕增强 | 缓存、性能、权限、事务管理 |

代码框架如下：

```java
// 环绕
try {
    // 前置
    Systen.out.println("---");
    // 后置
} catch (Exception e) {
    // 异常
} finally {
    // 最终
}
```

## 2.6 参考

* [Dubbo 官网](http://dubbo.apache.org/zh-cn/docs/source_code_guide/dubbo-spi.html)
* [Dubbo源码解析（二）Dubbo扩展机制SPI](https://segmentfault.com/a/1190000016842868)
* [【Java】ServiceLoader源码分析](https://www.cnblogs.com/a526583280/p/10871795.html)
* [ServiceLoader源代码分析](https://www.jianshu.com/p/a6073e9f8cb4)
* [从dubbo内核分析IOC&AOP](https://www.jianshu.com/p/189c8a0708be)