# 9. 服务调用过程

服务调用的过程包含前面的所有小节，还有过滤器链、序列化、服务降级、编解码、线程派发、通信等等内容。

此小节将会涉及到的内容有通信、编解码、线程派发、请求发送和响应。

> 1. [服务暴露](https://github.com/Augustvic/DubboSourceCodeAnalysis/blob/master/md/dubbo/3.md)、[服务引入](https://github.com/Augustvic/DubboSourceCodeAnalysis/blob/master/md/dubbo/4.md)、[目录和路由](https://github.com/Augustvic/DubboSourceCodeAnalysis/blob/master/md/dubbo/5.md)、[集群容错](https://github.com/Augustvic/DubboSourceCodeAnalysis/blob/master/md/dubbo/7.md)、[负载均衡](https://github.com/Augustvic/DubboSourceCodeAnalysis/blob/master/md/dubbo/8.md) 等内容请参考前面的内容。
> 2. Netty 组件和数据编解码过程的相关内容请参考 [Dubbo 协议与通信过程](https://github.com/Augustvic/DubboSourceCodeAnalysis/blob/master/md/dubbo/12.md) 。
> 3. 过滤器链的相关内容请参考 [过滤器链](https://github.com/Augustvic/DubboSourceCodeAnalysis/blob/master/md/dubbo/13.md) 。
> 4. 异步请求和响应的相关内容请参考 [异步调用和线程模型](https://github.com/Augustvic/DubboSourceCodeAnalysis/blob/master/md/dubbo/14.md) 。

## 9.1 调用服务

一次简单的调用主要经过了以下流程：

<img src="https://github.com/Augustvic/DubboSourceCodeAnalysis/blob/master/images/invoke.PNG" width=50% />

从左到右依次经历：

* Client：客户端通过代理对象（Proxy）发起远程调用，首先对消息头（Header）进行编码（Codec），对数据（Body）进行序列化（Serialization），最后将编码后的请求发送给服务端。
* Server：服务端接收请求，首先对消息头进行解码，然后对数据进行反序列化，将解码后的请求发送给分发器。
* Dispatcher：分发器将请求派发到指定的线程池里。
* ThreadPool：在线程池中调用服务的具体实现（Implement）。

服务端把响应数据发送回客户端和客户端接收响应数据与上述过程相反。客户端接收到响应的数据之后，此次远程调用就完成了。

调用过程从代理类开始，在 [服务引入](https://github.com/Augustvic/DubboSourceCodeAnalysis/blob/master/md/4.md) 一节中已经阐述过创建代理类的过程。

将运行时参数存储到数组中，然后调用 InvocationHandler 的 invoke 方法。

**InvokerInvocationHandler.invoke**

这里分成了很多种情况，一般情况下会跳过中间的 if-else 块。

创建一个 RpcInvocation，把 method 和 args 参数封装到里面，然后调用 invoker 的 invoke 方法，会得到一个 Result 类型的数据，把它返回给代理类。

```java
    // 调用
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (method.getDeclaringClass() == Object.class) {
            return method.invoke(invoker, args);
        }
        // 方法名字
        String methodName = method.getName();
        // 方法参数
        Class<?>[] parameterTypes = method.getParameterTypes();
        // 方法没有参数
        if (parameterTypes.length == 0) {
            if ("toString".equals(methodName)) {
                // toString 方法
                return invoker.toString();
            } else if ("$destroy".equals(methodName)) {
                invoker.destroy();
                return null;
            } else if ("hashCode".equals(methodName)) {
                // hashCode 方法
                return invoker.hashCode();
            }
        } else if (parameterTypes.length == 1 && "equals".equals(methodName)) {
            // equals 方法
            return invoker.equals(args[0]);
        }
        // 根据 method 和 args 构造 RpcInvocation
        // 调用 invoker 的 invoke 方法
        RpcInvocation rpcInvocation = new RpcInvocation(method, invoker.getInterface().getName(), args);
        String serviceKey = invoker.getUrl().getServiceKey();
        rpcInvocation.setTargetServiceUniqueName(serviceKey);
      
        if (consumerModel != null) {
            rpcInvocation.put(Constants.CONSUMER_MODEL, consumerModel);
            rpcInvocation.put(Constants.METHOD_MODEL, consumerModel.getMethodModel(method));
        }
        // 根据 method 和 args 构造 RpcInvocation
        // 调用 invoker 的 invoke 方法，返回结果
        return invoker.invoke(rpcInvocation).recreate();
    }
```

**ClusterInvoker.invoke**

在 [服务引入](https://github.com/Augustvic/DubboSourceCodeAnalysis/blob/master/md/dubbo/4.md) 一节中谈到将服务提供者 invoker 通过 cluster.join 聚合成一个 invoker，默认为 FailoverClusterInvoker（FailoverClusterInvoker 外面会包装一层 MockClusterInvoker），接着调用 FailoverClusterInvoker 的 invoke 方法，将会经过集群容错机制、负载均衡选择器和过滤器，到达代表服务提供者的 DubboInvoker。

**AsyncToSyncInvoker.invoke**

DubboInvoker 会被 AsyncToSyncInvoker 包装（服务引入中提到过），所以在到达 DubboInvoker 之前，先经过 AsyncToSyncInvoker 的 invoke 方法。

在这个 invoke 方法中比较重要的部分是对异步调用的处理。如果是 SYNC 模式，直接在当前线程中调用 Result（Completable） 的 get 方法进行超时等待，如果超过等待时间还没有结果，将会把异常写入结果中，并继续后面的流程；如果是 FUTURE 或者 ASYNC 模式，不会再当前线程中马上调用 get 获取结果，而是直接返回 Result，后续再根据需要获取结果。

```java
    @Override
    public Result invoke(Invocation invocation) throws RpcException {
        // 获取结果
        Result asyncResult = invoker.invoke(invocation);
        try {
            // 如果是同步模式，直接调用 get 方法获取结果
            if (InvokeMode.SYNC == ((RpcInvocation) invocation).getInvokeMode()) {
                asyncResult.get(Integer.MAX_VALUE, TimeUnit.MILLISECONDS);
            }
        } catch (InterruptedException e) {
            throw new RpcException("Interrupted unexpectedly while waiting for remote result to return!  method: " +
                    invocation.getMethodName() + ", provider: " + getUrl() + ", cause: " + e.getMessage(), e);
        } catch (ExecutionException e) {
            ...
        } catch (Throwable e) {
            throw new RpcException(e.getMessage(), e);
        }
        // 如果是 ASYNC/FUTURE 模式，返回结果，不马上获取
        return asyncResult;
    }
```

**AbstractInvoker.invoke**

DubboInvoker 继承自 AbstractInvoker，invoke 方法在 AbstractInvoker 中实现。

此处使用了模板模式。invoke 方法中只是定义了添加 attachments 等信息的操作，调用的流程在 doInvoke 方法中。doInvoke 由具体的子类实现。

```java
    // Invoker 调用服务
    @Override
    public Result invoke(Invocation inv) throws RpcException {
        // 由于注册中心地址刷新导致 invoker 被销毁，仍然允许当前 invoker 继续执行
        if (destroyed.get()) {
            logger.warn("Invoker for service " + this + " on consumer " + NetUtils.getLocalHost() + " is destroyed, "
                    + ", dubbo version is " + Version.getVersion() + ", this invoker should not be used any longer");
        }
        RpcInvocation invocation = (RpcInvocation) inv;
        // 设置 invoker 到 invocation 中
        invocation.setInvoker(this);
        // 设置 attachment 到 invocation 中
        if (CollectionUtils.isNotEmptyMap(attachment)) {
            invocation.addObjectAttachmentsIfAbsent(attachment);
        }
        // 添加 contextAttachments 到 RpcInvocation#attachment 变量中
        // RpcContext 是一个 ThreadLocal 的临时状态记录器，通过 ThreadLocal 使得每个线程维护自己的RpcContext对象。
        // 在处理完上一个请求之后线程中的 RpcContext 对象被销毁之前，
        // 下一个请求如果进来并复用上一个请求的线程的话，
        // 这时候访问 RpcContext 对象就会访问到上一个请求保存下来的数据，
        // 所以每次处理完请求之后应该及时清除 RpcContext 对象中的数据防止下一个请求访问到。
        Map<String, Object> contextAttachments = RpcContext.getContext().getObjectAttachments();
        if (CollectionUtils.isNotEmptyMap(contextAttachments)) {
            invocation.addObjectAttachments(contextAttachments);
        }
        // 设置调用方式，有 FUTURE、ASYNC 和 SYNC 三种
        // 调用 RpcUtils 的 getInvokeMode 方法获取，
        invocation.setInvokeMode(RpcUtils.getInvokeMode(url, invocation));
        // 添加 invoker 的编号
        RpcUtils.attachInvocationIdIfAsync(getUrl(), invocation);

        AsyncRpcResult asyncResult;
        try {
            // doInvoke 抽象方法
            // 保存结果
            asyncResult = (AsyncRpcResult) doInvoke(invocation);
        } catch (InvocationTargetException e) { // biz exception
            Throwable te = e.getTargetException();
            if (te == null) {
                asyncResult = AsyncRpcResult.newDefaultAsyncResult(null, e, invocation);
            } else {
                if (te instanceof RpcException) {
                    ((RpcException) te).setCode(RpcException.BIZ_EXCEPTION);
                }
                asyncResult = AsyncRpcResult.newDefaultAsyncResult(null, te, invocation);
            }
        } catch (RpcException e) {
            if (e.isBiz()) {
                asyncResult = AsyncRpcResult.newDefaultAsyncResult(null, e, invocation);
            } else {
                throw e;
            }
        } catch (Throwable e) {
            asyncResult = AsyncRpcResult.newDefaultAsyncResult(null, e, invocation);
        }
        // 设置结果到 RpcContext 中，用于异步获取结果
        RpcContext.getContext().setFuture(new FutureAdapter(asyncResult.getResponseFuture()));
        // 返回结果
        return asyncResult;
    }
```

**DubboInvoker.doInvoke**

此函数的前面一小部分是获取和设置各种属性。

根据同步/异步、单向/双向进行不同的流程。如果是单向通信，直接发送数据就行了，发送完了返回空的 Result，不需要接收数据。

同步和异步模式在 AsyncToSyncInvoker 的 invoke 方法中进行了处理，所以在这里没有任何区分。这里统一调用 request 方法获取 CompletableFuture 类型的结果，然后把此结果包装成 AsyncRpcResult 并返回。

```java
    // 实现抽象方法 doInvoke
    @Override
    protected Result doInvoke(final Invocation invocation) throws Throwable {
        RpcInvocation inv = (RpcInvocation) invocation;
        // 调用的方法
        final String methodName = RpcUtils.getMethodName(invocation);
        // 设置 path 和 version 到 attachment 里面
        inv.setAttachment(PATH_KEY, getUrl().getPath());
        inv.setAttachment(VERSION_KEY, version);

        // 从 clients 数组里获取一个 ExchangeClient
        ExchangeClient currentClient;
        if (clients.length == 1) {
            currentClient = clients[0];
        } else {
            currentClient = clients[index.getAndIncrement() % clients.length];
        }
        try {
            // 是否是单向发送
            boolean isOneway = RpcUtils.isOneway(getUrl(), invocation);
            // 超时时间
            int timeout = getUrl().getMethodPositiveParameter(methodName, TIMEOUT_KEY, DEFAULT_TIMEOUT);
            if (isOneway) {
                // 如果是单向发送
                // 是否等待消息发送，默认不等待消息发出，将消息放入 IO 队列，即刻返回。
                boolean isSent = getUrl().getMethodParameter(methodName, Constants.SENT_KEY, false);
                // 单向发送不等待服务端应答，没有返回值
                currentClient.send(inv, isSent);
                // 返回结果
                return AsyncRpcResult.newDefaultAsyncResult(invocation);
            } else {
                // 需要接收结果
                // 获取回调处理线程池
                ExecutorService executor = getCallbackExecutor(getUrl(), inv);
                // 调用 ReferenceCountExchangeClient 的 request 发送消息
                // request 方法返回 CompletableFuture<Object> 类型的结果
                // 调用 thenApply 将 Object 类型的 Result 转化为 AppResponse
                CompletableFuture<AppResponse> appResponseFuture =
                        currentClient.request(inv, timeout, executor).thenApply(obj -> (AppResponse) obj);
                // save for 2.6.x compatibility, for example, TraceFilter in Zipkin uses com.alibaba.xxx.FutureAdapter
                FutureContext.getContext().setCompatibleFuture(appResponseFuture);
                // 把 Completable 类型的结果包装成 AsyncRpcResult 并返回
                AsyncRpcResult result = new AsyncRpcResult(appResponseFuture, inv);
                result.setExecutor(executor);
                // 返回结果
                return result;
            }
        } catch (TimeoutException e) {
            throw new RpcException(RpcException.TIMEOUT_EXCEPTION, "Invoke remote method timeout. method: " + invocation.getMethodName() + ", provider: " + getUrl() + ", cause: " + e.getMessage(), e);
        } catch (RemotingException e) {
            throw new RpcException(RpcException.NETWORK_EXCEPTION, "Failed to invoke remote method: " + invocation.getMethodName() + ", provider: " + getUrl() + ", cause: " + e.getMessage(), e);
        }
    }
```

## 9.2 消费者发送请求

**ExchangeClient.request**

上文提到客户端 Client 通过 request 方法发送消息，Client 具体指的是有引用计数功能的 ReferenceCountExchangeClient 对象。消费者发送请求的操作从这一个函数开始。

```java
    // ReferenceCountExchangeClient.request
    // 发送请求，有超时限制
    @Override
    public CompletableFuture<Object> request(Object request, int timeout, ExecutorService executor) throws RemotingException {
        // 调用被装饰对象的同名方法
        return client.request(request, timeout, executor);
    }
    
    // HeaderExchangeClient.request
    // 发送请求，有超时限制
    @Override
    public CompletableFuture<Object> request(Object request, int timeout, ExecutorService executor) throws RemotingException {
        return channel.request(request, timeout, executor);
    }
```

仅仅就 request 函数而言，实现是很简单的，就是调用子类的 request 方法。除此之外，在此类的内部维护了一个线程安全的引用计数的变量 refenceCount，有一个懒启动的客户端集合 ghostClientMap，以及当前的 Exchange 客户端对象 client。

HeaderExchangeClient 的 request 方法同样没什么逻辑，就是调用 ExchangeChannel 的 request 方法而已。

**HeaderExchangeChannel.request**

HeaderExchangeChannel 在 dubbo-remoting 模块中，到 ExchangeChannel 这里就到达了对底层通信框架（一般是 Netty）的封装。

在 HeaderExchangeChannel 的 request方法中创建了一个 Request 对象作为请求的载体，创建了一个 DefaultFuture 作为需要返回的 future。在 DefaultFuture 中封装了 Channel、Request 和 timeout 等，接收响应数据的工作主要在 DefaultFuture 中进行。

创建完 DefaultFuture 之后，调用 Channel 的 send 方法，开始发送数据。此处的 Channel 是 Dubbo 中自定义的 Channel，可以看成一个 Netty 客户端。

```java
    // 在 HeaderExchangeClient 的 request 方法中调用
    @Override
    public ResponseFuture request(Object request) throws RemotingException {
        return request(request, channel.getUrl().getPositiveParameter(Constants.TIMEOUT_KEY, Constants.DEFAULT_TIMEOUT));
    }

    @Override
    public ResponseFuture request(Object request, int timeout) throws RemotingException {
        // ExchangeClient 有 close 函数，关闭客户端。先判断是否关闭。
        if (closed) {
            throw new RemotingException(this.getLocalAddress(), null, "Failed to send request " + request + ", cause: The channel " + this + " is closed!");
        }
        // create request.
        // 创建 request 对象，后面再为 request 的各种属性赋值
        Request req = new Request();
        req.setVersion(Version.getProtocolVersion());
        req.setTwoWay(true);
        // Request 对象的 data 属性为传进来的 message
        req.setData(request);
        // 创建 future 对象
        DefaultFuture future = new DefaultFuture(channel, req, timeout);
        try {
            // 调用 NettyClient 的 send 方法发送请求
            channel.send(req);
        } catch (RemotingException e) {
            future.cancel();
            throw e;
        }
        // 返回 future 对象
        return future;
    }
```

**AbstractPeer.send/AbstractClient.send**

Netty 客户端的实现是 NettyClient，但在 NettyClient 中并未实现 send 方法，该方法继承自父类 AbstractPeer，而 AbstractPeer 的 send 方法又调用的是 AbstractClient 的 send 方法。

```java
    // AbstractPeer
    // 发送
    @Override
    public void send(Object message) throws RemotingException {
        send(message, url.getParameter(Constants.SENT_KEY, false));
    }

    // AbstractClient
    @Override
    public void send(Object message, boolean sent) throws RemotingException {
        // 检查连接
        if (needReconnect && !isConnected()) {
            connect();
        }
        // 获取 NettyChannel
        Channel channel = getChannel();
        //TODO Can the value returned by getChannel() be null? need improvement.
        if (channel == null || !channel.isConnected()) {
            throw new RemotingException(this, "message can not send, because channel is closed . url:" + getUrl());
        }
        // 调用 NettyChannel 的 send 方法发送消息
        channel.send(message, sent);
    }
```

**NettyClient.getChannel/NettyChannel.getOrAddChannel**

调用 channel 的 send 方法之前，需要获取 NettyChannel 实例（NettyChannel 也不是 Netty 中的 Channel）。

```java
    // 获取 NettyChannel
    @Override
    protected com.alibaba.dubbo.remoting.Channel getChannel() {
        Channel c = channel;
        if (c == null || !c.isConnected())
            return null;
        // 获取 NettyChannel
        return NettyChannel.getOrAddChannel(c, getUrl(), this);
    }

    // 获取 NettyChannel
    static NettyChannel getOrAddChannel(org.jboss.netty.channel.Channel ch, URL url, ChannelHandler handler) {
        if (ch == null) {
            return null;
        }
        // 尝试从 Map 集合中获取 NettyChannel 实例
        NettyChannel ret = channelMap.get(ch);
        if (ret == null) {
            // 集合中没有，创造一个新的 NettyChannel
            NettyChannel nc = new NettyChannel(ch, url, handler);
            // 可以连接上，把它放入 Map 集合中
            if (ch.isConnected()) {
                ret = channelMap.putIfAbsent(ch, nc);
            }
            if (ret == null) {
                ret = nc;
            }
        }
        return ret;
    }
```

**NettyChannel.send**

通过 send 发出消息。配置项中可以设置是否等待消息发出后再返回，即是否捕捉发出消息产生的异常。如果设置为等待消息发出，且发出过程中有了异常，将会在此函数中抛出。

此方法中的 Channel 是 Netty 中的 Channel，调用 writeAndFlush 将数据写入系统内存并发送出去。

```java
    /**
     * 发送消息
     */
    @Override
    public void send(Object message, boolean sent) throws RemotingException {
        // 检查通道是否关闭
        super.send(message, sent);

        boolean success = true;
        int timeout = 0;
        try {
            // 写入并发送
            ChannelFuture future = channel.writeAndFlush(message);
            // sent 的值源于 <dubbo:method sent="true/false" /> 中 sent 的配置值，有两种配置值：
            //   1. true: 等待消息发出，消息发送失败将抛出异常
            //   2. false: 不等待消息发出，将消息放入 IO 队列，即刻返回
            // 默认情况下 sent = false；
            if (sent) {
                // 超时限制
                timeout = getUrl().getPositiveParameter(TIMEOUT_KEY, DEFAULT_TIMEOUT);
                // 等待
                success = future.await(timeout);
            }
            Throwable cause = future.cause();
            if (cause != null) {
                throw cause;
            }
        } catch (Throwable e) {
            removeChannelIfDisconnected(channel);
            throw new RemotingException(this, "Failed to send message " + PayloadDropper.getRequestWithoutData(message) + " to " + getRemoteAddress() + ", cause: " + e.getMessage(), e);
        }
        // 如果发出失败，抛出异常
        if (!success) {
            throw new RemotingException(this, "Failed to send message " + PayloadDropper.getRequestWithoutData(message) + " to " + getRemoteAddress()
                    + "in timeout(" + timeout + "ms) limit");
        }
    }
```

在消息发出之前，还需要进行编码操作。Dubbo 的 数据报分成两个部分，消息头和数据。下文中也将沿用“消息头”和“数据”这两个说法。其中“编码”和“解码”通常情况下针对“消息头”，而“序列化”和“反序列化”针对的是“数据”。（后文中有些地方把解码和反序列化统称为“解码”。）

消息头的数据项在 [Dubbo 官网](http://dubbo.apache.org/zh-cn/docs/source_code_guide/service-invoking-process.html) 中有详细的说明。

> 每一个数据包的魔数完全相同。魔数用于解决拆包粘包的问题。

**ExchangeCodec.encode**

ExchangeCodec 是 Dubbo 的父类，消息头的编解码在此类中进行。

和 Request 编码有关的函数是 encode 和 encodeRequest。encode 对 Request/Response 分类讨论。encodeRequest 函数中包含了对消息头编码和对数据序列化两步操作（先写入的是数据，因为要先获取数据的长度，然后才是消息头数组 header）。执行数据序列化的 encodeRequestData 函数在子类 DubboCodec 中实现。

```java
    // ExchangeCodec
    // 消息编码
    @Override
    public void encode(Channel channel, ChannelBuffer buffer, Object msg) throws IOException {

        if (msg instanceof Request) {
            // 对 Request 编码
            encodeRequest(channel, buffer, (Request) msg);
        } else if (msg instanceof Response) {
            // 对 Response 编码
            encodeResponse(channel, buffer, (Response) msg);
        } else {
            super.encode(channel, buffer, msg);
        }
    }
    
    // Request 类型的消息编码
    protected void encodeRequest(Channel channel, ChannelBuffer buffer, Request req) throws IOException {
        // 序列化器
        Serialization serialization = getSerialization(channel);
        // 创建 header 数组
        byte[] header = new byte[HEADER_LENGTH];
        // 设置魔数
        Bytes.short2bytes(MAGIC, header);

        // 设置数据包类型（Response/Request）和序列化器编号
        header[2] = (byte) (FLAG_REQUEST | serialization.getContentTypeId());

        // 是不是双向的
        if (req.isTwoWay()) {
            header[2] |= FLAG_TWOWAY;
        }
        // 是不是事件
        if (req.isEvent()) {
            header[2] |= FLAG_EVENT;
        }

        // 请求编号，long 类型，占 8 个字节
        Bytes.long2bytes(req.getId(), header, 4);

        // buffer 当前可写的位置
        int savedWriteIndex = buffer.writerIndex();
        // 更新 buffer 可写的位置，为消息头预留（现在还没有写入），先写真实数据，即 Request
        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);
        ChannelBufferOutputStream bos = new ChannelBufferOutputStream(buffer);
        // 序列化器
        ObjectOutput out = serialization.serialize(channel.getUrl(), bos);
        if (req.isEvent()) {
            // 如果是事件，对事件数据进行序列化操作
            encodeEventData(channel, out, req.getData());
        } else {
            // 如果是请求，对请求数据进行序列化操作
            encodeRequestData(channel, out, req.getData(), req.getVersion());
        }
        out.flushBuffer();
        if (out instanceof Cleanable) {
            ((Cleanable) out).cleanup();
        }
        bos.flush();
        bos.close();
        // 写入字节数的长度
        int len = bos.writtenBytes();
        checkPayload(channel, len);

        // 把消息体长度写入到消息头中（占 4 个字节）
        Bytes.int2bytes(len, header, 12);

        // 将 buffer 指针移动到 savedWriteIndex，从 savedWriteIndex 开始写消息头
        buffer.writerIndex(savedWriteIndex);
        // 从 savedWriteIndex 位置开始写消息头
        buffer.writeBytes(header);
        // 设置新的 writeIndex，writerIndex = 原写下标 + 消息头长度 + 消息体长度
        buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);
    }
```

**DubboCodec.encodeRequestData**

DubboCodec 重写了 encodeRequestData 方法，这里面主要调用了序列化的接口。

```java
    // 对 request 对象的 data 进行序列化，并写入 channel
    @Override
    protected void encodeRequestData(Channel channel, ObjectOutput out, Object data, String version) throws IOException {
        RpcInvocation inv = (RpcInvocation) data;

        // 序列化 dubbo version，path，version
        out.writeUTF(version);
        out.writeUTF(inv.getAttachment(PATH_KEY));
        out.writeUTF(inv.getAttachment(VERSION_KEY));
        // 序列化方法名
        out.writeUTF(inv.getMethodName());
        // 序列化参数类型
        out.writeUTF(inv.getParameterTypesDesc());
        Object[] args = inv.getArguments();
        if (args != null) {
            for (int i = 0; i < args.length; i++) {
                // 运行时参数序列化
                out.writeObject(encodeInvocationArgument(channel, inv, i));
            }
        }
        // 序列化 attachments
        out.writeAttachments(inv.getObjectAttachments());
    }
```

## 9.3 提供者接收请求

提供者从 Channel 中接收到数据之后，首先需要解码和反序列化，然后将数据传递到下一个地方。解码和反序列化的逻辑在 ExchangeCodec 和 DubboCodec 中。

**ExchangeCodec.decode**

解码操作在 InternalDecode 的 decode 中触发，依次调用了 DubboCountCode.decode、ExchangeCodec.decode 方法。在此过程中还调用了 DubboCodec 的 decodeBody 方法对消息体进行反序列化。

```java
    // 解码
    @Override
    public Object decode(Channel channel, ChannelBuffer buffer) throws IOException {
        // buffer 中总的可读字节数
        int readable = buffer.readableBytes();
        // 消息头
        byte[] header = new byte[Math.min(readable, HEADER_LENGTH)];
        // 读入 header 长度的数据
        buffer.readBytes(header);
        return decode(channel, buffer, readable, header);
    }

    // 解码
    @Override
    protected Object decode(Channel channel, ChannelBuffer buffer, int readable, byte[] header) throws IOException {
        // 对 telnet 提供支持
        // 检查魔数（魔数是固定的），如果魔数不在 header 开头，说明读取的不是 header，进入 if
        // && 的优先级高于 ||
        if (readable > 0 && header[0] != MAGIC_HIGH
                || readable > 1 && header[1] != MAGIC_LOW) {
            int length = header.length;
            // 把 buffer 全部复制到 header 中
            // 读取到的 header 长度小于总的可读长度
            if (header.length < readable) {
                // 创造长度为 readable 的字节数组，把 header 复制进去，最后返回
                header = Bytes.copyOf(header, readable);
                // 把 buffer 中剩下的部分复制到 header 里面
                buffer.readBytes(header, length, readable - length);
                // 经过这一步操作之后，把 buffer 全部复制到了 header 里面
            }
            // header 现在包括了全部的 buffer
            // 可以从索引 1 开始找，因为上面的 if 已经确定了索引 0 不是魔数
            for (int i = 1; i < header.length - 1; i++) {
                // 如果找到了魔数
                if (header[i] == MAGIC_HIGH && header[i + 1] == MAGIC_LOW) {
                    // 把 buffer 的 readerIndex 退回到魔数的位置
                    // 之前 readerIndex 已经设置到 header.length 位置了，现在往回退
                    buffer.readerIndex(buffer.readerIndex() - header.length + i);
                    // 把魔数之前的部分保存在 header 中
                    header = Bytes.copyOf(header, i);
                    break;
                }
            }
            // 如果找到了魔数，header 表示魔数之前的数据
            // 如果没找到魔数，header 表示 buffer 中所有数据
            // 调用 TelnetCodec 的 decode 方法对数据包进行解码
            return super.decode(channel, buffer, readable, header);
        }

        // buffer 以魔数开头，说明直接就是消息头
        // 可读长度小于消息头长度，显然需要继续等待数据
        if (readable < HEADER_LENGTH) {
            return DecodeResult.NEED_MORE_INPUT;
        }
        // 获取消息体的长度
        int len = Bytes.bytes2int(header, 12);
        checkPayload(channel, len);
        // 数据包（消息头加消息体）长度
        int tt = len + HEADER_LENGTH;
        // 长度不够，继续等待
        if (readable < tt) {
            return DecodeResult.NEED_MORE_INPUT;
        }

        // 到这里的时候，buffer 的 readerIndex 指向的是消息体的起始位置
        ChannelBufferInputStream is = new ChannelBufferInputStream(buffer, len);

        try {
            // 解析消息体，返回消息体
            return decodeBody(channel, is, header);
        } finally {
            if (is.available() > 0) {
                try {
                    if (logger.isWarnEnabled()) {
                        logger.warn("Skip input stream " + is.available());
                    }
                    StreamUtils.skipUnusedStream(is);
                } catch (IOException e) {
                    logger.warn(e.getMessage(), e);
                }
            }
        }
    }
```

**DubboCodec.decodeBody**

DubboCodec 重写了 decodeBody 方法。

根据调用类型分成 request 和 response 两类，response 是消费端接收到服务端返回的消息时的解码操作，request 是我们此刻要讨论的服务端对请求消息解码操作。

其实这两种情况都差不多，只是 response 类型解码出来放在 DecodeableRpcResult 的对象里面，因为获得的是调用的结果，而 request 类型解码出来放在 DecodeableRpcInvocation 里面，因为要调用提供者的方法。

在这里需要根据配置确定是否在当前的 IO 线程上解码。如果就在 IO 线程上解码，马上调用 DecodeableRpcInvocation 的 decode 函数，否则不调用，继续往后传递。

```java
    // 重写 decodeBody
    @Override
    protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException {
        // 获取序列化器编号
        byte flag = header[2], proto = (byte) (flag & SERIALIZATION_MASK);
        // 获取调用编号
        long id = Bytes.bytes2long(header, 4);
        // 获取调用类型，如果调用类型是 response 类型的话
        if ((flag & FLAG_REQUEST) == 0) {
            // 对 response 类型的数据进行解码
            // 创建 Response 对象
            Response res = new Response(id);
            if ((flag & FLAG_EVENT) != 0) {
                res.setEvent(true);
            }
            // 获取状态
            byte status = header[3];
            // 设置状态
            res.setStatus(status);
            try {
                // 状态为 OK，说明响应正常
                if (status == Response.OK) {
                    Object data;
                    if (res.isEvent()) {
                        // 反序列化事件数据
                        ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);
                        data = decodeEventData(channel, in);
                    } else {
                        DecodeableRpcResult result;
                        // 判断是否在 IO 线程上执行解码
                        if (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) {
                            // 创建 DecodeableRpcResult 对象
                            result = new DecodeableRpcResult(channel, res, is,
                                    (Invocation) getRequestData(id), proto);
                            // 解码
                            result.decode();
                        } else {
                            // 只创建 DecodeableRpcResult 对象，不解码
                            result = new DecodeableRpcResult(channel, res,
                                    new UnsafeByteArrayInputStream(readMessageData(is)),
                                    (Invocation) getRequestData(id), proto);
                        }
                        data = result;
                    }
                    // 设置 DecodeableRpcResult 对象（即数据）到 Response 中
                    res.setResult(data);
                } else {
                    // 状态不 OK，设置错误信息
                    ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);
                    res.setErrorMessage(in.readUTF());
                }
            } catch (Throwable t) {
                // 解码过程中出现了错误，此时设置 CLIENT_ERROR 状态码到 Response 对象中
                if (log.isWarnEnabled()) {
                    log.warn("Decode response failed: " + t.getMessage(), t);
                }
                res.setStatus(Response.CLIENT_ERROR);
                res.setErrorMessage(StringUtils.toString(t));
            }
            return res;
        } else {
            // 对 request 数据进行解码
            // 创建 Request 对象
            Request req = new Request(id);
            // 设置版本，通信方式
            req.setVersion(Version.getProtocolVersion());
            req.setTwoWay((flag & FLAG_TWOWAY) != 0);
            if ((flag & FLAG_EVENT) != 0) {
                req.setEvent(true);
            }
            try {
                Object data;
                if (req.isEvent()) {
                    // 对事件数据进行解码
                    ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);
                    data = decodeEventData(channel, in);
                } else {
                    DecodeableRpcInvocation inv;
                    // 根据 url 的参数判断是否在 IO 线程上解码
                    if (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) {
                        inv = new DecodeableRpcInvocation(channel, req, is, proto);
                        // 在当前线程，也就是 IO 线程上解码。解码完成后，可将
                        // 调用方法名、attachment、以及调用参数解析出来
                        inv.decode();
                    } else {
                        // 创建 DecodeableRpcInvocation 对象，不在 IO 线程上解码
                        inv = new DecodeableRpcInvocation(channel, req,
                                new UnsafeByteArrayInputStream(readMessageData(is)), proto);
                    }
                    data = inv;
                }
                // 设置 data 到 request 中
                req.setData(data);
            } catch (Throwable t) {
                if (log.isWarnEnabled()) {
                    log.warn("Decode request failed: " + t.getMessage(), t);
                }
                // 若解码过程中出现异常，则将 broken 字段设为 true，
                // 并将异常对象设置到 Reqeust 对象中
                req.setBroken(true);
                req.setData(t);
            }
            return req;
        }
    }
```

**DecodeableRpcInvocation.decode**

一个 DecodeableRpcInvocation 对应一个 Request 实例，反序列化得到的字段将会存储在 Request 实例中。

```java
    // 解码
    @Override
    public void decode() throws Exception {
        if (!hasDecoded && channel != null && inputStream != null) {
            // 如果还没有解码
            try {
                // 解码
                decode(channel, inputStream);
            } catch (Throwable e) {
                if (log.isWarnEnabled()) {
                    log.warn("Decode rpc invocation failed: " + e.getMessage(), e);
                }
                request.setBroken(true);
                request.setData(e);
            } finally {
                hasDecoded = true;
            }
        }
    }
    
    // 解码
    @Override
    public Object decode(Channel channel, InputStream input) throws IOException {
        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)
                .deserialize(channel.getUrl(), input);
        // 获取 dubbo version，保存到 attachment 中
        String dubboVersion = in.readUTF();
        request.setVersion(dubboVersion);
        setAttachment(DUBBO_VERSION_KEY, dubboVersion);
        // 获取 path 和 version
        String path = in.readUTF();
        setAttachment(PATH_KEY, path);
        setAttachment(VERSION_KEY, in.readUTF());
        // 设置方法名
        setMethodName(in.readUTF());
        // 参数类型
        String desc = in.readUTF();
        setParameterTypesDesc(desc);

        try {
            // 空数组
            Object[] args = DubboCodec.EMPTY_OBJECT_ARRAY;
            Class<?>[] pts = DubboCodec.EMPTY_CLASS_ARRAY;
            if (desc.length() > 0) {
                // 有参数
                ServiceRepository repository = ApplicationModel.getServiceRepository();
                ServiceDescriptor serviceDescriptor = repository.lookupService(path);
                if (serviceDescriptor != null) {
                    MethodDescriptor methodDescriptor = serviceDescriptor.getMethod(getMethodName(), desc);
                    if (methodDescriptor != null) {
                        pts = methodDescriptor.getParameterClasses();
                        this.setReturnTypes(methodDescriptor.getReturnTypes());
                    }
                }
                if (pts == DubboCodec.EMPTY_CLASS_ARRAY) {
                    // 解析参数类型数组
                    pts = ReflectUtils.desc2classArray(desc);
                }

                args = new Object[pts.length];
                for (int i = 0; i < args.length; i++) {
                    try {
                        // 获取运行时参数值
                        args[i] = in.readObject(pts[i]);
                    } catch (Exception e) {
                        if (log.isWarnEnabled()) {
                            log.warn("Decode argument failed: " + e.getMessage(), e);
                        }
                    }
                }
            }
            // 参数类型的数组
            setParameterTypes(pts);
            // 得到原来的 attachment 的内容，存入 map
            Map<String, Object> map = in.readAttachments();
            if (map != null && map.size() > 0) {
                Map<String, Object> attachment = getObjectAttachments();
                if (attachment == null) {
                    attachment = new HashMap<>();
                }
                // 把 map 的内容全部添加到 attachment 里面
                attachment.putAll(map);
                setObjectAttachments(attachment);
            }

            // 对 callback 类型的参数进行处理
            for (int i = 0; i < args.length; i++) {
                args[i] = decodeInvocationArgument(channel, this, pts, i, args[i]);
            }
            // 设置参数值
            setArguments(args);
            String targetServiceName = buildKey((String) getAttachment(PATH_KEY),
                    getAttachment(GROUP_KEY),
                    getAttachment(VERSION_KEY));
            setTargetServiceUniqueName(targetServiceName);
        } catch (ClassNotFoundException e) {
            throw new IOException(StringUtils.toString("Read invocation data failed.", e));
        } finally {
            if (in instanceof Cleanable) {
                ((Cleanable) in).cleanup();
            }
        }
        return this;
    }
```

Request 将会被传递到 NettyHandler 的 messageReceived 方法中，然后继续往下传递。

在 NettyHandler 的 messageReceived 方法中将会调用 handler 的 received 方法，在创建 NettyHandler 时传入的 handler 为 NettyClient 实例，所以调用的时 NettyClient 的 received 方法。

AbstractPeer 的 received 方法，接着将会调用 MultiMessageHandler、HeartbeatHandler 的 receive 方法（可以从 ChannelHandlers 中看到）。这些 receive 方法中没有什么复杂的逻辑。

之后将会使用线程派发模型对逻辑任务进行派发。此时需要决定逻辑任务是继续在 IO 线程上进行处理还是派发到特定的线程池中进行处理。

Dispatcher 线程派发器支持五种不同的线程派发策略。默认的是使用 ALL 派发策略，也就是所有的任务（请求、响应、连接和断开）都派发到线程池中，对应的类是 AllChannelHandler。

**AllChannelHandler**

由于所有的任务都将派发到线程池中执行，AllChannelHandler 类中的所有函数几乎都是同一种结构：第一步获取线程池，第二步创建 ChannelEventRunnable 任务，最后在线程池中运行。

```java
public class AllChannelHandler extends WrappedChannelHandler {

    public AllChannelHandler(ChannelHandler handler, URL url) {
        super(handler, url);
    }

    // 连接事件
    @Override
    public void connected(Channel channel) throws RemotingException {
        // 获取线程池
        ExecutorService executor = getExecutorService();
        try {
            // 创建 ChannelEventRunnable，在线程池中处理连接事件
            executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CONNECTED));
        } catch (Throwable t) {
            throw new ExecutionException("connect event", channel, getClass() + " error when process connected event .", t);
        }
    }

    // 断开连接事件
    @Override
    public void disconnected(Channel channel) throws RemotingException {
        ExecutorService executor = getExecutorService();
        try {
            executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.DISCONNECTED));
        } catch (Throwable t) {
            throw new ExecutionException("disconnect event", channel, getClass() + " error when process disconnected event .", t);
        }
    }

    // 请求 request 和响应 response 事件
    @Override
    public void received(Channel channel, Object message) throws RemotingException {
        ExecutorService executor = getPreferredExecutorService(message);
        try {
            // 创建 ChannelEventRunnable，在线程池中处理请求或响应事件
            executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.RECEIVED, message));
        } catch (Throwable t) {
            // 线程池满了或者拒绝调用或者没有返回或者超时
        	if(message instanceof Request && t instanceof RejectedExecutionException){
        	    // sendFeedback 处理
                sendFeedback(channel, (Request) message, t);
                return;
        	}
            throw new ExecutionException(message, channel, getClass() + " error when process received event .", t);
        }
    }

    // 异常信息
    @Override
    public void caught(Channel channel, Throwable exception) throws RemotingException {
        ExecutorService executor = getExecutorService();
        try {
            executor.execute(new ChannelEventRunnable(channel, handler, ChannelState.CAUGHT, exception));
        } catch (Throwable t) {
            throw new ExecutionException("caught event", channel, getClass() + " error when process caught event .", t);
        }
    }
}
```

**ChannelEventRunnable.run**

ChannelEventRunnable 相当于一个中转站，完成了任务从 IO 线程到线程池的转移，转移之后直接把参数传递给其它的 ChannelHandler 对象进行处理。

```java
    @Override
    public void run() {
        // 根据状态调用 handler 的不同方法
        // response/request
        if (state == ChannelState.RECEIVED) {
            try {
                // 调用相应方法
                handler.received(channel, message);
            } catch (Exception e) {
                logger.warn("ChannelEventRunnable handle " + state + " operation error, channel is " + channel
                        + ", message is " + message, e);
            }
        } else {
            switch (state) {
            case CONNECTED:
                // 连接
                try {
                    handler.connected(channel);
                } catch (Exception e) {
                    logger.warn("ChannelEventRunnable handle " + state + " operation error, channel is " + channel, e);
                }
                break;
            case DISCONNECTED:
                // 断开连接
                try {
                    handler.disconnected(channel);
                } catch (Exception e) {
                    logger.warn("ChannelEventRunnable handle " + state + " operation error, channel is " + channel, e);
                }
                break;
            case SENT:
                // 发送
                try {
                    handler.sent(channel, message);
                } catch (Exception e) {
                    logger.warn("ChannelEventRunnable handle " + state + " operation error, channel is " + channel
                            + ", message is " + message, e);
                }
                break;
            case CAUGHT:
                // 捕获异常
                try {
                    handler.caught(channel, exception);
                } catch (Exception e) {
                    logger.warn("ChannelEventRunnable handle " + state + " operation error, channel is " + channel
                            + ", message is: " + message + ", exception is " + exception, e);
                }
                break;
            default:
                logger.warn("unknown state: " + state + ", message is " + message);
            }
        }
    }
```

**DecodeHandler.received**

以 Request/Reponse 为例。参数传递给 DecodeHandler.received 方法处理。

在上文的 “DubboCodec.decodeBody” 小节中提到，如果不在 IO 线程中执行解码逻辑，将不会直接调用 decode 方法进行解码。

现在已经完成了线程派发，可以开始解码了。在 DecodeHandler 的 received 方法和 decode 方法中调用 decode 开始解码。（对 Request 的 data 对象调用 decode 方法。Request 的 data 对象是 DecodeableRpcInvocation 的实例，实现了 Decodeable 接口。）

```java
    @Override
    public void received(Channel channel, Object message) throws RemotingException {
        if (message instanceof Decodeable) {
            // 对 Decodeable 接口实现类对象进行解码
            decode(message);
        }
        if (message instanceof Request) {
            // 对 Request 的 data 进行解码
            decode(((Request) message).getData());
        }
        if (message instanceof Response) {
            // 对 Response 的 result 进行解码
            decode(((Response) message).getResult());
        }
        handler.received(channel, message);
    }

    // 对 Request/Response 解码
    private void decode(Object message) {
        // Decodeable 接口目前有两个实现类，
        // 分别为 DecodeableRpcInvocation 和 DecodeableRpcResult
        if (message instanceof Decodeable) {
            try {
                // 解码
                ((Decodeable) message).decode();
                if (log.isDebugEnabled()) {
                    log.debug("Decode decodeable message " + message.getClass().getName());
                }
            } catch (Throwable e) {
                if (log.isWarnEnabled()) {
                    log.warn("Call Decodeable.decode failed: " + e.getMessage(), e);
                }
            } // ~ end of catch
        } // ~ end of if
    } // ~ end of method decode
```

**HeaderExchangeHandler.received**

当 Request 对象从 DecodeHandler 传递到 HeaderExchangeHandler 的 received 方法时，已经完成解码，之后开始方法调用的流程。

Request 类型的消息在 HeaderExchangeHandler 类的 handleRequest 函数中处理。从 Request 中获取 RpcInvocation，进而获取 Invoker。

reply 方法返回 CompletableFuture 用于获取结果，并调用 whenComplete 方法用于回调处理。在方法调用完成之后，返回响应 Response，并通过 channel 发送给服务消费者。（channel 一直作为参数在各种方法中传递。）

```java
    @Override
    public void received(Channel channel, Object message) throws RemotingException {
        final ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
        if (message instanceof Request) {
            // 请求类型的对象
            Request request = (Request) message;
            if (request.isEvent()) {
                // 事件
                handlerEvent(channel, request);
            } else {
                if (request.isTwoWay()) {
                    // 双向通信
                    handleRequest(exchangeChannel, request);
                } else {
                    // 单向通信，只需要调用，没有结果
                    handler.received(exchangeChannel, request.getData());
                }
            }
        } else if (message instanceof Response) {
            // 响应类型的对象
            handleResponse(channel, (Response) message);
        } else if (message instanceof String) {
            // telnet 类型
            if (isClientSide(channel)) {
                Exception e = new Exception("Dubbo client can not supported string message: " + message + " in channel: " + channel + ", url: " + channel.getUrl());
                logger.error(e.getMessage(), e);
            } else {
                String echo = handler.telnet(channel, (String) message);
                if (echo != null && echo.length() > 0) {
                    channel.send(echo);
                }
            }
        } else {
            handler.received(exchangeChannel, message);
        }
    }
    
    // 有返回值 request 的处理过程
    void handleRequest(final ExchangeChannel channel, Request req) throws RemotingException {
        Response res = new Response(req.getId(), req.getVersion());
        // 检测请求是否合法
        if (req.isBroken()) {
            // 请求不合法，返回 Response.BAD_REQUEST
            Object data = req.getData();
            String msg;
            if (data == null) {
                msg = null;
            } else if (data instanceof Throwable) {
                msg = StringUtils.toString((Throwable) data);
            } else {
                msg = data.toString();
            }
            res.setErrorMessage("Fail to decode request due to: " + msg);
            res.setStatus(Response.BAD_REQUEST);
            channel.send(res);
            return;
        }
        // 获取 data，即 RpcInvocation 对象
        Object msg = req.getData();
        try {
            // 在 handler 中调用
            // CompletableFuture 实现了 CompletionStage 接口
            CompletionStage<Object> future = handler.reply(channel, msg);
            future.whenComplete((appResult, t) -> {
                // 回调任务
                try {
                    if (t == null) {
                        // 调用成功
                        res.setStatus(Response.OK);
                        res.setResult(appResult);
                    } else {
                        // 有错误
                        res.setStatus(Response.SERVICE_ERROR);
                        res.setErrorMessage(StringUtils.toString(t));
                    }
                    // 把消息发送回去
                    channel.send(res);
                } catch (RemotingException e) {
                    logger.warn("Send result to consumer failed, channel is " + channel + ", msg is " + e);
                }
            });
        } catch (Throwable e) {
            res.setStatus(Response.SERVICE_ERROR);
            res.setErrorMessage(StringUtils.toString(e));
            channel.send(res);
        }
    }
```

**ExchangeHandler.reply**

ExchangeHandler 的匿名实现类在 DubboProtocol 类中定义。此匿名类的 reply 函数用于执行最后的方法调用。

首先根据 ExchangeChannel 和 Invocation 获取 Invoker，然后调用 invoke 函数即可。获取 Invoker 的 getInvoker 方法在 DubboProtocol 中定义。

```java
        // 调用
        @Override
        public CompletableFuture<Object> reply(ExchangeChannel channel, Object message) throws RemotingException {
            // 如果不是 Invocation 类型的消息，抛出异常
            if (!(message instanceof Invocation)) {
                throw new RemotingException(channel, "Unsupported request: "
                        + (message == null ? null : (message.getClass().getName() + ": " + message))
                        + ", channel: consumer: " + channel.getRemoteAddress() + " --> provider: " + channel.getLocalAddress());
            }

            Invocation inv = (Invocation) message;
            // 获取 invoker 实例
            Invoker<?> invoker = getInvoker(channel, inv);
            // 如果是回调类型
            if (Boolean.TRUE.toString().equals(inv.getObjectAttachments().get(IS_CALLBACK_SERVICE_INVOKE))) {
                String methodsStr = invoker.getUrl().getParameters().get("methods");
                boolean hasMethod = false;
                if (methodsStr == null || !methodsStr.contains(",")) {
                    hasMethod = inv.getMethodName().equals(methodsStr);
                } else {
                    String[] methods = methodsStr.split(",");
                    for (String method : methods) {
                        if (inv.getMethodName().equals(method)) {
                            hasMethod = true;
                            break;
                        }
                    }
                }
                if (!hasMethod) {
                    logger.warn(new IllegalStateException("The methodName " + inv.getMethodName()
                            + " not found in callback service interface ,invoke will be ignored."
                            + " please update the api interface. url is:"
                            + invoker.getUrl()) + " ,invocation is :" + inv);
                    return null;
                }
            }
            RpcContext.getContext().setRemoteAddress(channel.getRemoteAddress());
            // invoker 调用
            Result result = invoker.invoke(inv);
            return result.thenApply(Function.identity());
        }
```

**DubboProtocol.getInvoker**

在 [服务暴露](https://github.com/Augustvic/DubboSourceCodeAnalysis/blob/master/md/3.md) 一节中已经描述了创造 Invoker 的流程。此时只需要根据 Channel 和 Invocation 构造 key，根据 key 在 exporterMap 中查找，如果没找到则抛出异常。

```java
    // 获取 Invoker
    Invoker<?> getInvoker(Channel channel, Invocation inv) throws RemotingException {
        boolean isCallBackServiceInvoke = false;
        boolean isStubServiceInvoke = false;
        int port = channel.getLocalAddress().getPort();
        String path = (String) inv.getObjectAttachments().get(PATH_KEY);

        // if it's callback service on client side
        isStubServiceInvoke = Boolean.TRUE.toString().equals(inv.getObjectAttachments().get(STUB_EVENT_KEY));
        if (isStubServiceInvoke) {
            port = channel.getRemoteAddress().getPort();
        }

        //callback
        isCallBackServiceInvoke = isClientSide(channel) && !isStubServiceInvoke;
        if (isCallBackServiceInvoke) {
            path += "." + inv.getObjectAttachments().get(CALLBACK_SERVICE_KEY);
            inv.getObjectAttachments().put(IS_CALLBACK_SERVICE_INVOKE, Boolean.TRUE.toString());
        }

        // 计算 service key，格式为 groupName/serviceName:serviceVersion:port。比如：
        //   dubbo/com.alibaba.dubbo.demo.DemoService:1.0.0:20880
        String serviceKey = serviceKey(
                port,
                path,
                (String) inv.getObjectAttachments().get(VERSION_KEY),
                (String) inv.getObjectAttachments().get(GROUP_KEY)
        );
        // 从 exporterMap 查找与 serviceKey 相对应的 DubboExporter 对象，
        // 服务导出过程中已经将 <serviceKey, DubboExporter> 映射关系存储到 exporterMap 集合中
        DubboExporter<?> exporter = (DubboExporter<?>) exporterMap.get(serviceKey);

        if (exporter == null) {
            throw new RemotingException(channel, "Not found exported service: " + serviceKey + " in " + exporterMap.keySet() + ", may be version or group mismatch " +
                    ", channel: consumer: " + channel.getRemoteAddress() + " --> provider: " + channel.getLocalAddress() + ", message:" + getInvocationWithoutData(inv));
        }
        // 返回 invoker
        return exporter.getInvoker();
    }
```

**doInvoke**

invoke 方法在 AbstractProxyInvoker 中实现，从源码找那个可以看到，执行调用的是 doInvoke 方法，返回的结果封装在 RpcResult 中返回。

```java
    // 调用
    @Override
    public Result invoke(Invocation invocation) throws RpcException {
        try {
            // doInvoke 方法中实现真正的调用，返回结果为 RpcResult
            // doInvoke 方法在子类中实现，在服务导出部分已经出现过了
            return new RpcResult(doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments()));
        } catch (InvocationTargetException e) {
            return new RpcResult(e.getTargetException());
        } catch (Throwable e) {
            throw new RpcException("Failed to invoke remote proxy method " + invocation.getMethodName() + " to " + getUrl() + ", cause: " + e.getMessage(), e);
        }
    }
```

服务提供端的 Invoker 是 AbstractProxyInvoker 实例，调用的 invoke 方法如下所示：

```java
    // 调用
    @Override
    public Result invoke(Invocation invocation) throws RpcException {
        try {
            // doInvoke 方法中实现真正的调用，返回结果为 RpcResult
            // doInvoke 方法在子类中实现，在服务导出部分（ JavassistProxyFactory.getInvoker）已经出现过了
            Object value = doInvoke(proxy, invocation.getMethodName(), invocation.getParameterTypes(), invocation.getArguments());
			// 把结果封装成 CompletableFuture 类型
            CompletableFuture<Object> future = wrapWithFuture(value);
            // 回调
            CompletableFuture<AppResponse> appResponseFuture = future.handle((obj, t) -> {
                AppResponse result = new AppResponse();
                if (t != null) {
                    // 发生了异常
                    if (t instanceof CompletionException) {
                        result.setException(t.getCause());
                    } else {
                        result.setException(t);
                    }
                } else {
                    // 没有发生异常，把结果保存下来
                    result.setValue(obj);
                }
                return result;
            });
            // 包装成 AsyncRpcResult 并返回
            return new AsyncRpcResult(appResponseFuture, invocation);
        } catch (InvocationTargetException e) {
            if (RpcContext.getContext().isAsyncStarted() && !RpcContext.getContext().stopAsync()) {
                logger.error("Provider async started, but got an exception from the original method, cannot write the exception back to consumer because an async result may have returned the new thread.", e);
            }
            return AsyncRpcResult.newDefaultAsyncResult(null, e.getTargetException(), invocation);
        } catch (Throwable e) {
            throw new RpcException("Failed to invoke remote proxy method " + invocation.getMethodName() + " to " + getUrl() + ", cause: " + e.getMessage(), e);
        }
    }
```

doInvoke 是一个抽象方法，在 JavassistProxyFactory 中实现：

```java
    // 生成 Invoker
    @Override
    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {
        // TODO Wrapper cannot handle this scenario correctly: the classname contains '$'
        // 为目标类创建 Wrapper，这里使用了代理模式
        // 如果目标类名字中不包含 '$'，对此目标类创建 Wrapper，否则，对接口创建 Wrapper
        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);
        // 创建继承自 AbstractProxyInvoker 类的匿名对象，重写 doInvoker 方法
        // 在 doInvoker 方法中调用需要运行的方法。
        return new AbstractProxyInvoker<T>(proxy, type, url) {
            @Override
            protected Object doInvoke(T proxy, String methodName,
                                      Class<?>[] parameterTypes,
                                      Object[] arguments) throws Throwable {
                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
            }
        };
    }
```

invoke 函数的返回值是 Result 类型，所以需要把 doInvoke 的结果包装成 Result 类型。先是包装成 CompletableFuture 类型，在 wrapWithFuture 中直接设置 CompletableFuture 的值为 value，然后调用 handle 函数把结果封装为 AppResponse 类型并存入 CompletableFuture 中，最后把 CompletableFuture 包装成 AsyncRpcResult 并返回。

## 9.4 提供者返回响应

前文说到服务提供者把 Response 通过 channel 的 send 方法发送给消费者。在发送出去之前，需要对消息进行编码。

编码的逻辑同样在 ExchangeCodec 和 DubboCodec 中实现。

**ExchangeCodec.encodeResponse**

先编码消息头 header，然后调用 encodeResponseData 方法序列化数据。encodeResponseData 方法在子类 DubboCodec 中实现。

```java
    // 对 Response 编码
    protected void encodeResponse(Channel channel, ChannelBuffer buffer, Response res) throws IOException {
        int savedWriteIndex = buffer.writerIndex();
        try {
            Serialization serialization = getSerialization(channel);
            // 消息头
            byte[] header = new byte[HEADER_LENGTH];
            // 魔数
            Bytes.short2bytes(MAGIC, header);
            // 序列化编号
            header[2] = serialization.getContentTypeId();
            if (res.isHeartbeat()) {
                header[2] |= FLAG_EVENT;
            }
            // 响应状态
            byte status = res.getStatus();
            header[3] = status;
            // 请求编号
            Bytes.long2bytes(res.getId(), header, 4);
            // 更新 writerIndex，为消息头预留 16 个字节的空间
            buffer.writerIndex(savedWriteIndex + HEADER_LENGTH);
            ChannelBufferOutputStream bos = new ChannelBufferOutputStream(buffer);
            ObjectOutput out = serialization.serialize(channel.getUrl(), bos);
            // 对返回的数据或返回的错误信息编码
            if (status == Response.OK) {
                if (res.isHeartbeat()) {
                    encodeEventData(channel, out, res.getResult());
                } else {
                    // 此方法在子类 DubboCodec 中实现
                    encodeResponseData(channel, out, res.getResult(), res.getVersion());
                }
            } else {
                // 写入异常信息
                out.writeUTF(res.getErrorMessage());
            }
            out.flushBuffer();
            if (out instanceof Cleanable) {
                ((Cleanable) out).cleanup();
            }
            bos.flush();
            bos.close();
            // 获取写入的字节数，即消息体的长度
            int len = bos.writtenBytes();
            checkPayload(channel, len);
            Bytes.int2bytes(len, header, 12);
            //  buffer 的 index 移到 savedWriteIndex 位置
            buffer.writerIndex(savedWriteIndex);
            // 写入消息头
            buffer.writeBytes(header); // write header.
            // 设置新的 writerIndex
            buffer.writerIndex(savedWriteIndex + HEADER_LENGTH + len);
        } catch (Throwable t) {
            // 把 writerIndex 移到原先的 savedWriteIndex，也就是把写入的消息头和数据清除
            buffer.writerIndex(savedWriteIndex);
            // 发送错误信息给消费者
            if (!res.isEvent() && res.getStatus() != Response.BAD_RESPONSE) {
            ...
        }
    }
```

**DubboCodec.encodeResponseData**

序列化服务调用返回的数据。

```java
    // 对 Reponse 的 data 部分进行编码
    @Override
    protected void encodeResponseData(Channel channel, ObjectOutput out, Object data, String version) throws IOException {
        Result result = (Result) data;
        // 检测当前协议版本是否支持带有 attachment 集合的 Response 对象
        boolean attach = Version.isSupportResponseAttachment(version);
        Throwable th = result.getException();
        // 没有异常
        if (th == null) {
            Object ret = result.getValue();
            // 调用结果为 null
            if (ret == null) {
                // 序列化响应类型
                out.writeByte(attach ? RESPONSE_NULL_VALUE_WITH_ATTACHMENTS : RESPONSE_NULL_VALUE);
            } else {
                // 调用结果非 null
                // 序列化响应类型
                out.writeByte(attach ? RESPONSE_VALUE_WITH_ATTACHMENTS : RESPONSE_VALUE);
                // 序列化调用结果
                out.writeObject(ret);
            }
        } else {
            // 有异常
            // 序列化响应类型
            out.writeByte(attach ? RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS : RESPONSE_WITH_EXCEPTION);
            // 序列化异常对象
            out.writeThrowable(th);
        }
        // 如果有 attachement
        if (attach) {
            // 记录 Dubbo 协议版本
            result.getObjectAttachments().put(DUBBO_VERSION_KEY, Version.getProtocolVersion());
            // 序列化 attachments 集合
            out.writeAttachments(result.getObjectAttachments());
        }
    }
```

## 9.5 消费者接收响应

消费者接收响应的过程和提供者接收请求的过程很相似，只是从 Request 变成了 Response。

第一步依然是编解码的过程，在 ExchangeCodec 和 DubboCodec 中进行。

**DubboCodec.decodeBody**

docodeBody 根据消息的类型（Request/Response）进行不同的处理。

返回的是 Response 对象。

```java
    // 重写 decodeBody
    @Override
    protected Object decodeBody(Channel channel, InputStream is, byte[] header) throws IOException {
        // 获取序列化器编号
        byte flag = header[2], proto = (byte) (flag & SERIALIZATION_MASK);
        // 获取调用编号
        long id = Bytes.bytes2long(header, 4);
        // 获取调用类型，如果调用类型是 response 类型的话
        if ((flag & FLAG_REQUEST) == 0) {
            // 对 response 类型的数据进行解码
            // 创建 Response 对象
            Response res = new Response(id);
            if ((flag & FLAG_EVENT) != 0) {
                res.setEvent(true);
            }
            // 获取状态
            byte status = header[3];
            // 设置状态
            res.setStatus(status);
            try {
                // 状态为 OK，说明响应正常
                if (status == Response.OK) {
                    Object data;
                    if (res.isEvent()) {
                        // 反序列化事件数据
                        ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);
                        data = decodeEventData(channel, in);
                    } else {
                        DecodeableRpcResult result;
                        // 判断是否在 IO 线程上执行解码
                        if (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) {
                            // 创建 DecodeableRpcResult 对象
                            result = new DecodeableRpcResult(channel, res, is,
                                    (Invocation) getRequestData(id), proto);
                            // 解码
                            result.decode();
                        } else {
                            // 只创建 DecodeableRpcResult 对象，不解码
                            result = new DecodeableRpcResult(channel, res,
                                    new UnsafeByteArrayInputStream(readMessageData(is)),
                                    (Invocation) getRequestData(id), proto);
                        }
                        data = result;
                    }
                    // 设置 DecodeableRpcResult 对象（即数据）到 Response 中
                    res.setResult(data);
                } else {
                    // 状态不 OK，设置错误信息
                    ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);
                    res.setErrorMessage(in.readUTF());
                }
            } catch (Throwable t) {
                // 解码过程中出现了错误，此时设置 CLIENT_ERROR 状态码到 Response 对象中
                if (log.isWarnEnabled()) {
                    log.warn("Decode response failed: " + t.getMessage(), t);
                }
                res.setStatus(Response.CLIENT_ERROR);
                res.setErrorMessage(StringUtils.toString(t));
            }
            return res;
        } else {
            // 对 request 数据进行解码
            // 创建 Request 对象
            Request req = new Request(id);
            // 设置版本，通信方式
            req.setVersion(Version.getProtocolVersion());
            req.setTwoWay((flag & FLAG_TWOWAY) != 0);
            if ((flag & FLAG_EVENT) != 0) {
                req.setEvent(true);
            }
            try {
                Object data;
                if (req.isEvent()) {
                    // 对事件数据进行解码
                    ObjectInput in = CodecSupport.deserialize(channel.getUrl(), is, proto);
                    data = decodeEventData(channel, in);
                } else {
                    DecodeableRpcInvocation inv;
                    // 根据 url 的参数判断是否在 IO 线程上解码
                    if (channel.getUrl().getParameter(DECODE_IN_IO_THREAD_KEY, DEFAULT_DECODE_IN_IO_THREAD)) {
                        inv = new DecodeableRpcInvocation(channel, req, is, proto);
                        // 在当前线程，也就是 IO 线程上解码。解码完成后，可将
                        // 调用方法名、attachment、以及调用参数解析出来
                        inv.decode();
                    } else {
                        // 创建 DecodeableRpcInvocation 对象，不在 IO 线程上解码
                        inv = new DecodeableRpcInvocation(channel, req,
                                new UnsafeByteArrayInputStream(readMessageData(is)), proto);
                    }
                    data = inv;
                }
                // 设置 data 到 request 中
                req.setData(data);
            } catch (Throwable t) {
                if (log.isWarnEnabled()) {
                    log.warn("Decode request failed: " + t.getMessage(), t);
                }
                // 若解码过程中出现异常，则将 broken 字段设为 true，
                // 并将异常对象设置到 Reqeust 对象中
                req.setBroken(true);
                req.setData(t);
            }
            return req;
        }
    }
```

**DecodeableRpcResult.decode**

在 DecodeableRpcResult 的 decode 方法中进行解码。

```java
    // 解码
    @Override
    public void decode() throws Exception {
        if (!hasDecoded && channel != null && inputStream != null) {
            // 如果还没有解码，开始解码
            try {
                decode(channel, inputStream);
            } catch (Throwable e) {
                if (log.isWarnEnabled()) {
                    log.warn("Decode rpc result failed: " + e.getMessage(), e);
                }
                response.setStatus(Response.CLIENT_ERROR);
                response.setErrorMessage(StringUtils.toString(e));
            } finally {
                // 设置已解码
                hasDecoded = true;
            }
        }
    }

    // 解码
    @Override
    public Object decode(Channel channel, InputStream input) throws IOException {
        if (log.isDebugEnabled()) {
            Thread thread = Thread.currentThread();
            log.debug("Decoding in thread -- [" + thread.getName() + "#" + thread.getId() + "]");
        }

        ObjectInput in = CodecSupport.getSerialization(channel.getUrl(), serializationType)
                .deserialize(channel.getUrl(), input);
        // 获取响应类型
        byte flag = in.readByte();
        switch (flag) {
            case DubboCodec.RESPONSE_NULL_VALUE:
                break;
            case DubboCodec.RESPONSE_VALUE:
                handleValue(in);
                break;
            case DubboCodec.RESPONSE_WITH_EXCEPTION:
                handleException(in);
                break;
            case DubboCodec.RESPONSE_NULL_VALUE_WITH_ATTACHMENTS:
                // 返回值为空，且携带了 attachements 集合
                handleAttachment(in);
                break;
            case DubboCodec.RESPONSE_VALUE_WITH_ATTACHMENTS:
                // 返回值不为空，且携带了 attachments 集合
                // 处理结果
                handleValue(in);
                // 处理附件
                handleAttachment(in);
                break;
            case DubboCodec.RESPONSE_WITH_EXCEPTION_WITH_ATTACHMENTS:
                // 异常对象不为空，且携带了 attachments 集合
                // 处理异常信息
                handleException(in);
                // 处理附件
                handleAttachment(in);
                break;
            default:
                throw new IOException("Unknown result flag, expect '0' '1' '2' '3' '4' '5', but received: " + flag);
        }
        if (in instanceof Cleanable) {
            ((Cleanable) in).cleanup();
        }
        return this;
    }
```

解码完成之后，需要将响应对象派发到线程池里。而线程池中的线程也不是用户线程，还需要将对象从线程池中的线程传递到用户线程中去。这一步骤完全依赖于请求 Request 的编号。

前文中提到，用户线程发送请求后，调用不同 DefaultFuture 对象的 get 方法进行等待。DefaultFuture 对象以键值对的方式存储在 FUTURES 集合中，键是请求 Request 的编号，值就是相应的 DefaultFuture 对象。

**HeaderExchangeHandler.received**

接收 Response。

```java
    @Override
    public void received(Channel channel, Object message) throws RemotingException {
        final ExchangeChannel exchangeChannel = HeaderExchangeChannel.getOrAddChannel(channel);
        if (message instanceof Request) {
            // 请求类型的对象
            Request request = (Request) message;
            if (request.isEvent()) {
                // 事件
                handlerEvent(channel, request);
            } else {
                if (request.isTwoWay()) {
                    // 双向通信
                    handleRequest(exchangeChannel, request);
                } else {
                    // 单向通信，只需要调用，没有结果
                    handler.received(exchangeChannel, request.getData());
                }
            }
        } else if (message instanceof Response) {
            // 响应类型的对象
            handleResponse(channel, (Response) message);
        } else if (message instanceof String) {
            // telnet 类型
            if (isClientSide(channel)) {
                Exception e = new Exception("Dubbo client can not supported string message: " + message + " in channel: " + channel + ", url: " + channel.getUrl());
                logger.error(e.getMessage(), e);
            } else {
                String echo = handler.telnet(channel, (String) message);
                if (echo != null && echo.length() > 0) {
                    channel.send(echo);
                }
            }
        } else {
            handler.received(exchangeChannel, message);
        }
    }
    
    // 处理响应
    static void handleResponse(Channel channel, Response response) throws RemotingException {
        if (response != null && !response.isHeartbeat()) {
            // DefaultFuture 接受响应数据
            DefaultFuture.received(channel, response);
        }
    }
```

**DefaultFuture.received**

查找 DefaultFuture，存入对应的结果。DefaultFuture 继承自 CompletableFuture，调用 complete 存入结果，此次服务调用结束。

```java
    // 接受相应数据
    public static void received(Channel channel, Response response) {
        received(channel, response, false);
    }
    
    // 接受响应数据
    public static void received(Channel channel, Response response, boolean timeout) {
        try {
            // 根据调用编号从 FUTURES 集合里查找指定的 DefaultFuture 并删除
            DefaultFuture future = FUTURES.remove(response.getId());
            if (future != null) {
                // 获取超时任务
                Timeout t = future.timeoutCheckTask;
                if (!timeout) {
                    // 没有超时
                    t.cancel();
                }
                // 继续向下调用
                future.doReceived(response);
            } else {
                logger.warn("The timeout response finally returned at "
                        + (new SimpleDateFormat("yyyy-MM-dd HH:mm:ss.SSS").format(new Date()))
                        + ", response " + response
                        + (channel == null ? "" : ", channel: " + channel.getLocalAddress()
                        + " -> " + channel.getRemoteAddress()));
            }
        } finally {
            CHANNELS.remove(response.getId());
        }
    }
    
    private void doReceived(Response res) {
        if (res == null) {
            throw new IllegalStateException("response cannot be null");
        }
        if (res.getStatus() == Response.OK) {
            // 顺利完成
            this.complete(res.getResult());
        } else if (res.getStatus() == Response.CLIENT_TIMEOUT || res.getStatus() == Response.SERVER_TIMEOUT) {
            // 客户端超时或者服务端超时
            this.completeExceptionally(new TimeoutException(res.getStatus() == Response.SERVER_TIMEOUT, channel, res.getErrorMessage()));
        } else {
            // 其他异常
            this.completeExceptionally(new RemotingException(channel, res.getErrorMessage()));
        }

        // 结果已经返回，但是调用者线程仍然在等待，为了避免无限期等待，通知调用者线程返回
        if (executor != null && executor instanceof ThreadlessExecutor) {
            ThreadlessExecutor threadlessExecutor = (ThreadlessExecutor) executor;
            if (threadlessExecutor.isWaiting()) {
                threadlessExecutor.notifyReturn(new IllegalStateException("The result has returned, but the biz thread is still waiting" +
                        " which is not an expected state, interrupt the thread manually by returning an exception."));
            }
        }
    }
```