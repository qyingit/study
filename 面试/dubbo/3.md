# 3. 服务暴露

服务暴露在服务端进行，客户端不存在服务暴露这一说法。

服务暴露的过程主要分成以下两个部分：

* 前置工作：
  - 检查 Provider 的配置参数；
  - 获取注册中心 URL；
* 导出服务：对于每一个协议，每一个注册中心，组装服务的 URL，然后执行导出服务的操作：
  - 创建 Invoker；
  - 执行 export，包括在注册中心注册服务和执行具体协议的 export 方法。以 Dubbo 协议为例，主要是创建 Exchanger 和 Transporter 服务端。创建 Transporter 的过程中包含了 Netty 服务端的启动。

服务暴露的流程可能还会涉及到元数据、通信客户端等内容，后面会对这些分支一笔带过，全文只有服务暴露的核心流程。

## 3.1 前置工作

### 3.1.1 检查配置

服务暴露的起点是 ServiceConfig 的 export 方法，此方法的源码如下所示：

```java
    public synchronized void export() {
        // 如果不应该暴露，则直接结束
        if (!shouldExport()) {
            return;
        }

        if (bootstrap == null) {
            bootstrap = DubboBootstrap.getInstance();
            bootstrap.init();
        }
        //检查并且更新配置
        checkAndUpdateSubConfigs();

        //初始化服务的元数据
        serviceMetadata.setVersion(version);
        serviceMetadata.setGroup(group);
        serviceMetadata.setDefaultGroup(group);
        serviceMetadata.setServiceType(getInterfaceClass());
        serviceMetadata.setServiceInterfaceName(getInterface());
        serviceMetadata.setTarget(getRef());

        if (shouldDelay()) {
            // 如果使用延迟加载，则延迟 delay 时间后暴露服务
            DELAY_EXPORT_EXECUTOR.schedule(this::doExport, getDelay(), TimeUnit.MILLISECONDS);
        } else {
            // 暴露服务
            doExport();
        }
        // 后续操作
        exported();
    }
    
    // 在 export 中调用
    protected synchronized void doExport() {
        // 已经取消了
        if (unexported) {
            throw new IllegalStateException("The service " + interfaceClass.getName() + " has already unexported!");
        }
        // 已经导出了
        if (exported) {
            return;
        }
        exported = true;
        // 如果 path 为空，则赋值接口名称
        if (StringUtils.isEmpty(path)) {
            path = interfaceName;
        }
        // 多协议多注册中心暴露服务
        doExportUrls();
    }
```

在 export/doExport 方法中主要进行各种检查，而配置检查最核心的方法是 checkAndUpdateSubConfigs，包括以下内容：

* 检查接口名是否合法、服务提供者的相关配置类如 ProviderConfig、ApplicationConfig 等是否存在；
* 检测并处理泛化服务和普通服务类
* 监测本地存根配置，并进行相应的处理
* 检测ApplicationConfig、RegistryConfig 等各种对象是否为空，为空则新建，或者抛出异常

```java
    private void checkAndUpdateSubConfigs() {
        // Use default configs defined explicitly with global scope
        // 用于检测 provider、application 等核心配置类对象是否为空，
        // 若为空，则尝试从其他配置类对象中获取相应的实例。
        completeCompoundConfigs();
        // 检测 provider 是否为空，为空则新建一个，并通过系统变量为其初始化
        checkDefault();
        // 检查 protocols 是否为空
        checkProtocol();
        // init some null configuration.
        List<ConfigInitializer> configInitializers = ExtensionLoader.getExtensionLoader(ConfigInitializer.class)
                .getActivateExtension(URL.valueOf("configInitializer://"), (String[]) null);
        configInitializers.forEach(e -> e.initServiceConfig(this));

        // 如果不是 injvm 协议，检查注册中心是否为空
        if (!isOnlyInJvm()) {
            checkRegistry();
        }
        this.refresh();

        // 服务名不能为空
        if (StringUtils.isEmpty(interfaceName)) {
            throw new IllegalStateException("<dubbo:service interface=\"\" /> interface not allow null!");
        }

        if (ref instanceof GenericService) {
            // 如果 ref 为泛化服务类型
            // 设置 interfaceClass 为 GenericService
            interfaceClass = GenericService.class;
            if (StringUtils.isEmpty(generic)) {
                // 设置 generic = true
                generic = Boolean.TRUE.toString();
            }
        } else {
            // 是普通的服务类型
            try {
                // 获得接口类型
                interfaceClass = Class.forName(interfaceName, true, Thread.currentThread()
                        .getContextClassLoader());
            } catch (ClassNotFoundException e) {
                throw new IllegalStateException(e.getMessage(), e);
            }
            // 对 interfaceClass，以及 <dubbo:method> 标签中的必要字段进行检查
            checkInterfaceAndMethods(interfaceClass, getMethods());
            // 对 ref 进行检测
            checkRef();
            // 设置 generic = false
            generic = Boolean.FALSE.toString();
        }
        
        ...
        
    }
```

### 3.1.2 加载注册中心

Dubbo 支持多种协议，也支持多个注册中心，可以同时在多个注册中心上注册发布。在 doExportUrls 中首先加载注册中心 URL，并遍历所有的协议，对每一个协议分别执行服务导出：

```java
    @SuppressWarnings({"unchecked", "rawtypes"})
    private void doExportUrls() {
        // 保存服务数据
        ServiceRepository repository = ApplicationModel.getServiceRepository();
        ServiceDescriptor serviceDescriptor = repository.registerService(getInterfaceClass());
        repository.registerProvider(
                getUniqueServiceName(),
                ref,
                serviceDescriptor,
                this,
                serviceMetadata
        );
        // 加载注册中心连接（Dubbo 支持多注册中心，所以可能不止一个）
        List<URL> registryURLs = ConfigValidationUtils.loadRegistries(this, true);
        // 遍历所有协议，并在每个协议下导出服务
        for (ProtocolConfig protocolConfig : protocols) {
            // 元数据处理
            String pathKey = URL.buildKey(getContextPath(protocolConfig)
                    .map(p -> p + "/" + path)
                    .orElse(path), group, version);
            repository.registerService(pathKey, interfaceClass);
            // TODO, uncomment this line once service key is unified
            serviceMetadata.setServiceKey(pathKey);
            // 对于每一个协议，对所有的注册中心都执行导出服务操作
            doExportUrlsFor1Protocol(protocolConfig, registryURLs);
        }
    }
```

loadRegistries 方法用于加载注册中心 URL，在后面针对每一个协议进行导出操作的时候会用到。

loadRegistries 方法主要包括以下步骤：

* 检测是否存在注册中心配置类 RegistryConfig
* 遍历所有的注册中心，构建参数的映射，即 Map。Map 只是中间变量。
* 根据 Map 构建注册中心链接列表（每一个注册中心可能有多个 地址，所以得到的是注册中心列表）。
* 遍历链接列表，并根据条件决定是否添加到需要返回的列表中

```java
    // 获取注册中心链接，用于服务注册
    public static List<URL> loadRegistries(AbstractInterfaceConfig interfaceConfig, boolean provider) {
        List<URL> registryList = new ArrayList<URL>();
        ApplicationConfig application = interfaceConfig.getApplication();
        // 注册中心列表
        List<RegistryConfig> registries = interfaceConfig.getRegistries();
        if (CollectionUtils.isNotEmpty(registries)) {
            // 遍历所有的注册中心
            for (RegistryConfig config : registries) {
                String address = config.getAddress();
                // 若地址为空，设置为 0.0.0.0
                if (StringUtils.isEmpty(address)) {
                    address = ANYHOST_VALUE;
                }
                if (!RegistryConfig.NO_AVAILABLE.equalsIgnoreCase(address)) {
                    // 如果获取到的 address 不等于 “N/A”，忽略大小写，继续后面流程
                    // 否则忽略这一个地址
                    Map<String, String> map = new HashMap<String, String>();
                    // 添加 ApplicationConfig 字段信息到 map 中（用于构建 URL）
                    AbstractConfig.appendParameters(map, application);
                    // 添加 RegistryConfig 字段信息到 map 中
                    AbstractConfig.appendParameters(map, config);
                    // 添加 path
                    map.put(PATH_KEY, RegistryService.class.getName());
                    // 添加运行时参数，包括协议版本、RELEASE、当前时间戳、PID
                    AbstractInterfaceConfig.appendRuntimeParameters(map);
                    if (!map.containsKey(PROTOCOL_KEY)) {
                        // 默认 dubbo 协议
                        map.put(PROTOCOL_KEY, DUBBO_PROTOCOL);
                    }
                    // 解析得到 URL 列表
                    // address 可能包含多个注册中心的 ip，所以得到的是 URL 列表
                    List<URL> urls = UrlUtils.parseURLs(address, map);

                    for (URL url : urls) {
                        url = URLBuilder.from(url)
                                .addParameter(REGISTRY_KEY, url.getProtocol())
                                // 将 URL 的协议头设置为 registry
                                .setProtocol(extractRegistryType(url))
                                .build();
                        // 如果是服务提供者，而且registry = true 或 null
                        // 不是提供者，而且 subscribe = true 或 null
                        // 满足以上两种情况之一，将 url 添加到 list 中
                        if ((provider && url.getParameter(REGISTER_KEY, true))
                                || (!provider && url.getParameter(SUBSCRIBE_KEY, true))) {
                            registryList.add(url);
                        }
                    }
                }
            }
        }
        return registryList;
    }
```

## 3.2 服务导出

需要传递到 doExportUrlsFor1Protocol 的参数是“协议”和“注册中心”，对于每一种协议和每一个注册中心，都需要执行服务导出操作。

参数 ProtocolConfig 是配置类，封装了服务提供者的协议配置，对应的是 <dubbo:protocol> 标签。参数 List<URL> 表示注册中心的 URL 列表。

> URL 是 Dubbo 配置的载体，通过 URL 可以让 Dubbo 的各种配置在各个模块中传递。

doExportUrlsFor1Protocol 方法是 ServiceConfig 中最长的方法，包含了服务导出的所有步骤。

此方法分为上下两个部分，上半部分是获取和组装服务的 URL，下半部分是服务导出的相关工作，例如创建 Invoker、开启通信服务端等。

### 3.2.1 获取服务 URL

```java    
        // 获取协议名
        String name = protocolConfig.getName();
        // 没有协议名，默认 dubbo 协议
        if (StringUtils.isEmpty(name)) {
            name = DUBBO;
        }
        Map<String, String> map = new HashMap<String, String>();
        // 标识此 map 为服务提供者
        map.put(SIDE_KEY, PROVIDER_SIDE);
        // 在 map 中添加运行时参数，包括协议版本、RELEASE、当前时间戳、PID
        ServiceConfig.appendRuntimeParameters(map);
        // 把 application/module/provider/protocol 等信息添加到 map 中
        AbstractConfig.appendParameters(map, getMetrics());
        AbstractConfig.appendParameters(map, getApplication());
        AbstractConfig.appendParameters(map, getModule());
        AbstractConfig.appendParameters(map, provider);
        AbstractConfig.appendParameters(map, protocolConfig);
        AbstractConfig.appendParameters(map, this);
        // 元数据处理
        MetadataReportConfig metadataReportConfig = getMetadataReportConfig();
        if (metadataReportConfig != null && metadataReportConfig.isValid()) {
            map.putIfAbsent(METADATA_KEY, REMOTE_METADATA_STORAGE_TYPE);
        }
        
        //省略后面的代码
```

上面的代码是把服务的各种基本信息先放到 Map 中，方便后面把 Map 转换成 URL。

接下来要做的是遍历此服务（接口）的方法和参数，这里涉及到两个标签，一个是 MethodConfig 对应的 <dubbo:method>，另一个是 ArgumentConfig 对应的 <dubbo:argument>。 <dubbo:argument> 是 <dubbo:method> 的子标签，所以这里涉及到两层循环，从代码中也可以看到 —— ArgumentConfig 的遍历循环在内层，MethodConfig 的遍历循环在外层。

这一段代码详细的流程如下：

```java
        // 省略前面的代码

        if (CollectionUtils.isNotEmpty(getMethods())) {
            // 遍历服务所有的方法
            for (MethodConfig method : getMethods()) {
                // 添加 MethodConfig 对象的字段信息到 map 中，键 = 方法名.属性名。
                // 比如存储 <dubbo:method name="sayHello" retries="2"> 对应的 MethodConfig，
                // 键 = sayHello.retries，map = {"sayHello.retries": 2, "xxx": "yyy"}
                AbstractConfig.appendParameters(map, method, method.getName());
                // 还需要处理 "retry" 属性
                String retryKey = method.getName() + ".retry";
                if (map.containsKey(retryKey)) {
                    String retryValue = map.remove(retryKey);
                    // 如果 retry 的值为 false，设置其次数为 0
                    if ("false".equals(retryValue)) {
                        map.put(method.getName() + ".retries", "0");
                    }
                }
                // 获取 ArgumentConfig 参数列表
                // 此处涉及到 <dubbo:method>  和 <dubbo:argument> 两个标签，<dubbo:argument> 是 <dubbo:method> 的子标签
                List<ArgumentConfig> arguments = method.getArguments();
                if (CollectionUtils.isNotEmpty(arguments)) {
                    // 遍历方法的参数
                    // 这一段是把方法参数的配置添加到 map 中
                    for (ArgumentConfig argument : arguments) {
                        // 参数类型
                        if (argument.getType() != null && argument.getType().length() > 0) {
                            // 获取接口的所有方法
                            Method[] methods = interfaceClass.getMethods();
                            if (methods.length > 0) {
                                // 遍历所有方法
                                for (int i = 0; i < methods.length; i++) {
                                    String methodName = methods[i].getName();
                                    // 找到的方法名和 method 的名字相等
                                    if (methodName.equals(method.getName())) {
                                        // 获取找到的方法的参数类型的数组
                                        Class<?>[] argtypes = methods[i].getParameterTypes();
                                        if (argument.getIndex() != -1) {
                                            // 检查 argtypes 的名称和 ArgumentConfig 中的 type 属性是否一致，
                                            // 如果一致，将 ArgumentConfig 字段信息添加到 map 中，
                                            // 否则抛出异常。
                                            if (argtypes[argument.getIndex()].getName().equals(argument.getType())) {
                                                AbstractConfig.appendParameters(map, argument, method.getName() + "." + argument.getIndex());
                                            } else {
                                                throw new IllegalArgumentException("Argument config error : the index attribute and type attribute not match :index :" + argument.getIndex() + ", type:" + argument.getType());
                                            }
                                        } else {
                                            // 遍历 argtypes
                                            for (int j = 0; j < argtypes.length; j++) {
                                                Class<?> argclazz = argtypes[j];
                                                // 由于没有设置 ArgumentConfig 的 index，一个一个试
                                                // 如果找到了和 ArgumentConfig 的 type 相同的参数，添加到 map 中
                                                if (argclazz.getName().equals(argument.getType())) {
                                                    AbstractConfig.appendParameters(map, argument, method.getName() + "." + j);
                                                    if (argument.getIndex() != -1 && argument.getIndex() != j) {
                                                        throw new IllegalArgumentException("Argument config error : the index attribute and type attribute not match :index :" + argument.getIndex() + ", type:" + argument.getType());
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        } else if (argument.getIndex() != -1) {
                            // 在 ArgumentConfig 中没有配置 type，但配置了 index
                            // 添加到 map 中
                            AbstractConfig.appendParameters(map, argument, method.getName() + "." + argument.getIndex());
                        } else {
                            throw new IllegalArgumentException("Argument config must set index or type attribute.eg: <dubbo:argument index='0' .../> or <dubbo:argument type=xxx .../>");
                        }
                    }
                }
            } // end of methods for
        }
```

最后把剩下的部分添加到 Map 中，例如接口版本号、provider 的地址、端口号等：

```java
        // 根据 generic 是否为 true 向 map 中添加不同的信息
        if (ProtocolUtils.isGeneric(generic)) {
            map.put(Constants.GENERIC_KEY, generic);
            map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);
        } else {
            // 获取接口版本号
            String revision = Version.getVersion(interfaceClass, version);
            if (revision != null && revision.length() > 0) {
                map.put("revision", revision);
            }

            // 获取方法集合
            String[] methods = Wrapper.getWrapper(interfaceClass).getMethodNames();
            // 接口中没有方法
            if (methods.length == 0) {
                logger.warn("NO method found in service interface " + interfaceClass.getName());
                map.put(Constants.METHODS_KEY, Constants.ANY_VALUE);
            } else {
                // 方法名之间用逗号隔开，然后作为 value 放入 map 中
                map.put(Constants.METHODS_KEY, StringUtils.join(new HashSet<String>(Arrays.asList(methods)), ","));
            }
        }
        // 添加 token 到 map 中
        if (!ConfigUtils.isEmpty(token)) {
            if (ConfigUtils.isDefault(token)) {
                // 随机生成
                map.put(Constants.TOKEN_KEY, UUID.randomUUID().toString());
            } else {
                map.put(Constants.TOKEN_KEY, token);
            }
        }
        // 判断协议名是否为 "injvm"
        if (Constants.LOCAL_PROTOCOL.equals(protocolConfig.getName())) {
            protocolConfig.setRegister(false);
            map.put("notify", "false");
        }
        // 获取上下文路径
        String contextPath = protocolConfig.getContextpath();
        if ((contextPath == null || contextPath.length() == 0) && provider != null) {
            contextPath = provider.getContextpath();
        }
        // 获取 host 和 port
        String host = this.findConfigedHosts(protocolConfig, registryURLs, map);
        Integer port = this.findConfigedPorts(protocolConfig, name, map);
        // 根据上面获取的参数和 map，构建 URL
        URL url = new URL(name, host, port, (contextPath == null || contextPath.length() == 0 ? "" : contextPath + "/") + path, map);

        // -------------------- 到此 URL 构建完成 ----------------------
        // 省略下面的代码
```

此函数进行到这里，URL 就构建完成了，接下来开始真正的服务导出工作。

## 3.2.2 服务导出

根据 URL 中的 scope 参数确定服务导出的方式：

* scope = none，不导出服务
* scope == local，导出到本地
* scope == remote，导出到远程

```java
        // 接上一个函数，省略上面的代码
        // ---------------- 下面开始服务导出（暴露）-------------------

        // 开始服务暴露
        // 加载 ConfiguratorFactory，生成 Configurator 实例，判断是否有该协议的实现存在
        if (ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)
                .hasExtension(url.getProtocol())) {
            // 通过协议的实例配置 URL
            url = ExtensionLoader.getExtensionLoader(ConfiguratorFactory.class)
                    .getExtension(url.getProtocol()).getConfigurator(url).configure(url);
        }

        // 根据 URL 的 scope 参数决定服务导出的方式
        // scope = none，不导出服务
        // scope == remote，导出到本地
        // scope == local，导出到远程
        String scope = url.getParameter(SCOPE_KEY);
        if (!SCOPE_NONE.equalsIgnoreCase(scope)) {
            // scope 不为 none，可以导出服务
            if (!SCOPE_REMOTE.equalsIgnoreCase(scope)) {
                // 导出到本地
                exportLocal(url);
            }
            if (!SCOPE_LOCAL.equalsIgnoreCase(scope)) {
                // 导出到远程
                if (CollectionUtils.isNotEmpty(registryURLs)) {
                    // 有注册中心，对于每一个注册中心，都要导出服务
                    // 遍历所有注册中心
                    for (URL registryURL : registryURLs) {
                        // 如果协议类型是 injvm，不注册
                        if (LOCAL_PROTOCOL.equalsIgnoreCase(url.getProtocol())) {
                            continue;
                        }
                        // 添加 dynamic 配置
                        url = url.addParameterIfAbsent(DYNAMIC_KEY, registryURL.getParameter(DYNAMIC_KEY));
                        // 加载监视器链接
                        // 监控中心会用到标签 <dubbo:monitor>
                        URL monitorUrl = ConfigValidationUtils.loadMonitor(this, registryURL);
                        if (monitorUrl != null) {
                            // 把监视器链接添加到 url 里
                            url = url.addParameterAndEncoded(MONITOR_KEY, monitorUrl.toFullString());
                        }
                        if (logger.isInfoEnabled()) {
                            if (url.getParameter(REGISTER_KEY, true)) {
                                logger.info("Register dubbo service " + interfaceClass.getName() + " url " + url + " to registry " + registryURL);
                            } else {
                                logger.info("Export dubbo service " + interfaceClass.getName() + " to url " + url);
                            }
                        }
                        // 获取代理方式
                        String proxy = url.getParameter(PROXY_KEY);
                        if (StringUtils.isNotEmpty(proxy)) {
                            // 将代理方式添加到注册中心的 URL 中
                            registryURL = registryURL.addParameter(PROXY_KEY, proxy);
                        }
                        // 为服务提供类（ref）生成 Invoker
                        Invoker<?> invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, registryURL.addParameterAndEncoded(EXPORT_KEY, url.toFullString()));
                        // DelegateProviderMetaDataInvoker 用于持有 Invoker 和 ServiceConfig
                        DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);
                        // 导出服务，并生成 Exporter
                        // 这里的 PROTOCOL 是自适应扩展点，其具体实现是 wrapperInvoker 里 URL 的 protocol 参数指定的类，即 registry
                        Exporter<?> exporter = PROTOCOL.export(wrapperInvoker);
                        exporters.add(exporter);
                    }
                } else {
                    // 没有注册中心，提示导出到 url，url 表示服务的 url，也就是直连方式
                    if (logger.isInfoEnabled()) {
                        logger.info("Export dubbo service " + interfaceClass.getName() + " to url " + url);
                    }
                    // 仅仅导出服务（添加到 exporters 中）
                    Invoker<?> invoker = PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, url);
                    DelegateProviderMetaDataInvoker wrapperInvoker = new DelegateProviderMetaDataInvoker(invoker, this);
                    // 生成 exporter
                    Exporter<?> exporter = PROTOCOL.export(wrapperInvoker);
                    exporters.add(exporter);
                }
                /**
                 * @since 2.7.0
                 * ServiceData Store
                 */
                WritableMetadataService metadataService = WritableMetadataService.getExtension(url.getParameter(METADATA_KEY, DEFAULT_METADATA_STORAGE_TYPE));
                if (metadataService != null) {
                    metadataService.publishServiceDefinition(url);
                }
            }
        }
        this.urls.add(url);
    }
```

到这里 doExportUrlsFor1Protocol 的全部内容都结束了，但是最后一部分 “服务导出” 里面调用了很多函数，下面将对它们一一说明。

把服务导出到本地的方法是 exportLocal，将会调用 InjvmProtocol 的 export 方法，在 InjvmProtocol.export 方法中创建一个 InjvmExporter 后直接返回，导出过程到此结束。

```java
    @SuppressWarnings({"unchecked", "rawtypes"})
    /**
     * 导出服务到本地
     */
    private void exportLocal(URL url) {
        URL local = URLBuilder.from(url)
                .setProtocol(LOCAL_PROTOCOL)    // 设置协议头为 injvm
                .setHost(LOCALHOST_VALUE)    // 设置地址 127.0.0.1
                .setPort(0)    // 设置端口
                .build();
        // 创建 Invoker，并导出服务，这里的 protocol 会在运行时调用 InjvmProtocol 的 export 方法
        Exporter<?> exporter = PROTOCOL.export(
                PROXY_FACTORY.getInvoker(ref, (Class) interfaceClass, local));
        exporters.add(exporter);
        logger.info("Export dubbo service " + interfaceClass.getName() + " to local registry url : " + local);
    }
```

把服务导出到远程又可分为有注册中心和没有注册中心两种情况，第二种情况通常只用于测试，在这里重点考虑第一种情况。

对于每一个注册中心（URL），都要执行服务导出。每一个服务导出的流程包括以下两个部分：

* 创建 Invoker。服务端不包括任何集群容错或负载均衡的逻辑，所以这里的 Invoker 是最底层的 Invoker，调用 Invoker.invoke 方法直接就是执行服务中对应的方法。生成 invoker 最核心的部分是生成包装类（Wrapper）。
* 生成 Exporter。这一部分包括在注册中心注册服务和创建服务端实例（Exchanger 和 Transporter）。

> Transporter 包含在 Exchanger 里面，Transporter 在 Dubbo 框架中要比 Exchanger 更底层。Transporter 封装了通讯框架的各种抽象和包装，例如 Netty 中的 Channel、ChannelHandler 等。

**创建 Invoker（Wrapper）**

在远程导出中，Invoker 由 ProxyFactory 调用 getInvoker 方法产生，默认的 ProxyFactory 实现类是 JavassistProxyFactory。

> Invoker 是实体域，它是 Dubbo 的核心模型，其它模型都向它靠扰，或转换成它，它代表一个可执行体，可向它发起 invoke 调用。Invoker 有很多子类，它有可能是一个本地的实现，也可能是一个远程的实现，也可能一个集群实现。

```java
    // 生成 Invoker
    @Override
    public <T> Invoker<T> getInvoker(T proxy, Class<T> type, URL url) {
        // TODO Wrapper cannot handle this scenario correctly: the classname contains '$'
        // 为目标类创建 Wrapper，这里使用了代理模式
        // 如果目标类名字中不包含 '$'，对此目标类创建 Wrapper，否则，对接口创建 Wrapper
        final Wrapper wrapper = Wrapper.getWrapper(proxy.getClass().getName().indexOf('$') < 0 ? proxy.getClass() : type);
        // 创建继承自 AbstractProxyInvoker 类的匿名对象，重写 doInvoker 方法
        // 在 doInvoker 方法中调用需要运行的方法。
        return new AbstractProxyInvoker<T>(proxy, type, url) {
            @Override
            protected Object doInvoke(T proxy, String methodName,
                                      Class<?>[] parameterTypes,
                                      Object[] arguments) throws Throwable {
                return wrapper.invokeMethod(proxy, methodName, parameterTypes, arguments);
            }
        };
    }
```

首先需要注意的一点是，这里（服务端）的 Invoker 继承自 AbstractProxyInvoker，且 doInvoke 方法的实现非常简单，就只是调用 Wrapper 的 invokeMethod。

Wrapper 类是包装类（和客户端的代理类类似），调用 Wrapper.getWrapper 生成包装类的对象。

在分析 Wrapper.getWrapper 的源码之前，先对此方法进行测试。

首先构建一个测试类 Hello 如下所示：

```java
package com.alibaba.dubbo.common.bytecode;

public class Hello {

    private String name = "August";

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public void hello(String name)  {
        System.out.println("hello " + name);
    }
}
```

在 Wrapper.getWrapper 方法中生成的 Wrapper 类的代码如下所示（已经格式化）：

```java
package com.alibaba.dubbo.common.bytecode;

public class Wrapper0 {
    public static String[] pns;
    public static java.util.Map pts;
    public static String[] mns;
    public static String[] dmns;
    public static Class[] mts0;
    public static Class[] mts1;
    public static Class[] mts2;

    public String[] getPropertyNames() {
        return pns;
    }

    public boolean hasProperty(String n) {
        return pts.containsKey(n);
    }

    public Class getPropertyType(String n) {
        return (Class) pts.get(n);
    }

    public String[] getMethodNames() {
        return mns;
    }

    public String[] getDeclaredMethodNames() {
        return dmns;
    }

    public void setPropertyValue(Object o, String n, Object v) {
        com.alibaba.dubbo.common.bytecode.Hello w;
        try {
            w = ((com.alibaba.dubbo.common.bytecode.Hello) $1);
        } catch (Throwable e) {
            throw new IllegalArgumentException(e);
        }
        if ($2.equals("name")) {
            w.setName((java.lang.String) $3);
            return;
        }
        throw new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException("Not found property \"" + $2 + "\" filed or setter method in class com.alibaba.dubbo.common.bytecode.Hello.");
    }

    public Object getPropertyValue(Object o, String n) {
        com.alibaba.dubbo.common.bytecode.Hello w;
        try {
            w = ((com.alibaba.dubbo.common.bytecode.Hello) $1);
        } catch (Throwable e) {
            throw new IllegalArgumentException(e);
        }
        if ($2.equals("name")) {
            return ($w) w.getName();
        }
        throw new com.alibaba.dubbo.common.bytecode.NoSuchPropertyException("Not found property \"" + $2 + "\" filed or setter method in class com.alibaba.dubbo.common.bytecode.Hello.");
    }

    public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws java.lang.reflect.InvocationTargetException {
        com.alibaba.dubbo.common.bytecode.Hello w;
        try {
            w = ((com.alibaba.dubbo.common.bytecode.Hello) $1);
        } catch (Throwable e) {
            throw new IllegalArgumentException(e);
        }
        try {
            if ("getName".equals($2) && $3.length == 0) {
                return ($w) w.getName();
            }
            if ("setName".equals($2) && $3.length == 1) {
                w.setName((java.lang.String) $4[0]);
                return null;
            }
            if ("hello".equals($2) && $3.length == 1) {
                w.hello((java.lang.String) $4[0]);
                return null;
            }
        } catch (Throwable e) {
            throw new java.lang.reflect.InvocationTargetException(e);
        }
        throw new com.alibaba.dubbo.common.bytecode.NoSuchMethodException("Not found method \"" + $2 + "\" in class com.alibaba.dubbo.common.bytecode.Hello.");
    }
}
```

可以看到，Wrapper 类定义了常用的获取类信息的一些方法，可以通过 Wrapper 对实例对象进行赋值取值以及调用指定方法等。

> Wrapper 包装器的思想应用很广泛，除了 Dubbo 的 Wrapper，在 Spring 中对 Bean 的操作也是通过 BeanWrapper 这个包装器进行的。

创建 Wrapper 类和 [创建自适应扩展点](https://github.com/Augustvic/DubboSourceCodeAnalysis/blob/master/md/2.md) 的方法十分类似，都需要自己生成代码，然后编译成 class 文件。

在 Wrapper.geWrapper 方法中，首先尝试从缓存中获取，如果缓存中没有，调用 makeWrapper 方法创建 Wrapper 类，并存入缓存。

```java
    /**
     * 获取类 c 对应的 Wrapper 实例
     *
     * @param c Class instance.
     * @return Wrapper instance(not null).
     */
    public static Wrapper getWrapper(Class<?> c) {
        while (ClassGenerator.isDynamicClass(c)) // can not wrapper on dynamic class.
        {
            // 返回该对象的超类
            c = c.getSuperclass();
        }
        // Object 类的 Wrapper 是固定的
        if (c == Object.class) {
            return OBJECT_WRAPPER;
        }
        // 如果缓存中存在直接获取
        // 如果缓存中不存在，通过 makeWrapper 创造包装类，并存入缓存中
        return WRAPPER_MAP.computeIfAbsent(c, key -> makeWrapper(key));
    }
```

下面的源码注释已经完整地解释了 makeWrapper 中创建包装类的过程。对于用户定义的每一个服务，创造出来的 Wrapper 都是一样的结构，都包含 7 个静态变量和 8 个成员函数。

所有成员函数中最重要的是 invokeMethod，在前面提到的 AbstractProxyInvoker.doInvoke 中调用这个方法来调用消费者指定的服务。

```java
    // 对指定类创建代理（包装类）
    private static Wrapper makeWrapper(Class<?> c) {
        // 如果 c 是基本类型，抛出异常
        if (c.isPrimitive()) {
            throw new IllegalArgumentException("Can not create wrapper for primitive type: " + c);
        }

        String name = c.getName();
        ClassLoader cl = ClassUtils.getClassLoader(c);
        // setPropertyValue 方法的代码
        StringBuilder c1 = new StringBuilder("public void setPropertyValue(Object o, String n, Object v){ ");
        // getPropertyValue 方法的代码
        StringBuilder c2 = new StringBuilder("public Object getPropertyValue(Object o, String n){ ");
        // invokeMethod 方法的代码
        StringBuilder c3 = new StringBuilder("public Object invokeMethod(Object o, String n, Class[] p, Object[] v) throws " + InvocationTargetException.class.getName() + "{ ");
        // try-catch 捕捉异常代码
        // DemoService w; try { w = ((DemoServcie) $1); }}catch(Throwable e){ throw new IllegalArgumentException(e); }
        c1.append(name).append(" w; try{ w = ((").append(name).append(")$1); }catch(Throwable e){ throw new IllegalArgumentException(e); }");
        c2.append(name).append(" w; try{ w = ((").append(name).append(")$1); }catch(Throwable e){ throw new IllegalArgumentException(e); }");
        c3.append(name).append(" w; try{ w = ((").append(name).append(")$1); }catch(Throwable e){ throw new IllegalArgumentException(e); }");
        // pts 存储成员变量名和类型
        Map<String, Class<?>> pts = new HashMap<>(); // <property name, property types>
        // ms 存储方法描述信息和 Method 实例
        Map<String, Method> ms = new LinkedHashMap<>(); // <method desc, Method instance>
        // mns 方法名列表
        List<String> mns = new ArrayList<>(); // method names.
        // dmns 方法名的代码
        List<String> dmns = new ArrayList<>(); // declaring method names.

        // 获取所有的 public 字段，为所有字段生成条件判断语句
        for (Field f : c.getFields()) {
            String fn = f.getName();
            Class<?> ft = f.getType();
            // 忽略 static 和 transient
            if (Modifier.isStatic(f.getModifiers()) || Modifier.isTransient(f.getModifiers())) {
                continue;
            }
            // 生成条件判断及赋值语句，比如：
            // if( $2.equals("name") ) { w.name = (java.lang.String) $3; return;}
            // if( $2.equals("age") ) { w.age = ((Number) $3).intValue(); return;}
            c1.append(" if( $2.equals(\"").append(fn).append("\") ){ w.").append(fn).append("=").append(arg(ft, "$3")).append("; return; }");
            // 生成条件判断及返回语句，比如：
            // if( $2.equals("name") ) { return ($w)w.name; }
            c2.append(" if( $2.equals(\"").append(fn).append("\") ){ return ($w)w.").append(fn).append("; }");
            // 将<字段名，字段类型>存入 pts 中
            pts.put(fn, ft);
        }
        // 获取所有方法
        Method[] methods = c.getMethods();
        // 如果 methods 中有除了 Object 类成员之外的方法，返回 true
        boolean hasMethod = hasMethods(methods);
        if (hasMethod) {
            c3.append(" try{");
            for (Method m : methods) {
                // 忽略 Object 的方法
                if (m.getDeclaringClass() == Object.class) {
                    continue;
                }

                String mn = m.getName();
                // 生成方法名判断语句，例如：
                // if ( "sayHello".equals( $2 )
                c3.append(" if( \"").append(mn).append("\".equals( $2 ) ");
                int len = m.getParameterTypes().length;
                // 生成“运行时传入的参数数量与方法参数列表长度”判断语句，比如：
                //  && $3.length == 2
                c3.append(" && ").append(" $3.length == ").append(len);

                boolean override = false;
                for (Method m2 : methods) {
                    // 检查方法是否有重载，条件为：方法对象不同，方法名相同
                    if (m != m2 && m.getName().equals(m2.getName())) {
                        override = true;
                        break;
                    }
                }
                // 存在重载（注意是重载不是重写），如：
                //    1. void sayHello(Integer, String)
                //    2. void sayHello(Integer, Integer)
                // 方法名相同，参数列表长度也相同，因此不能仅通过这两项判断两个方法是否相等。
                // 需要进一步判断方法的参数类型
                if (override) {
                    if (len > 0) {
                        for (int l = 0; l < len; l++) {
                            // 生成参数类型进行检测代码，比如：
                            // && $3[0].getName().equals("java.lang.Integer")
                            //    && $3[1].getName().equals("java.lang.String")
                            c3.append(" && ").append(" $3[").append(l).append("].getName().equals(\"")
                                    .append(m.getParameterTypes()[l].getName()).append("\")");
                        }
                    }
                }

                // 添加 ) {，完成方法判断语句，此时生成的代码可能如下（已格式化）：
                // if ("sayHello".equals($2)
                //     && $3.length == 2
                //     && $3[0].getName().equals("java.lang.Integer")
                //     && $3[1].getName().equals("java.lang.String")) {
                c3.append(" ) { ");
                // 根据返回值生成目标方法调用语句
                if (m.getReturnType() == Void.TYPE) {
                    // w.sayHello((java.lang.Integer)$4[0], (java.lang.String)$4[1]); return null;
                    c3.append(" w.").append(mn).append('(').append(args(m.getParameterTypes(), "$4")).append(");").append(" return null;");
                } else {
                    // return w.sayHello((java.lang.Integer)$4[0], (java.lang.String)$4[1]);
                    c3.append(" return ($w)w.").append(mn).append('(').append(args(m.getParameterTypes(), "$4")).append(");");
                }
                // 添加 }, 生成的代码形如（已格式化）：
                // if ("sayHello".equals($2)
                //     && $3.length == 2
                //     && $3[0].getName().equals("java.lang.Integer")
                //     && $3[1].getName().equals("java.lang.String")) {
                //
                //     w.sayHello((java.lang.Integer)$4[0], (java.lang.String)$4[1]);
                //     return null;
                // }
                c3.append(" }");
                // 添加方法名到 mns 集合中
                mns.add(mn);
                // 如果当前方法在 c 中被声明，将当前方法名添加到 dmns 中
                if (m.getDeclaringClass() == c) {
                    dmns.add(mn);
                }
                ms.put(ReflectUtils.getDesc(m), m);
            }
            // 添加捕捉异常语句
            c3.append(" } catch(Throwable e) { ");
            c3.append("     throw new java.lang.reflect.InvocationTargetException(e); ");
            c3.append(" }");
        }
        // 添加 NoSuchMethodException 异常抛出代码
        c3.append(" throw new " + NoSuchMethodException.class.getName() + "(\"Not found method \\\"\"+$2+\"\\\" in class " + c.getName() + ".\"); }");

        // 处理 get/set 方法
        Matcher matcher;
        // 遍历所有方法
        for (Map.Entry<String, Method> entry : ms.entrySet()) {
            String md = entry.getKey();
            Method method = entry.getValue();
            // 匹配以 get 开头的方法
            if ((matcher = ReflectUtils.GETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) {
                // 获取属性名
                String pn = propertyName(matcher.group(1));
                // 生成属性判断及返回语句
                // if( $2.equals("name") ) { return ($w).w.getName(); }
                c2.append(" if( $2.equals(\"").append(pn).append("\") ){ return ($w)w.").append(method.getName()).append("(); }");
                pts.put(pn, method.getReturnType());
            } else if ((matcher = ReflectUtils.IS_HAS_CAN_METHOD_DESC_PATTERN.matcher(md)).matches()) {
                // 匹配以 is/has/can 开头的方法
                String pn = propertyName(matcher.group(1));
                // 生成属性判断以及返回语句，示例如下：
                // if( $2.equals("dream") ) { return ($w).w.hasDream(); }
                c2.append(" if( $2.equals(\"").append(pn).append("\") ){ return ($w)w.").append(method.getName()).append("(); }");
                pts.put(pn, method.getReturnType());
            } else if ((matcher = ReflectUtils.SETTER_METHOD_DESC_PATTERN.matcher(md)).matches()) {
                // 匹配以 set 开头的方法
                Class<?> pt = method.getParameterTypes()[0];
                String pn = propertyName(matcher.group(1));
                // 生成属性判断以及 setter 调用语句，示例如下：
                // if( $2.equals("name") ) { w.setName((java.lang.String)$3); return; }
                c1.append(" if( $2.equals(\"").append(pn).append("\") ){ w.").append(method.getName()).append("(").append(arg(pt, "$3")).append("); return; }");
                pts.put(pn, pt);
            }
        }
        // 添加 NoSuchPropertyException 异常抛出代码
        c1.append(" throw new " + NoSuchPropertyException.class.getName() + "(\"Not found property \\\"\"+$2+\"\\\" field or setter method in class " + c.getName() + ".\"); }");
        c2.append(" throw new " + NoSuchPropertyException.class.getName() + "(\"Not found property \\\"\"+$2+\"\\\" field or setter method in class " + c.getName() + ".\"); }");

        // make class
        long id = WRAPPER_CLASS_COUNTER.getAndIncrement();
        // 创建类生成器
        ClassGenerator cc = ClassGenerator.newInstance(cl);
        // 设置类名，设置父类
        cc.setClassName((Modifier.isPublic(c.getModifiers()) ? Wrapper.class.getName() : c.getName() + "$sw") + id);
        cc.setSuperClass(Wrapper.class);
        // 添加默认构造方法
        cc.addDefaultConstructor();
        // 添加各种字段
        cc.addField("public static String[] pns;"); // property name array.
        cc.addField("public static " + Map.class.getName() + " pts;"); // property type map.
        cc.addField("public static String[] mns;"); // all method name array.
        cc.addField("public static String[] dmns;"); // declared method name array.
        for (int i = 0, len = ms.size(); i < len; i++) {
            cc.addField("public static Class[] mts" + i + ";");
        }
        // 添加各种方法
        cc.addMethod("public String[] getPropertyNames(){ return pns; }");
        cc.addMethod("public boolean hasProperty(String n){ return pts.containsKey($1); }");
        cc.addMethod("public Class getPropertyType(String n){ return (Class)pts.get($1); }");
        cc.addMethod("public String[] getMethodNames(){ return mns; }");
        cc.addMethod("public String[] getDeclaredMethodNames(){ return dmns; }");
        cc.addMethod(c1.toString());
        cc.addMethod(c2.toString());
        cc.addMethod(c3.toString());

        try {
            // 生成类
            Class<?> wc = cc.toClass();
            // 设置字段的值
            wc.getField("pts").set(null, pts);
            wc.getField("pns").set(null, pts.keySet().toArray(new String[0]));
            wc.getField("mns").set(null, mns.toArray(new String[0]));
            wc.getField("dmns").set(null, dmns.toArray(new String[0]));
            int ix = 0;
            for (Method m : ms.values()) {
                wc.getField("mts" + ix++).set(null, m.getParameterTypes());
            }
            // 返回 Wrapper 实例
            return (Wrapper) wc.newInstance();
        } catch (RuntimeException e) {
            throw e;
        } catch (Throwable e) {
            throw new RuntimeException(e.getMessage(), e);
        } finally {
            cc.release();
            ms.clear();
            mns.clear();
            dmns.clear();
        }
    }
```

**生成 Exporter**

首先要明确的是，导出到远程的 export 函数，是在 RegistryProtocol 而不是任何具体的协议中实现的。也就是说 ServiceConfig 中的自适应扩展点 PROTOCOL 指的就是 RegistryProtocol。

在 RegistryProtocol 中实现的 export 方法包括在注册中心注册服务和创建服务端实例两个过程，其中c创建服务端实例在指定协议的 export 方法里执行（默认的协议是 Dubbo，即 DubboProtocol.export）。

RegistryProtocol.export 源码如下：

```java
   // 导出服务
    @Override
    public <T> Exporter<T> export(final Invoker<T> originInvoker) throws RpcException {
        // 获取注册中心 URL
        URL registryUrl = getRegistryUrl(originInvoker);
        // provider 的 URL，即本地服务提供者的配置
        URL providerUrl = getProviderUrl(originInvoker);

        // Subscribe the override data
        // FIXME When the provider subscribes, it will affect the scene : a certain JVM exposes the service and call
        //  the same service. Because the subscribed is cached key with the name of the service, it causes the
        //  subscription information to cover.
        // 获取订阅 URL，比如：
        // provider://172.17.48.52:20880/com.alibaba.dubbo.demo.DemoService?category=configurators&check=false&anyhost=true&application=demo-provider&dubbo=2.0.2&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello
        final URL overrideSubscribeUrl = getSubscribedOverrideUrl(providerUrl);
        // 创建监听器
        final OverrideListener overrideSubscribeListener = new OverrideListener(overrideSubscribeUrl, originInvoker);
        // 监听器放入缓存
        overrideListeners.put(overrideSubscribeUrl, overrideSubscribeListener);

        providerUrl = overrideUrlWithConfig(providerUrl, overrideSubscribeListener);
        // 导出服务（从具体的协议）
        final ExporterChangeableWrapper<T> exporter = doLocalExport(originInvoker, providerUrl);

        // 获取注册中心的实例
        final Registry registry = getRegistry(originInvoker);
        // 获取注册的服务提供者的 URL，比如：
        // dubbo://127.0.0.0:20880/com.alibaba.dubbo.demo.DemoService?anyhost=true&application=demo-provider&dubbo=2.0.2&generic=false&interface=com.alibaba.dubbo.demo.DemoService&methods=sayHello
        final URL registeredProviderUrl = getUrlToRegistry(providerUrl, registryUrl);
        //获取 “registry” 参数的值
        boolean register = providerUrl.getParameter(REGISTER_KEY, true);
        // 根据 registry 的值确定是否向注册中心注册服务
        if (register) {
            // 向注册中心注册服务
            register(registryUrl, registeredProviderUrl);
        }

        // Deprecated! Subscribe to override rules in 2.6.x or before.
        // 向注册中心订阅 override 数据
        registry.subscribe(overrideSubscribeUrl, overrideSubscribeListener);

        exporter.setRegisterUrl(registeredProviderUrl);
        exporter.setSubscribeUrl(overrideSubscribeUrl);

        notifyExport(exporter);
        // 创建并返回 DestroyableExporter
        return new DestroyableExporter<>(exporter);
    }
```

上面的代码中主要有以下几个步骤：

* 调用 doLocalExport 暴露服务
* 在注册中心注册服务
* 向注册中心订阅 override 数据
* 创建并返回 DestroyableExporter

doLocalExport 是 RegistryProtocol 类中的方法，在此方法中根据运行时协议，加载对应的类，调用协议的 export 方法。

```java
    // 根据运行时协议，加载对应的类
    @SuppressWarnings("unchecked")
    private <T> ExporterChangeableWrapper<T> doLocalExport(final Invoker<T> originInvoker, URL providerUrl) {
        String key = getCacheKey(originInvoker);
        // 如果缓存中没有，创造 Invoker 委托对象，并调用具体协议的 export 方法导出服务
        // 并存入缓存
        return (ExporterChangeableWrapper<T>) bounds.computeIfAbsent(key, s -> {
            Invoker<?> invokerDelegate = new InvokerDelegate<>(originInvoker, providerUrl);
            // 这里的 protocol 依然是自适应扩展点
            return new ExporterChangeableWrapper<>((Exporter<T>) protocol.export(invokerDelegate), originInvoker);
        });
    }
```

下文中以 Dubbo 协议为例。

DubboProtocol 中的 export 方法主要分成两个步骤：创建 DubboExporter 和开启服务器。由于 invoker 已经创建完成，创建 DubboExporter 仅仅是封装了一下，比较简单。开启服务器的操作主要是在 openServer 方法中进行。

```java
    // 服务暴露
    @Override
    public <T> Exporter<T> export(Invoker<T> invoker) throws RpcException {
        URL url = invoker.getUrl();

        // 获取服务标识，理解成服务坐标也行。由服务组名，服务名，服务版本号以及端口组成。比如：
        // demoGroup/com.alibaba.dubbo.demo.DemoService:1.0.1:20880
        String key = serviceKey(url);
        // 创建 DubboExpoter
        DubboExporter<T> exporter = new DubboExporter<T>(invoker, key, exporterMap);
        // 放入缓存
        exporterMap.put(key, exporter);

        //export an stub service for dispatching event
        Boolean isStubSupportEvent = url.getParameter(STUB_EVENT_KEY, DEFAULT_STUB_EVENT);
        Boolean isCallbackservice = url.getParameter(IS_CALLBACK_SERVICE, false);
        // 如果是本地存根而不是回调服务
        if (isStubSupportEvent && !isCallbackservice) {
            String stubServiceMethods = url.getParameter(STUB_EVENT_METHODS_KEY);
            if (stubServiceMethods == null || stubServiceMethods.length() == 0) {
                if (logger.isWarnEnabled()) {
                    logger.warn(new IllegalStateException("consumer [" + url.getParameter(INTERFACE_KEY) +
                            "], has set stubproxy support event ,but no stub methods founded."));
                }
            }
        }
        // 启动服务器
        openServer(url);
        // 序列化
        optimizeSerialization(url);
        return exporter;
    }
```

在同一个机器同一个端口上只允许启动一个服务器实例，在 openServer 方法中首先检查缓存中是否已经存在服务器实例，如果缓存中已经存在，就不用创建了，否则创建一个 ExchangeServer 并放入缓存中。

```java
    // 启动服务器
    private void openServer(URL url) {
        // 获取服务器地址，即 host:port，将其作为服务器实例的 key，用于标识当前的服务器实例
        String key = url.getAddress();
        // 客户端是否可以导出仅供服务器调用的服务
        boolean isServer = url.getParameter(IS_SERVER_KEY, true);
        if (isServer) {
            // 访问缓存，获取信息交换服务器 ExchangeServer
            ProtocolServer server = serverMap.get(key);
            if (server == null) {
                // 没找到，创造一个
                // 并且将 key-server 键值对放入里面
                synchronized (this) {
                    server = serverMap.get(key);
                    if (server == null) {
                        serverMap.put(key, createServer(url));
                    }
                }
            } else {
                // 重置 URL
                server.reset(url);
            }
        }
    }
```

调用 createServer 创建服务器实例（ExchangeServer），分成以下三个步骤：
* 检测是否存在 server 参数所代表的 Transporter 扩展点，不存在则抛出异常。
* 创建 ExchangeServer 实例。
* 检测是否支持 client 参数所表示的 Transporter 扩展点，不存在也是抛出异常。

```java
    // 创造 ProtocolServer 实例
    private ProtocolServer createServer(URL url) {
        url = URLBuilder.from(url)
                // 服务器关闭时发送 readonly 时间，默认启用
                .addParameterIfAbsent(CHANNEL_READONLYEVENT_SENT_KEY, Boolean.TRUE.toString())
                // 添加心跳监测配置，默认启用，时间间隔为 1 分钟
                .addParameterIfAbsent(HEARTBEAT_KEY, String.valueOf(DEFAULT_HEARTBEAT))
                // 编解码方式
                .addParameter(CODEC_KEY, DubboCodec.NAME)
                .build();
        // 获取远程通讯服务端实现方式，默认 netty
        String str = url.getParameter(SERVER_KEY, DEFAULT_REMOTING_SERVER);
        // 通过 SPI 监测 Transporter 接口的扩展中，是否有 netty，没有则抛出异常
        if (str != null && str.length() > 0 && !ExtensionLoader.getExtensionLoader(Transporter.class).hasExtension(str)) {
            throw new RpcException("Unsupported server type: " + str + ", url: " + url);
        }

        ExchangeServer server;
        try {
            // 创建 ExchangeServer
            server = Exchangers.bind(url, requestHandler);
        } catch (RemotingException e) {
            throw new RpcException("Fail to start server(url: " + url + ") " + e.getMessage(), e);
        }
        // 获取客户端设置的远程通信方式
        str = url.getParameter(CLIENT_KEY);
        if (str != null && str.length() > 0) {
            // 获取所有 Transport 实现类名称集合
            Set<String> supportedTypes = ExtensionLoader.getExtensionLoader(Transporter.class).getSupportedExtensions();
            // 当前 Dubbo 支持的通信方式里是否有客户端指定的 Transport，不包含抛出异常
            if (!supportedTypes.contains(str)) {
                throw new RpcException("Unsupported client type: " + str);
            }
        }
        return new DubboProtocolServer(server);
    }
```

创建 Exchanger 的操作在 Exchangers.bind 中进行。默认创建 HeaderExchangeServer 服务器。

```java
    // Exchangers
    // 创建 ExchangeServer
    // bind 意思是“绑定”
    public static ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {
        if (url == null) {
            throw new IllegalArgumentException("url == null");
        }
        if (handler == null) {
            throw new IllegalArgumentException("handler == null");
        }
        url = url.addParameterIfAbsent(Constants.CODEC_KEY, "exchange");
        // 获取 Exchanger 的扩展点，默认为 HeaderExchanger
        // 调用 HeaderExchanger 的 bind 方法创建 ExchangerServer
        return getExchanger(url).bind(url, handler);
    }
    
    // 获取 Exchanger 的扩展点
    public static Exchanger getExchanger(URL url) {
        // 如果没有 exchanger 参数，默认 header
        String type = url.getParameter(Constants.EXCHANGER_KEY, Constants.DEFAULT_EXCHANGER);
        return getExchanger(type);
    }

    // 获取 Exchanger 的 type 扩展点
    public static Exchanger getExchanger(String type) {
        return ExtensionLoader.getExtensionLoader(Exchanger.class).getExtension(type);
    }
    
    // 创建 HeaderExchangeServer
    @Override
    public ExchangeServer bind(URL url, ExchangeHandler handler) throws RemotingException {
        // 调用 Transporters 的 bind 方法，Transporter 可以看成通讯层
        return new HeaderExchangeServer(Transporters.bind(url, new DecodeHandler(new HeaderExchangeHandler(handler))));
    }
```

创建 HeaderExchangeServer 的核心在于创建 RemotingServer，通过调用 Transporters.bind 实现。

这里面也没有什么复杂的逻辑。getTransporter 在运行时动态创建 TransporterAdaptive，根据传入的参数确定 Transporter 的类型，默认为 NettyTransport。

然后调用 NettyTransport.bind 方法创建 NettyServer。NettyServer 是 Netty 的服务端实例。

NettyServer 的启动过程和原理在 [Dubbo 协议与通信过程](https://github.com/Augustvic/DubboSourceCodeAnalysis/blob/master/md/dubbo/12.md) 中有更详细的说明。

```java
    // 创建 RemotingServer
    public static RemotingServer bind(URL url, ChannelHandler... handlers) throws RemotingException {
        if (url == null) {
            throw new IllegalArgumentException("url == null");
        }
        if (handlers == null || handlers.length == 0) {
            throw new IllegalArgumentException("handlers == null");
        }
        ChannelHandler handler;
        if (handlers.length == 1) {
            handler = handlers[0];
        } else {
            // 如果 handlers 的元素数量大于 1，则创建 ChannelHandlers 分发器
            handler = new ChannelHandlerDispatcher(handlers);
        }
        // 获取自适应 Transporter 实例，默认 netty
        // 调用实例的 bind 方法
        return getTransporter().bind(url, handler);
    }
    
    // 创造 NettyServer
    @Override
    public RemotingServer bind(URL url, ChannelHandler listener) throws RemotingException {
        return new NettyServer(url, listener);
    }
```

NettyServer 的构造函数中调用了父类 AbstractServer 的构造函数，而父类的构造函数中又调用了 NettyServer 的 doOpen。

Netty 服务端启动的核心流程在 doOpen 中。

```java    
    // NettyServer
    public NettyServer(URL url, ChannelHandler handler) throws RemotingException {
        super(ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME), ChannelHandlers.wrap(handler, url));
    }
    
    // AbstractServer
    // NettyServer 的父类
    public AbstractServer(URL url, ChannelHandler handler) throws RemotingException {
        super(url, handler);
        localAddress = getUrl().toInetSocketAddress();
        // 获取 ip
        String bindIp = getUrl().getParameter(Constants.BIND_IP_KEY, getUrl().getHost());
        // 获取端口
        int bindPort = getUrl().getParameter(Constants.BIND_PORT_KEY, getUrl().getPort());
        // 如果 url 中配置 anyhost 为 true 或者判断 host 为不可用的本地 host
        if (url.getParameter(ANYHOST_KEY, false) || NetUtils.isInvalidLocalHost(bindIp)) {
            // 设置 ip 为 0.0.0.0
            bindIp = ANYHOST_VALUE;
        }
        bindAddress = new InetSocketAddress(bindIp, bindPort);
        // 从 URL 中获取最大可接受连接数，默认为 0
        this.accepts = url.getParameter(ACCEPTS_KEY, DEFAULT_ACCEPTS);
        // 从 URL 中获取空闲超时时间，默认为 600s
        this.idleTimeout = url.getParameter(IDLE_TIMEOUT_KEY, DEFAULT_IDLE_TIMEOUT);
        try {
            // 开启服务器
            doOpen();
            if (logger.isInfoEnabled()) {
                logger.info("Start " + getClass().getSimpleName() + " bind " + getBindAddress() + ", export " + getLocalAddress());
            }
        } catch (Throwable t) {
            throw new RemotingException(url.toInetSocketAddress(), null, "Failed to bind " + getClass().getSimpleName()
                    + " on " + getLocalAddress() + ", cause: " + t.getMessage(), t);
        }
        // 创造线程池
        executor = executorRepository.createExecutorIfAbsent(url);
    }
    
    /**
     * 用于开启服务器
     */
    @Override
    protected void doOpen() throws Throwable {
        bootstrap = new ServerBootstrap();

        // boss 线程组
        bossGroup = NettyEventLoopFactory.eventLoopGroup(1, "NettyServerBoss");
        // worker 线程组
        workerGroup = NettyEventLoopFactory.eventLoopGroup(
                getUrl().getPositiveParameter(IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),
                "NettyServerWorker");

        // 服务端事件处理
        final NettyServerHandler nettyServerHandler = new NettyServerHandler(getUrl(), this);
        // 所有的通道集合
        channels = nettyServerHandler.getChannels();

        bootstrap.group(bossGroup, workerGroup)
                .channel(NettyEventLoopFactory.serverSocketChannelClass())
                .option(ChannelOption.SO_REUSEADDR, Boolean.TRUE)
                .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)
                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)
                .childHandler(new ChannelInitializer<SocketChannel>() {
                    @Override
                    protected void initChannel(SocketChannel ch) throws Exception {
                        // FIXME: should we use getTimeout()?
                        int idleTimeout = UrlUtils.getIdleTimeout(getUrl());
                        NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this);
                        if (getUrl().getParameter(SSL_ENABLED_KEY, false)) {
                            ch.pipeline().addLast("negotiation",
                                    SslHandlerInitializer.sslServerHandler(getUrl(), nettyServerHandler));
                        }
                        ch.pipeline()
                                // 解码器和编码器
                                .addLast("decoder", adapter.getDecoder())
                                .addLast("encoder", adapter.getEncoder())
                                .addLast("server-idle-handler", new IdleStateHandler(0, 0, idleTimeout, MILLISECONDS))
                                // 服务端事件处理
                                .addLast("handler", nettyServerHandler);
                    }
                });
        // 连接
        ChannelFuture channelFuture = bootstrap.bind(getBindAddress());
        channelFuture.syncUninterruptibly();
        channel = channelFuture.channel();
    }
```

回到 RegistryProtocol.export 方法，创建服务端实例过后，接下来调用 registry 方法向注册中心注册服务：

```java
    // 向注册中心注册
    public void register(URL registryUrl, URL registeredProviderUrl) {
        // 获取 Registry 注册中心实例
        Registry registry = registryFactory.getRegistry(registryUrl);
        // 注册服务
        registry.register(registeredProviderUrl);
        ProviderModel model = ApplicationModel.getProviderModel(registeredProviderUrl.getServiceKey());
        model.addStatedUrl(new ProviderModel.RegisterStatedURL(
                registeredProviderUrl,
                registryUrl,
                true
        ));
    }
```

首先创建 Registry 注册中心实例，然后调用其 register 方法注册服务。

getRegistry 方法在 AbstractRegistryFactory 中，说明所有的注册中心都是通过这个方法获取注册中心示例的。（其实这个方法也没什么逻辑，只是检查了缓存，然后调用子类中的 createRegistry 方法创建，而不同的注册中心有不同的 RegistryFactory 实现。）

```java
    // 获取注册中心实例
    @Override
    public Registry getRegistry(URL url) {
        if (destroyed.get()) {
            LOGGER.warn("All registry instances have been destroyed, failed to fetch any instance. " +
                    "Usually, this means no need to try to do unnecessary redundant resource clearance, all registries has been taken care of.");
            return DEFAULT_NOP_REGISTRY;
        }

        url = URLBuilder.from(url)
                .setPath(RegistryService.class.getName())
                .addParameter(INTERFACE_KEY, RegistryService.class.getName())
                .removeParameters(EXPORT_KEY, REFER_KEY)
                .build();
        // 生成 key
        String key = createRegistryCacheKey(url);
        // 保证只有一个注册中心（Registry）实例
        LOCK.lock();
        try {
            // 从缓存获取
            Registry registry = REGISTRIES.get(key);
            if (registry != null) {
                return registry;
            }
            // 缓存没有，创建注册中心实例
            registry = createRegistry(url);
            if (registry == null) {
                throw new IllegalStateException("Can not create registry " + url);
            }
            REGISTRIES.put(key, registry);
            return registry;
        } finally {
            // Release the lock
            LOCK.unlock();
        }
    }
```

createRegistry 方法用于创造注册中心实例：

```java
    // ZookeeperRegistryFactory
    // 创建 Zookeeper 注册中心实例
    @Override
    public Registry createRegistry(URL url) {
        return new ZookeeperRegistry(url, zookeeperTransporter);
    }
    
    
    // Zookeeper 注册中心实例
    public ZookeeperRegistry(URL url, ZookeeperTransporter zookeeperTransporter) {
        super(url);
        if (url.isAnyHost()) {
            throw new IllegalStateException("registry address == null");
        }
        // 获取组名，默认为 dubbo
        String group = url.getParameter(GROUP_KEY, DEFAULT_ROOT);
        if (!group.startsWith(PATH_SEPARATOR)) {
            group = PATH_SEPARATOR + group;
        }
        this.root = group;
        // 创建 Zookeeper 客户端，默认为 CuratorZookeeperTransporter
        zkClient = zookeeperTransporter.connect(url);
        // 添加状态监听器
        zkClient.addStateListener((state) -> {
            if (state == StateListener.RECONNECTED) {
                logger.warn("Trying to fetch the latest urls, in case there're provider changes during connection loss.\n" +
                        " Since ephemeral ZNode will not get deleted for a connection lose, " +
                        "there's no need to re-register url of this instance.");
                ZookeeperRegistry.this.fetchLatestAddresses();
            } else if (state == StateListener.NEW_SESSION_CREATED) {
                logger.warn("Trying to re-register urls and re-subscribe listeners of this instance to registry...");
                try {
                    ZookeeperRegistry.this.recover();
                } catch (Exception e) {
                    logger.error(e.getMessage(), e);
                }
            } else if (state == StateListener.SESSION_LOST) {
                logger.warn("Url of this instance will be deleted from registry soon. " +
                        "Dubbo client will try to re-register once a new session is created.");
            } else if (state == StateListener.SUSPENDED) {

            } else if (state == StateListener.CONNECTED) {
            }
        });
    }
```

创建了注册中心实例后，调用 registry 方法完成服务注册。

ZookeeperRegistry 继承自 FailbackRegistry，registry 方法在 FailbackRegistry 中实现。

所谓的服务注册，本质上是将服务配置数据写入到 Zookeeper 的某个路径的节点下。例如 com.alibaba.dubbo.demo.DemoService 这个服务对应的配置信息（存储在 URL 中）最终会被注册到 /dubbo/com.alibaba.dubbo.demo.DemoService/providers/ 节点下。

核心方法是 doRegister。

```java
    // 向注册中心注册
    public void register(URL registryUrl, URL registeredProviderUrl) {
        // 获取 Registry 注册中心实例
        Registry registry = registryFactory.getRegistry(registryUrl);
        // 注册服务
        registry.register(registeredProviderUrl);
        ProviderModel model = ApplicationModel.getProviderModel(registeredProviderUrl.getServiceKey());
        model.addStatedUrl(new ProviderModel.RegisterStatedURL(
                registeredProviderUrl,
                registryUrl,
                true
        ));
    }
    
    @Override
    public void register(URL url) {
        if (!acceptable(url)) {
            logger.info("URL " + url + " will not be registered to Registry. Registry " + url + " does not accept service of this protocol type.");
            return;
        }
        super.register(url);
        // 从失败的缓存中删除该 URL
        removeFailedRegistered(url);
        removeFailedUnregistered(url);
        try {
            // 向注册中心发送注册请求
            doRegister(url);
        } catch (Exception e) {
            Throwable t = e;

            // 如果开启了启动时检测，直接抛出异常
            boolean check = getUrl().getParameter(Constants.CHECK_KEY, true)
                    && url.getParameter(Constants.CHECK_KEY, true)
                    && !CONSUMER_PROTOCOL.equals(url.getProtocol());
            boolean skipFailback = t instanceof SkipFailbackWrapperException;
            if (check || skipFailback) {
                if (skipFailback) {
                    t = t.getCause();
                }
                throw new IllegalStateException("Failed to register " + url + " to registry " + getUrl().getAddress() + ", cause: " + t.getMessage(), t);
            } else {
                logger.error("Failed to register " + url + ", waiting for retry, cause: " + t.getMessage(), t);
            }

            // 把注册失败的 URL 放入缓存，并且定时重试。
            addFailedRegistered(url);
        }
    }
```

## 3.3 参考

* [Dubbo 官网](http://dubbo.apache.org/zh-cn/docs/source_code_guide/export-service.html)
* [Dubbo源码解析（四十四）服务暴露过程](https://segmentfault.com/a/1190000018953699)
* [Dubbo原理和源码解析之服务暴露](https://github.com/cyfonly/dubbo-read/wiki/Service_Exposure)



