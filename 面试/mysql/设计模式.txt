前言：关于设计模式，在框架中用的比较多。在平常接触最为频繁的估计是单例模式了，因此笔者在此对设计模式相关知识点进行总结。

1.设计模式的种类
总体来说，设计模式分为3大类总共23种：

1）创建型模式，共5种

工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

2）结构型模式，共7种

适配器模式、装饰器模式、外观模式、桥接模式、组合模式、享元模式。

3）行为型模式，共11种

策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

上述23种设计模式都是建立在面向对象的基础上，因此没有常见的生产者/消费者模式（面向过程）。

参考：

http://www.cnblogs.com/xrq730/p/4896125.html

http://blog.chinaunix.net/uid-29140694-id-4107880.html

2.简单工厂模式
简单工厂模式的通俗理解：在一个键盘上，敲下‘K’键，对应生成‘K’的对象，依次类推。相当于一个有按钮的黑盒子，需要什么，直接按下对应的按钮即可。

简单工厂模式由一个工厂对象决定生产出哪一种产品类的实例。

参考：

http://www.cnblogs.com/xrq730/p/4902597.html

3.工厂方法模式
工厂方法模式是对简单工厂模式的进一步抽象，它将实际创建的动作交给子类。

使用工厂方法模式的系统涉及到以下角色：

1）抽象工厂角色

担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。

注：总的工厂接口，让具体工厂角色进行实现

2）具体工厂角色

担任这个角色的是实现了工厂接口的具体Java类，具体工厂角色与业务密切相关，并且随着使用者的调用以创建导出类。

注：具体实现类，实现总的工厂接口，内部进行具体类的实现

3）抽象产品角色

工厂方法模式所创建的对象的超类。

注：具体动作接口，声明在总工厂接口中

4）具体产品角色

这个角色实现了抽象导出角色所声明的接口，工厂方法模式所创建的每一个对象都是某个具体角色导出角色的实例。

注：实现抽象导出角色，用于工厂子类的具体实现



注：图片来源于百度百科：工厂方法模式

从图中可以清晰的知道：Creator=>抽象工厂角色；BulbCreator和TubeCreator=>具体工厂角色；Light=>抽象产品角色；BulbLight和TubeLight=>具体产品角色。

参考：

http://www.cnblogs.com/xrq730/p/4905578.html

http://www.cnblogs.com/ytaozhao/p/3389883.html

4.抽象工厂模式
抽象工厂就是对一组具有相同主题的工厂进行封装。

优点：

1）抽象工厂模式隔离了具体类的生产，使得客户并不需要知道什么被创建。

2）当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。

3）增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则”。

缺点：

增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性。

参考：

https://www.cnblogs.com/chenpi/p/5156801.html

http://www.cnblogs.com/ytaozhao/p/3392149.html

5.策略模式
策略模式个人理解就是将不同的策略通过不同的子类实现进行封装，在调用时，需明确具体使用的具体策略，然后进行不同行为的反应。

策略模式是对算法的包装，是把使用算法的责任和算法本身分开。策略模式通常是把一系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。

策略模式涉及到三个角色：

1）环境角色

持有一个策略Strategy的引用。

2）抽象策略角色

这是一个抽象角色，通常由一个接口或抽象类实现，此角色给出所有具体策略类所需的接口。

3）具体策略角色

包装了相关算法或行为。

参考：

http://www.cnblogs.com/xrq730/p/4906313.html

6.适配器模式
适配器模式：可以把一个类的接口变换成客户端所期待的另一种接口，使得原本因接口不匹配而无法在一起工作的两个类可以一起工作。

通俗理解：适配器模式就相当于一个中间件，加上一层转换后，就可以正常工作了。

适配器分类适配器和对象适配器。

适配器模式的优缺点

优点

1）有更好的复用性。系统需要使用现有的类，但此类接口不符合系统需要，通过适配器模式让这些功能得到很好的复用。

2）有更好的扩展性。实现适配器，可以调用自己开发的功能。

缺点

过多使用适配器会使得系统非常凌乱，明明调用的是A接口，内部却被适配成了B接口。因此除非必要，不推荐使用适配器，而是直接对系统重构。

参考：

http://www.cnblogs.com/xrq730/p/4906487.html

7.迭代器模式
迭代器模式又叫做游标（Cursor）模式，其作用是提供一种方法访问一个容器元素中的各个对象，而又不暴露该对象的内部细节。

参考：

http://www.cnblogs.com/xrq730/p/4907184.html

8.代理模式
代理模式的定义：给某一对象提供一个代理对象，并由代理对象控制对原对象的引用。

通俗理解：房东通过中介进行卖房，中介就相当于一个代理。

代理模式分静态代理和动态代理两种。

参考：

http://www.cnblogs.com/xrq730/p/4907999.html

9.观察者模式
观察者模式也叫作发布-订阅模式，也就是事件监听机制。观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态上发生变化时，会通知所有观察者对象，使他们能够自动更新自己。

观察者模式所涉及的角色有：

1）抽象主题角色

抽象主题角色把所有对观察者对象的引用保存在一个集合中，每个主题都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象，并具有通知观察者的功能。

2）具体主题角色

将有关状态存入具体观察者对象，在具体主题的内部状态改变时，给所有登记过的观察者发出通知。

3）抽象观察者角色

为所有的具体观察者提供一个接口，在得到主题通知时更新自己

4）具体观察者角色

存储与主题的状态相关的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态协调

参考：

http://www.cnblogs.com/xrq730/p/4908686.html

10.外观模式
外观模式是对象的结构模式，外部与一个子系统的通信必须通过一个统一的外观对象进行。

通俗理解外观模式就是：比如到超市买东西，原来都是自己去找，然后付钱。现在通过一个中间人，全程代替我买东西，然后把东西交给我即可。

外观模式涉及的角色：

1）外观角色

客户端调用这个角色的方法。此角色知晓相关的子系统的功能和责任，正常情况下，本角色会将所有从客户端发来的请求委派到响应的子系统中。

2）子系统角色

可以同时有一个或多个子系统，每个子系统都不是一个单独的类，而是一个类的集合。每个子系统都可以被客户端直接调用，或者被外观角色直接调用。子系统并不知道外观角色的存在，对于子系统而言，外观仅仅是另外一个客户端而已。

参观：

http://www.cnblogs.com/xrq730/p/4908822.html

11.装饰器模式
装饰器模式又称为包装（Wrapper）模式。装饰器模式以多客户端透明的方式扩展对象的功能，是继承关系的一个替代方案。

装饰器模式的通俗理解：比如一面墙，将它进行装修，加上挂钩、灯等东西，使其功能更加强大。

装饰器模式中的角色有：

1）抽象构件角色

给出一个抽象接口，以规范准备接受附加责任的对象。

2）具体构件角色

定义一个将要接受附加责任的类。

3）装饰角色

持有一个构建对象的实例，并定义一个与抽象构件接口一致的接口。

4）具体装饰角色

负责给构建对象贴上附加的责任。

参考：

http://www.cnblogs.com/xrq730/p/4908940.html

