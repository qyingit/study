springcloud
          微服务的核心:
                    将传统一站式的应用，根据业务拆分成一个个服务,彻底的去耦合，每一个微服务,提供单个业务功能的服务,从技术角度就是一种小儿独立的处理过程，类似于进程,能够独立的启动与销毁，拥有自己独立的数据库。
         微服务与为服务架构:
                    强调服务的大小,关注于某个点，是解决某一个问题对应服务的一个服务应用。
         微服务架构:
	一种架构模式,提倡将单一的应用程序划分为一组小的服务,服务之间相互调用，互相配合，为用户提供最终价值,每个服务在独立的进程之中,服务之间通过轻量的通信机制互相协作(http)。每个服务能够独立的部署到生产环境,类生产环境，另外，应该避免统一的,集中式服务管理机制，对一个具体服务而言，应该根据业务的上下文，选择合适的工具,语言进行构建

          优点:
                 1.解耦，高内聚低耦合,聚焦业务
                 2.开发简单,效率高，一个服务干一件事
                 3.能被小团队单独开发，这个小团队在2到5人之间
                 4.微服务是松耦合的，具有功能意义，无论在开发还是部署阶段都是独立的
                 5.能构使用不同的语言开发
                 6.微服务只是业务逻辑的代码,不会和html,css或者其它的组建混合
                 7.每个服务可以有自己的存储能力,可以有自己的数据库,也可以有统一的数据库
          缺点:
                 1.开发人员要处理分布式系统的复杂性
                 2.多服务运维难度，随着服务的增加,运维的压力增大
                 3.系统部署依赖
                 4.服务的通信成本上升
                 5.数据的一致性
                 6.系统的集成测试困难
                 7.性能监控

        springboot与springcloud的区别
              boot用于快速构建应用,cloud用于将各个boot组合起来，构建成一个系统级的应用，提供对外服务的能力

springcloud版本Dalston  boot版本1.5.9

技术栈:
注册中心:Eureka、Consul、Zookeeper等
eureak
分别客户端与服务端
server
服务端存储可用节点的信息,服务节点的信息可以在界面中直接观察到
client
客户端内置round-robin负载算法均衡器，在应用启动过后，会向eureka Server发送心跳，如果
Eureka Server在多个心跳周期没有接收到某个节点的心跳,Eureka会将这个节点一处


Eureka是ap原则  zookeeper是cp原则
zk会当master因为网络故障失去联系的时候哦，会导致剩余的节点进行重新选举，问题在于选举的时间太长，30~120s,期间zookeeper是不可用的,如果这期间会导致注册服务瘫痪可能会影响用户的使用

eureka的设计是保证可用性
各个节点是平等的，如果客户端发现eureka的某个服务端不可以用,会使用负载均衡的算法，请求其它server端保证可用性,如果15分钟之内超过85%的节点没有心跳,，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：
1. Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务
2. Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其它节点上(即保证当前节点依然可用)
3. 当网络稳定时，当前实例新的注册信息会被同步到其它节点中


服务调用:
Rest、RPC、gRPC

服务熔断器:
Hystrix、Envoy等
服务的雪崩效应：
当微服务中得某个服务down掉后，系统其它的服务还是会调用down掉的服务，当其没有响应的时候会大量的占用系统的资源,引起所谓的雪崩效应
占用的资源包括(系统延迟，备份队列，线程)这时候就需要对故障和延迟进行隔离与管理，不能应为单个服务的失败就导致整个系统不可以用

服务熔断:
       熔断机制是应对雪崩效应的微服务链路保护机制
       当链路不可用,或者响应的时间太长，会进行服务降级，熔断该微服务的调用,快速响应错误信息,当检测到服务恢复后进行恢复,当失败的阈值在5s内20次失败的调用就会启动熔断机制
       当服务调用失败,可以使用服务容错,调用command注解里面的fallbackmethod方法
       服务降级使用 FallbackFactory在客户端去实现

       服务熔断有两种：
                              支持超时      支持熔断    隔离原理               是否异步调用      资源消耗
              信号量      支持            支持     服务单独调用线程池     都可以             线程切换，机器负载
              线程池      不支持         支持          通过信号量             不支持异步       少，只是计数器

负载均衡:
Ribbon、Nginx等
nginx属于集中式LB,在服务消费方和提供方之间使用独立的LB设施,由该设施将访问请求,通过某种策略转发至服务方
ribbon属于进程内lb,只是一个类库，集成于消费方进程,消费方通过他来获取服务提供方提供的地址
ribbon通过核心的组建IRule从特定的算法从特定的列表中选取一个要访问的服务
           RoundRobinRule  轮询
           RandomRule  随机
           AvailablityFilteringRule  过滤掉不可用服务选择轮询
           WeightedResponseTimeRule  根据平均响应时间，计算服务的权重
           RetryRule按照RoundRobinRule的策略获取服务,如果获取的服务失败,会在指定的时间里面重试,获取可用的服务
           BestAvailableRule 过滤掉故障的服务，选择并发量最小的服务
           ZoneAvoidanceRule默认规则，判断Server的性能和server可用性选择服务器




服务接口调用(客户端调用服务的简化工具)
fegin
通过接口的方法调用rest服务（不然得用rest+template）
fegin直接找到服务接口,由此进行服务调用的时候融合了ribbon

消息队列
Kafka、RabbitMQ、ActiveMQ等


服务配置中心管理
SpringCloudConfig、Chef等


服务路由（API网关）
zuul
Zuul包含了对请求的路由和过滤两个最主要的功能：
其中路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础而过滤器功能则负责对请求的处理过程进行干预，是实现请求校验、服务聚合等功能的基础.
Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他微服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。
注意：Zuul服务最终还是会注册进Eureka
提供=代理+路由+过滤三大功能


服务监控
Zabbix、Nagios、Metrics、Spectator等


全链路追踪
Zipkin，Brave、Dapper等


服务部署
Docker、OpenStack、Kubernetes等

数据流操作开发包
SpringCloud Stream（封装与Redis,Rabbit、

消息总线
Spring Cloud Bus


注册中心consule:
    分布式发现及配置管理中心,go语言开发


网关gateWay:
    spring5.0 springboot2.0  reactor等技术开发的网关
    底层使用netty加webflux技术
    1.能干嘛:
        反向代理,鉴权,流量控制,熔断,日志监控
    2.特性
        动态路由：能够匹配任何请求属性
        可以对路由指定predicate(断言)和filter(过滤器)
        集成hystrix的断路器功能
        集成SpringCloud服务发现功能
        易于编写的predicate和Filter
        请求限流功能及支持路径重写
    3.核心概念
        路由:
            构建网关的基本模块,由ID,目标URI,一系列断言和过滤器组成,如果断言为True就匹配该路由
        断言:
            参考java8的java.util.function.Predicate开发人员可以匹配HTTP请求中的所有内容,如果请求头与断言匹配
            则进行路由
        过滤:
            指spring框架中GateWayFilter实例,使用过滤器,可以在请求被路由前或者路由后对请求修改
    4.核心逻辑
        请求过来在Gateway handler Mapping 找到对应的匹配的路由,将其发送到Gateway Web Handler,handler再通过指定的
        过滤器链将请求发送到实际的服务执行业务逻辑,然后再Filter中做处理

消息总线cloudBus
    springCloudBus 配置Spring cloud config可以实现配置的动态刷新
    Bus 支持两种消息代理rabbitmq 与 kafka

springcloudStream：
    屏蔽底层中间件的差异,降低切换版本,统一消息的编程模型